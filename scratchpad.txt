commit 64d53cbd3a0c55989551c05b24e63c0bc1d8d619
Author: Pat Buah <38233063+EditUndo@users.noreply.github.com>
Date:   Thu Jun 12 22:00:18 2025 +0100

    Feat/Decoupling (#10)
   
    * chore: Update submodule URLs and add new a2a-samples submodule
    
    * chore: Update submodule a2a to latest commit
    
    * chore: Refactor task handling to use message-based parameters
    
    - Updated parameter types in A2AClient and A2AServer to use MessageSendParams instead of TaskSendParams for sending tasks.
    - Renamed related types and methods to reflect the new message-based approach.
    - Introduced a new submodule a2a-samples for example implementations.
    - Enhanced error handling and validation for message parameters across the codebase.
    
    * chore: Update A2A protocol to use message-based methods and enhance task handling
    
    - Refactored core methods to replace `tasks/send` with `message/send` and updated related streaming methods to `message/stream`.
    - Renamed push notification configuration methods to `tasks/pushNotificationConfig/set` and `tasks/pushNotificationConfig/get`.
    - Updated type definitions and interfaces to reflect the new message-based approach, including changes in `A2AClient`, `A2AServer`, and related types.
    - Enhanced error handling and validation for message parameters across the codebase.
    - Revised documentation in `README.md` and `llms.txt` to align with the new method names and functionalities.
    
    * chore: Update A2A schema and refactor imports for enhanced organization
    
    - Updated submodule a2a to the latest commit for improved functionality.
    - Refactored import paths in various files to align with the new schema structure under `schemas/a2a`.
    - Introduced new types and interfaces for error handling and task management within the A2A protocol.
    - Enhanced code organization by consolidating related types and definitions in the `schemas/a2a` directory.
    
    * refactor: Rename task-related methods to align with message-based approach
    
    - Renamed `sendTask` to `sendMessage` and `sendTaskSubscribe` to `sendStreamingMessage` in A2AClient for clarity.
    - Added deprecated methods for `sendTask` and `sendTaskSubscribe` to guide users towards the new method names.
    - Updated type definitions in the Client interface to reflect these changes and maintain backward compatibility.
    
    * chore: Add new MCP submodule and implement A2A agent logic
    
    - Added a new submodule for MCP integration, linking to the repository at https://github.com/EditUndo/artinet-mcp-use-ts.git.
    - Implemented the `a2a-mcp.ts` file to demonstrate A2A communication and MCP tool usage between `MathAgent` and `OrchestratorAgent`.
    - Introduced detailed documentation in `llms.txt` outlining the architecture, technologies, and functionalities of the multi-agent system.
    - Updated the quick server implementation to correct type references and enhance agent capabilities.
    
    * chore: Refactor A2A and MCP integration with enhanced context handling
    
    - Removed deprecated submodules for `a2a-samples` and `mcp-use`.
    - Updated `.gitmodules` to reflect the removal of obsolete submodules.
    - Enhanced `package.json` with new dependencies for improved functionality.
    - Refactored context handling in A2A and MCP services to utilize `ExecutionContext` for better parameter management.
    - Improved error handling and logging across various modules to ensure robustness.
    - Updated tests to align with the new context structure and validate message handling.
    
    * feat: Add NLWebExecutionContext interface for NLWeb protocol support
    
    - Introduced NLWebExecutionContext interface extending MCPExecutionContext, specifically for handling requests related to the NLWeb protocol.
    - Updated documentation to include descriptions for both MCPExecutionContext and NLWebExecutionContext, enhancing clarity on protocol-specific request handling.
    
    * chore: Refactor import paths to consolidate schema references
    
    - Updated import statements across multiple files to reference the new `schemas` directory instead of the previous `schema` structure.
    - Introduced a new `schemas/index.js` file to streamline exports from the `schemas` directory, enhancing code organization and maintainability.

diff --git a/.gitmodules b/.gitmodules
index 9bbd09a..5923cb4 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,3 @@
 [submodule "deps/a2a"]
 	path = deps/a2a
-	url = https://github.com/google/A2A.git
+	url = https://github.com/google-a2a/A2A.git
diff --git a/README.md b/README.md
index 375b051..8cf3269 100644
--- a/README.md
+++ b/README.md
@@ -57,7 +57,7 @@ Its got [serveral template projects](https://github.com/the-artinet-project/crea
 - **TypeScript First:** Fully written in TypeScript with comprehensive type definitions for a robust developer experience.
 - **Flexible Storage:** Offers built-in `InMemoryTaskStore` (development/testing) and `FileStore` (persistent), with the `TaskStore` interface allowing custom storage solutions.
 - **Protocol Compliance:** Implements the complete A2A specification using the official JSON schema, ensuring interoperability.
-- **Robust Streaming:** Reliable SSE support for `tasks/sendSubscribe` & `tasks/resubscribe` using `eventsource-parser`.
+- **Robust Streaming:** Reliable SSE support for `message/stream` & `tasks/resubscribe` using `eventsource-parser`.
 - **Configurable Logging:** Integrated structured logging via `pino`. Configurable levels using `configureLogger` and `LogLevel`.
 - **Advanced Customization:** Allows providing a custom `JSONRPCServerFactory` for fine-grained control over the JSON-RPC server, enabling integration with existing Express apps or adding custom methods.
 - **Comprehensive Testing:** Includes a suite of tests to ensure reliability and maintainability.
@@ -69,7 +69,7 @@ Its got [serveral template projects](https://github.com/the-artinet-project/crea
 | **Server**          | Host A2A-compliant agents. Handles protocol details, routing, SSE.          | `A2AServer`, `A2AServerParams`                                                               |
 | **Task Handling**   | Define agent logic using async generators.                                  | `TaskHandler`, `TaskContext`, `TaskYieldUpdate`                                              |
 | **Storage**         | Persist task state. In-memory and file-based options included.              | `TaskStore`, `InMemoryTaskStore`, `FileStore`                                                |
-| **Streaming (SSE)** | Handle real-time updates via SSE for `tasks/sendSubscribe`/`resubscribe`.   | `TaskStatusUpdateEvent`, `TaskArtifactUpdateEvent`                                           |
+| **Streaming (SSE)** | Handle real-time updates via SSE for `message/stream`/`resubscribe`.   | `TaskStatusUpdateEvent`, `TaskArtifactUpdateEvent`                                           |
 | **Logging**         | Configure structured logging for debugging and monitoring.                  | `logger`, `configureLogger`, `LogLevel`                                                      |
 | **Advanced Server** | Customize the underlying JSON-RPC server or integrate into existing apps.   | `JSONRPCServerFactory`, `CreateJSONRPCServerParams`, `createJSONRPCMethod`, A2A Method Types |
 | **Core Types**      | Based on the official A2A JSON Schema.                                      | `AgentCard`, `Task`, `Message`, `Part`, `Artifact`, etc.                                     |
@@ -184,7 +184,7 @@ The Artinet SDK provides several core classes and interfaces for building A2A cl
 | `A2AServerParams`                                         | Configuration object passed to the `A2AServer` constructor (port, store, card, basePath, handler, etc.).                           |
 | `AgentCard`                                               | Describes the agent's capabilities, metadata, skills, and endpoint URL.                                                            |
 | `Message`, `Part`, `Artifact`, `Task`, `TaskStatus`, etc. | Core types mirroring the structures defined in the A2A JSON Schema specification. Used for requests, responses, and task state.    |
-| `TaskStatusUpdateEvent`, `TaskArtifactUpdateEvent`        | Specific types for Server-Sent Events (SSE) received during streaming operations (`tasks/sendSubscribe`, `tasks/resubscribe`).     |
+| `TaskStatusUpdateEvent`, `TaskArtifactUpdateEvent`        | Specific types for Server-Sent Events (SSE) received during streaming operations (`message/stream`, `tasks/resubscribe`).     |
 | `LogLevel`                                                | Enum defining logging levels (`error`, `warn`, `info`, `debug`, `trace`) used with the built-in logger.                            |
 | `JSONRPCServerFactory`                                    | Function signature for providing a custom JSON-RPC server creation logic to `A2AServer` for advanced customization.                |
 | `CreateJSONRPCServerParams`                               | Object containing dependencies provided _to_ a `JSONRPCServerFactory` function.                                                    |
@@ -214,7 +214,7 @@ Interact with A2A-compliant agents using the `A2AClient`. See `examples/` for mo
 
 #### Basic Client Usage
 
-Send a task using `tasks/send`.
+Send a task using `message/send`.
 
 ```typescript
 import { A2AClient, Message } from "@artinet/sdk";
@@ -233,7 +233,7 @@ async function runBasicTask() {
 
 #### Streaming Updates
 
-Receive real-time updates via SSE using `tasks/sendSubscribe` (recommended).
+Receive real-time updates via SSE using `message/stream` (recommended).
 
 ```typescript
 import {
@@ -436,7 +436,7 @@ const myCustomSendMethod: SendTaskMethod = (
   callback
 ) => {
   const { taskStore, taskHandler, createTaskContext } = deps;
-  const taskId = extractTaskId(requestParams.id);
+  const { id: taskId } = requestParams;
   const { message, sessionId, metadata } = requestParams;
   ...
   callback(null, ...);
@@ -446,20 +446,20 @@ const myCustomRPCServer: JSONRPCServerFactory = (
   params: CreateJSONRPCServerParams
 ): JSONRPCServerType => {
   //Use a custom task/send method
-  const taskSendMethod = createJSONRPCMethod(params, myCustomSendMethod, "tasks/send");
+  const taskSendMethod = createJSONRPCMethod(params, myCustomSendMethod, "message/send");
   const taskGetMethod = createJSONRPCMethod(params, defaultGetTaskMethod, "tasks/get");
   const taskCancelMethod = createJSONRPCMethod(params, defaultCancelTaskMethod, "tasks/cancel");
 
   // Note: Push notifications are not fully implemented yet
-  const taskPushNotificationSetMethod = createJSONRPCMethod(params, defaultSetTaskPushNotificationMethod, "tasks/pushNotification/set");
-  const taskPushNotificationGetMethod = createJSONRPCMethod(params, defaultGetTaskPushNotificationMethod, "tasks/pushNotification/get");
+  const taskPushNotificationSetMethod = createJSONRPCMethod(params, defaultSetTaskPushNotificationMethod, "tasks/pushNotificationConfig/set");
+  const taskPushNotificationGetMethod = createJSONRPCMethod(params, defaultGetTaskPushNotificationMethod, "tasks/pushNotificationConfig/get");
 
   const rpcServer = new JSONRPCServer({
-    "tasks/send": taskSendMethod,
+    "message/send": taskSendMethod,
     "tasks/get": taskGetMethod,
     "tasks/cancel": taskCancelMethod,
-    "tasks/pushNotification/set": taskPushNotificationSetMethod,
-    "tasks/pushNotification/get": taskPushNotificationGetMethod,
+    "tasks/pushNotificationConfig/set": taskPushNotificationSetMethod,
+    "tasks/pushNotificationConfig/get": taskPushNotificationGetMethod,
   });
 
   return rpcServer;
@@ -476,7 +476,7 @@ const server = new A2AServer({
 
 Pass your factory function via the `createJSONRPCServer` option during `A2AServer` initialization.
 
-**Important:** The default `A2AServer` setup automatically adds Express middleware to handle Server-Sent Events (SSE) for `tasks/sendSubscribe` and `tasks/resubscribe`, as well as the `/agent/card` (and `/.well-known/agent.json`) GET endpoints. If you are **not** using `A2AServer` and integrating the Jayson server middleware into your own Express application, you **must** implement these SSE and card endpoints yourself to maintain full A2A compliance, especially for streaming functionality. See `src/server/lib/express-server.ts` for how the default server handles these routes.
+**Important:** The default `A2AServer` setup automatically adds Express middleware to handle Server-Sent Events (SSE) for `message/stream` and `tasks/resubscribe`, as well as the `/agent/card` (and `/.well-known/agent.json`) GET endpoints. If you are **not** using `A2AServer` and integrating the Jayson server middleware into your own Express application, you **must** implement these SSE and card endpoints yourself to maintain full A2A compliance, especially for streaming functionality. See `src/server/lib/express-server.ts` for how the default server handles these routes.
 
 ### Quick-Agents (Alpha)
 
diff --git a/deps/a2a b/deps/a2a
index b67527f..0ae9384 160000
--- a/deps/a2a
+++ b/deps/a2a
@@ -1 +1 @@
-Subproject commit b67527f2b4a7e7ce9e40bd003bbcf3d4b95367d6
+Subproject commit 0ae93843903dcba264f89b41fd031086ee17e0dc
diff --git a/llms.txt b/llms.txt
index 877c3ca..c7d4cd0 100644
--- a/llms.txt
+++ b/llms.txt
@@ -54,9 +54,9 @@ The SDK is distributed as the `@artinet/sdk` npm package.
     *   New types: `ServerDeploymentRequestParams`, `ServerDeploymentResponse` in `src/types/extended-schema.ts`. New proxy-related types (`TaskProxy`, `TaskManagerProps`, `ConnectAPICallback`, `ClientProxy`, `ClientFactory`, etc.) in `src/types/proxy.ts`.
 *   **Protocol Compliance:**
     *   Full implementation based on the official A2A JSON Schema (`a2a.json`).
-    *   Supports core methods: `tasks/send`, `tasks/get`, `tasks/cancel`.
-    *   Supports streaming method: `tasks/sendSubscribe`.
-    *   Supports push notification configuration methods: `tasks/pushNotification/set`, `tasks/pushNotification/get` (though full push *sending* logic might be agent-specific).
+    *   Supports core methods: `message/send`, `tasks/get`, `tasks/cancel`.
+    *   Supports streaming method: `message/stream`.
+    *   Supports push notification configuration methods: `tasks/pushNotificationConfig/set`, `tasks/pushNotificationConfig/get` (though full push *sending* logic might be agent-specific).
     *   Supports streaming resubscription: `tasks/resubscribe`.
     *   Agent registration now includes `tags: ["a2a"]`.
     *   Improved agent card fetching in client with URL validation and checks for card content.
diff --git a/package.json b/package.json
index ac890e9..daf4199 100644
--- a/package.json
+++ b/package.json
@@ -56,17 +56,20 @@
   "homepage": "https://github.com/the-artinet-project/artinet-sdk#readme",
   "dependencies": {
     "@artinet/metadata-validator": "^0.0.3",
+    "@modelcontextprotocol/sdk": "latest",
     "@types/cors": "^2.8.17",
     "@types/express": "^5.0.1",
+    "@types/mime-types": "^3.0.0",
     "@types/pino": "^7.0.4",
     "cors": "^2.8.5",
+    "esbuild": "^0.25.4",
     "eventsource-parser": "^3.0.1",
     "express": "^5.1.0",
     "jayson": "^4.2.0",
-    "esbuild": "^0.25.4",
     "pino": "^9.6.0",
     "pino-pretty": "^10.2.0",
-    "uuid": "^11.1.0"
+    "uuid": "^11.1.0",
+    "zod": "^3.25.42"
   },
   "devDependencies": {
     "@eslint/js": "^9.25.1",
@@ -75,6 +78,7 @@
     "@types/supertest": "latest",
     "@types/uuid": "^9.0.6",
     "eslint": "^9.25.1",
+    "express-list-routes": "^1.3.1",
     "globals": "^16.0.0",
     "jest": "^29.7.0",
     "msw": "^2.7.5",
diff --git a/quickstart/a2a-mcp.ts b/quickstart/a2a-mcp.ts
new file mode 100644
index 0000000..704c8ec
--- /dev/null
+++ b/quickstart/a2a-mcp.ts
@@ -0,0 +1,558 @@
+import {
+  A2AServer,
+  TaskHandler,
+  TaskContext,
+  InMemoryTaskStore,
+  logger,
+  configureLogger,
+  Artinet, // Assuming Artinet class is available (may need ArtinetClient or similar)
+  UpdateEvent, // Added based on linter error
+  AgentSkill, // Added based on linter error
+  AgentCard, // Assuming AgentCard is a type we can reference
+  MessagePart, // Assuming this is the type for parts of a message
+} from "@artinet/sdk";
+import { FastMCP } from "fastmcp";
+import { z } from "zod";
+import {
+  MCPClient,
+  HttpConnector,
+  type ToolCallRequest,
+  type ToolCallResponse,
+} from "@modelcontextprotocol/sdk";
+import http from "node:http";
+
+// --- Configuration ---
+configureLogger({ level: "info" });
+const ARTINET_API_KEY = process.env.ARTINET_API_KEY || "your_artinet_api_key";
+
+const MATH_AGENT_A2A_PORT = 4001;
+const MATH_AGENT_A2A_URL = `http://localhost:${MATH_AGENT_A2A_PORT}/a2a`;
+const MATH_AGENT_MCP_PORT = 7071;
+const MATH_AGENT_MCP_URL = `http://localhost:${MATH_AGENT_MCP_PORT}`;
+
+const ORCHESTRATOR_AGENT_A2A_PORT = 4002;
+const ORCHESTRATOR_AGENT_A2A_URL = `http://localhost:${ORCHESTRATOR_AGENT_A2A_PORT}/a2a`;
+
+const artinet = new Artinet({ apiKey: ARTINET_API_KEY });
+
+let mathToolServerInstance: http.Server | null = null;
+
+async function startMathAgentMcpServer(): Promise<void> {
+  const mathMcpServer = new FastMCP({
+    name: "MathAgentMCPServer",
+    version: "1.0.0",
+  });
+
+  mathMcpServer.addTool({
+    name: "add",
+    description: "Adds two numbers",
+    parameters: z.object({
+      a: z.number().describe("The first number"),
+      b: z.number().describe("The second number"),
+    }),
+    execute: async (args) => {
+      logger.info(
+        `[MathAgent-MCP] Executing 'add' tool with args: ${JSON.stringify(args)}`
+      );
+      const result = args.a + args.b;
+      return { result };
+    },
+  });
+
+  mathMcpServer.addTool({
+    name: "subtract",
+    description: "Subtracts the second number from the first",
+    parameters: z.object({
+      a: z.number().describe("The number to subtract from"),
+      b: z.number().describe("The number to subtract"),
+    }),
+    execute: async (args) => {
+      logger.info(
+        `[MathAgent-MCP] Executing 'subtract' tool with args: ${JSON.stringify(args)}`
+      );
+      const result = args.a - args.b;
+      return { result };
+    },
+  });
+
+  return new Promise((resolve, reject) => {
+    // Type assertion for http.Server to satisfy FastMCP's listen method if it expects a specific http server type.
+    mathToolServerInstance = mathMcpServer.listen(MATH_AGENT_MCP_PORT, () => {
+      logger.info(
+        `[MathAgent] MCP Tool Server running at ${MATH_AGENT_MCP_URL}`
+      );
+      resolve();
+    }) as http.Server;
+    if (mathToolServerInstance) {
+      mathToolServerInstance.on("error", reject);
+    }
+  });
+}
+
+// Adjusted UpdateEvent structure based on common patterns (assuming type and payload)
+// This is an assumption; the actual Artinet SDK UpdateEvent structure is needed for full accuracy.
+interface ArtinetUpdateEvent extends UpdateEvent {
+  type: "TaskStateChanged" | "NewMessage" | "TaskError" | "TaskCompleted"; // Example types
+  payload: {
+    taskId?: string;
+    state?: "working" | "completed" | "failed";
+    message?: {
+      role: "agent" | "user" | "system";
+      parts: MessagePart[];
+    };
+    error?: string;
+  };
+}
+
+const mathAgentLogic: TaskHandler = async function* (context: TaskContext) {
+  const userInput =
+    context.userMessage.parts[0].kind === "text"
+      ? context.userMessage.parts[0].text
+      : "";
+  logger.info(`[MathAgent-A2A] Received: "${userInput}"`);
+
+  const workingUpdate: ArtinetUpdateEvent = {
+    type: "TaskStateChanged",
+    payload: {
+      taskId: context.taskId,
+      state: "working",
+      message: {
+        role: "agent",
+        parts: [{ type: "text", text: "MathAgent processing..." }],
+      },
+    },
+  };
+  yield workingUpdate;
+
+  let completionMessageText: string;
+  if (userInput.toLowerCase().includes("what is your mcp endpoint")) {
+    completionMessageText = `My MCP tools are available at ${MATH_AGENT_MCP_URL}`;
+  } else {
+    completionMessageText = `MathAgent received: "${userInput}". I primarily offer tools via MCP at ${MATH_AGENT_MCP_URL}.`;
+  }
+  const completionUpdate: ArtinetUpdateEvent = {
+    type: "TaskCompleted", // Or TaskStateChanged with state: "completed"
+    payload: {
+      taskId: context.taskId,
+      state: "completed",
+      message: {
+        role: "agent",
+        parts: [{ type: "text", text: completionMessageText }],
+      },
+    },
+  };
+  yield completionUpdate;
+};
+
+const mathA2AServer = new A2AServer({
+  handler: mathAgentLogic,
+  taskStore: new InMemoryTaskStore(),
+  port: MATH_AGENT_A2A_PORT,
+  basePath: "/a2a",
+  card: {
+    name: "MathAgent",
+    url: MATH_AGENT_A2A_URL,
+    version: "1.0.0",
+    description:
+      "An agent that provides math tools (add, subtract) via an MCP endpoint and can be interacted with via A2A.",
+    skills: [
+      {
+        id: "inform_mcp",
+        name: "Inform MCP Endpoint",
+        description: "Tells where its MCP tools are hosted.",
+        inputModes: ["text"],
+        outputModes: ["text"],
+        tags: ["mcp", "info"],
+      },
+    ],
+    defaultInputModes: ["text"],
+    defaultOutputModes: ["text"],
+    capabilities: { streaming: true },
+    // Assuming a common way to add custom data if 'metadata' is not direct
+    customProperties: {
+      mcp_endpoint: MATH_AGENT_MCP_URL,
+      mcp_tools_available: ["add", "subtract"],
+    },
+  } as AgentCard,
+});
+
+const orchestratorMcpClient = new MCPClient({
+  connector: new HttpConnector({ uri: MATH_AGENT_MCP_URL }),
+});
+
+interface LLMToolCallDecision {
+  shouldCallTool: boolean;
+  toolName?: string;
+  toolArguments?: Record<string, any>;
+  reasoning?: string;
+  directResponse?: string;
+}
+
+async function decideToolCallWithLLM(
+  query: string,
+  tools: any[]
+): Promise<LLMToolCallDecision> {
+  const systemPrompt = `You are an orchestrator agent. Your goal is to answer the user's query.
+You can answer directly or use one of the available tools.
+If you decide to use a tool, respond with a JSON object with "toolName" and "toolArguments".
+Available tools:
+${tools.map((t) => `- Tool: "${t.name}", Description: "${t.description}", Arguments: ${JSON.stringify(t.parametersZod.shape)}`).join("\n")}
+
+User Query: "${query}"
+Respond with JSON for a tool call, or with your direct answer.
+Example tool call response: {"toolName": "add", "toolArguments": {"a": 5, "b": 3}}
+Example direct answer: {"directResponse": "The user is asking for a greeting."}`;
+
+  logger.info(`[OrchestratorAgent-LLM] System Prompt for LLM: ${systemPrompt}`);
+
+  let simulatedLlmResponseContent: any;
+  if (query.toLowerCase().includes("what is 5 plus 3")) {
+    simulatedLlmResponseContent = {
+      toolName: "add",
+      toolArguments: { a: 5, b: 3 },
+      reasoning: "User wants to add 5 and 3.",
+    };
+  } else if (query.toLowerCase().includes("calculate 10 minus 4")) {
+    simulatedLlmResponseContent = {
+      toolName: "subtract",
+      toolArguments: { a: 10, b: 4 },
+      reasoning: "User wants to subtract 4 from 10.",
+    };
+  } else if (query.toLowerCase().includes("tell math agent hello")) {
+    simulatedLlmResponseContent = {
+      directResponse: "I should tell MathAgent hello via A2A.",
+      toolName: "send_a2a_to_math_agent",
+      toolArguments: { message: "Hello from Orchestrator!" },
+    };
+  } else {
+    simulatedLlmResponseContent = {
+      directResponse: `I understood the query as: "${query}", but I don't have a specific tool for it beyond basic math or greeting MathAgent.`,
+    };
+  }
+  logger.info(
+    `[OrchestratorAgent-LLM] SIMULATED LLM Response: ${JSON.stringify(simulatedLlmResponseContent)}`
+  );
+
+  if (
+    simulatedLlmResponseContent.toolName &&
+    simulatedLlmResponseContent.toolArguments
+  ) {
+    return {
+      shouldCallTool: true,
+      toolName: simulatedLlmResponseContent.toolName,
+      toolArguments: simulatedLlmResponseContent.toolArguments,
+      reasoning:
+        simulatedLlmResponseContent.reasoning ||
+        "LLM decided to call this tool.",
+    };
+  }
+  return {
+    shouldCallTool: false,
+    directResponse:
+      simulatedLlmResponseContent.directResponse ||
+      "LLM decided to answer directly.",
+  };
+}
+
+async function executeMcpTool(
+  toolName: string,
+  toolArguments: Record<string, any>
+): Promise<any> {
+  logger.info(
+    `[OrchestratorAgent-MCPClient] Calling MCP tool: "${toolName}" with args: ${JSON.stringify(toolArguments)}`
+  );
+  try {
+    const request: ToolCallRequest = {
+      toolName,
+      input: toolArguments,
+    };
+    const response: ToolCallResponse =
+      await orchestratorMcpClient.callTool(request);
+
+    if (response.error) {
+      logger.error(
+        `[OrchestratorAgent-MCPClient] MCP Tool Error: ${response.error.message}`
+      );
+      throw new Error(response.error.message);
+    }
+    logger.info(
+      `[OrchestratorAgent-MCPClient] MCP Tool "${toolName}" Response: ${JSON.stringify(response.output)}`
+    );
+    return response.output;
+  } catch (error: any) {
+    logger.error(
+      `[OrchestratorAgent-MCPClient] Failed to call MCP tool "${toolName}": ${error.message}`
+    );
+    throw error;
+  }
+}
+
+async function sendA2AMessageToMathAgent(message: string): Promise<string> {
+  logger.info(
+    `[OrchestratorAgent-A2A] Attempting to send A2A message to MathAgent: "${message}"`
+  );
+  const mathAgentResponse = `MathAgent received your A2A message: "${message}". Acknowledged.`;
+  logger.info(
+    `[OrchestratorAgent-A2A] Simulated response from MathAgent: "${mathAgentResponse}"`
+  );
+  return mathAgentResponse;
+}
+
+const orchestratorAgentLogic: TaskHandler = async function* (
+  context: TaskContext
+) {
+  const userInput =
+    context.userMessage.parts[0].kind === "text"
+      ? context.userMessage.parts[0].text
+      : "";
+  logger.info(`[OrchestratorAgent-A2A] Received user query: "${userInput}"`);
+
+  yield {
+    type: "TaskStateChanged",
+    payload: {
+      taskId: context.taskId,
+      state: "working",
+      message: {
+        role: "agent",
+        parts: [{ type: "text", text: "Orchestrator analyzing query..." }],
+      },
+    },
+  } as ArtinetUpdateEvent;
+
+  const mathAgentTools = [
+    {
+      name: "add",
+      description: "Adds two numbers",
+      parametersZod: z.object({ a: z.number(), b: z.number() }),
+    },
+    {
+      name: "subtract",
+      description: "Subtracts b from a",
+      parametersZod: z.object({ a: z.number(), b: z.number() }),
+    },
+    {
+      name: "send_a2a_to_math_agent",
+      description: "Sends a text message to the MathAgent via A2A",
+      parametersZod: z.object({ message: z.string() }),
+    },
+  ];
+
+  const llmDecision = await decideToolCallWithLLM(userInput, mathAgentTools);
+  let finalUpdatePayload: ArtinetUpdateEvent["payload"];
+  let finalUpdateType: ArtinetUpdateEvent["type"] = "TaskCompleted";
+
+  if (
+    llmDecision.shouldCallTool &&
+    llmDecision.toolName &&
+    llmDecision.toolArguments
+  ) {
+    yield {
+      type: "TaskStateChanged",
+      payload: {
+        taskId: context.taskId,
+        state: "working",
+        message: {
+          role: "agent",
+          parts: [
+            {
+              type: "text",
+              text: `LLM decided to use tool: ${llmDecision.toolName}. ${llmDecision.reasoning || ""}`,
+            },
+          ],
+        },
+      },
+    } as ArtinetUpdateEvent;
+
+    if (llmDecision.toolName === "send_a2a_to_math_agent") {
+      const a2aResponse = await sendA2AMessageToMathAgent(
+        llmDecision.toolArguments.message
+      );
+      finalUpdatePayload = {
+        taskId: context.taskId,
+        state: "completed",
+        message: {
+          role: "agent",
+          parts: [
+            {
+              type: "text",
+              text: `A2A Interaction with MathAgent: ${a2aResponse}`,
+            },
+          ],
+        },
+      };
+    } else {
+      try {
+        const toolResult = await executeMcpTool(
+          llmDecision.toolName,
+          llmDecision.toolArguments
+        );
+        const finalAnswer = `Tool ${llmDecision.toolName} executed. Result: ${JSON.stringify(toolResult)}`;
+        finalUpdatePayload = {
+          taskId: context.taskId,
+          state: "completed",
+          message: {
+            role: "agent",
+            parts: [{ type: "text", text: finalAnswer }],
+          },
+        };
+      } catch (error: any) {
+        finalUpdateType = "TaskError"; // Or TaskStateChanged with state: "failed"
+        finalUpdatePayload = {
+          taskId: context.taskId,
+          state: "failed",
+          error: `Error executing tool ${llmDecision.toolName}: ${error.message}`,
+          message: {
+            role: "agent",
+            parts: [
+              {
+                type: "text",
+                text: `Error executing tool ${llmDecision.toolName}: ${error.message}`,
+              },
+            ],
+          },
+        };
+      }
+    }
+  } else {
+    finalUpdatePayload = {
+      taskId: context.taskId,
+      state: "completed",
+      message: {
+        role: "agent",
+        parts: [
+          {
+            type: "text",
+            text:
+              llmDecision.directResponse ||
+              "Orchestrator processed the query directly.",
+          },
+        ],
+      },
+    };
+  }
+  yield {
+    type: finalUpdateType,
+    payload: finalUpdatePayload,
+  } as ArtinetUpdateEvent;
+};
+
+const orchestratorA2AServer = new A2AServer({
+  handler: orchestratorAgentLogic,
+  taskStore: new InMemoryTaskStore(),
+  port: ORCHESTRATOR_AGENT_A2A_PORT,
+  basePath: "/a2a",
+  card: {
+    name: "OrchestratorAgent",
+    url: ORCHESTRATOR_AGENT_A2A_URL,
+    version: "1.0.0",
+    description:
+      "Orchestrates tasks, potentially using an LLM to call MCP tools on other agents (like MathAgent) or communicating via A2A.",
+    skills: [
+      {
+        id: "process_query",
+        name: "Process Complex Query",
+        description: "Processes a natural language query, using LLM and tools.",
+        inputModes: ["text"],
+        outputModes: ["text"],
+        tags: ["orchestration", "llm", "mcp"],
+      } as AgentSkill,
+    ],
+    defaultInputModes: ["text"],
+    defaultOutputModes: ["text"],
+    capabilities: { streaming: true },
+    customProperties: {
+      артinet_llm_integration_pattern: "uses artinet.v0.connect with MCP tools",
+    },
+  } as AgentCard,
+});
+
+async function startAllServices() {
+  try {
+    await startMathAgentMcpServer();
+    await mathA2AServer.start();
+    logger.info(`[MathAgent-A2A] A2A Server running at ${MATH_AGENT_A2A_URL}`);
+    await orchestratorA2AServer.start();
+    logger.info(
+      `[OrchestratorAgent-A2A] A2A Server running at ${ORCHESTRATOR_AGENT_A2A_URL}`
+    );
+    logger.info("All services started successfully!");
+  } catch (error) {
+    logger.error("Failed to start one or more services:", error);
+    process.exit(1);
+  }
+}
+
+async function testAgentQuery(
+  agentUrl: string,
+  query: string,
+  taskId: string = `task-${Date.now()}`
+): Promise<string> {
+  logger.info(`\n--- Testing Agent at ${agentUrl} with query: "${query}" ---`);
+  const body = {
+    taskId: taskId,
+    contextId: `context-${Date.now()}`,
+    request: {
+      role: "user",
+      parts: [{ type: "text", text: query }],
+    },
+  };
+  logger.info(
+    `Mock Test: To test, send a POST request to ${agentUrl}/tasks with body:`
+  );
+  logger.info(JSON.stringify(body, null, 2));
+  logger.info(
+    `Then GET ${agentUrl}/tasks/${taskId}/updates to stream results.`
+  );
+  logger.info(`--- End Test for: "${query}" ---`);
+  return `Test queued for "${query}" against ${agentUrl}. Check server logs for execution.`;
+}
+
+async function runTests() {
+  await new Promise((resolve) => setTimeout(resolve, 1000));
+  logger.info("\n🚀🚀🚀 RUNNING E2E TESTS 🚀🚀🚀");
+  await testAgentQuery(ORCHESTRATOR_AGENT_A2A_URL, "What is 5 plus 3?");
+  await testAgentQuery(ORCHESTRATOR_AGENT_A2A_URL, "calculate 10 minus 4");
+  await testAgentQuery(ORCHESTRATOR_AGENT_A2A_URL, "Tell MathAgent hello");
+  await testAgentQuery(MATH_AGENT_A2A_URL, "What is your MCP endpoint?");
+  logger.info("\n🏁🏁🏁 TESTS QUEUED 🏁🏁🏁");
+  logger.info("Monitor the server logs to see the interactions.");
+  logger.info(
+    "Use an A2A client (e.g., Postman, curl, or another Artinet client) to interact with the agents:"
+  );
+  logger.info(`- MathAgent A2A: ${MATH_AGENT_A2A_URL}`);
+  logger.info(`- OrchestratorAgent A2A: ${ORCHESTRATOR_AGENT_A2A_URL}`);
+  logger.info(
+    `- MathAgent MCP Tools: ${MATH_AGENT_MCP_URL} (e.g., POST to /mcp with MCP ToolCallRequest)`
+  );
+}
+
+async function main() {
+  await startAllServices();
+  await runTests();
+  logger.info("\nServers are running. Press Ctrl+C to stop.");
+}
+
+main().catch((error) => {
+  logger.error("Unhandled error in main execution:", error);
+  process.exit(1);
+});
+
+process.on("SIGINT", async () => {
+  logger.info("Caught SIGINT. Shutting down servers...");
+  if (mathToolServerInstance) {
+    await new Promise<void>((resolve) =>
+      mathToolServerInstance!.close(() => resolve())
+    );
+    logger.info("[MathAgent] MCP Server stopped.");
+  }
+  if (mathA2AServer) {
+    await mathA2AServer.stop();
+    logger.info("[MathAgent-A2A] A2A Server stopped.");
+  }
+  if (orchestratorA2AServer) {
+    await orchestratorA2AServer.stop();
+    logger.info("[OrchestratorAgent-A2A] A2A Server stopped.");
+  }
+  logger.info("All services stopped. Exiting.");
+  process.exit(0);
+});
diff --git a/quickstart/llms.txt b/quickstart/llms.txt
new file mode 100644
index 0000000..47d56ab
--- /dev/null
+++ b/quickstart/llms.txt
@@ -0,0 +1,132 @@
+# Detailed Report: A2A and MCP Integration Proof-of-Concept
+
+## 1. Overall Objective
+
+The primary goal of this proof-of-concept (PoC) as implemented in `quickstart/a2a-mcp.ts` is to demonstrate the integration of Agent-to-Agent (A2A) communication with the Model Context Protocol (MCP). The aim is to create a multi-agent system where:
+- Agents can be exposed as A2A services using the `@artinet/sdk`.
+- Agents can expose specific functionalities or "skills" as discrete tools via MCP, using `fastmcp` as the MCP server framework.
+- Agents can consume MCP tools (provided by themselves or other agents/services) using an MCP client library like `@modelcontextprotocol/sdk`.
+- A pattern for integrating Large Language Models (LLMs), such as those accessible via `artinet.v0.connect`, to make intelligent decisions about when and how to use available MCP tools or engage in A2A communication to fulfill user requests.
+
+This creates a flexible architecture where agents can collaborate at a high level (A2A) and also leverage fine-grained, standardized toolsets (MCP).
+
+## 2. Core Technologies & Libraries
+
+-   **`@artinet/sdk`**: The foundational SDK for building and running A2A agents. It provides `A2AServer` for hosting agents, `TaskHandler` for defining agent logic, and types like `AgentCard`, `UpdateEvent`, etc.
+-   **`fastmcp`**: A TypeScript framework used to create MCP servers. In this PoC, it's used by `MathAgent` to expose its mathematical functions as MCP tools. (Note: Assumed to be installed via `npm install fastmcp`).
+-   **`@modelcontextprotocol/sdk`**: The official TypeScript SDK for MCP. It's used by `OrchestratorAgent` to act as an MCP client, allowing it to connect to and call tools on MCP servers (like the one hosted by `MathAgent`). (Note: Assumed to be installed via `npm install @modelcontextprotocol/sdk`).
+-   **`zod`**: A TypeScript-first schema declaration and validation library. Used by `fastmcp` to define the expected parameters for MCP tools. (Note: Assumed to be installed as a dependency of `fastmcp` or separately).
+-   **`Node.js http module`**: Used by `fastmcp` under the hood to run its HTTP-based MCP server.
+
+## 3. Agent Architecture
+
+A two-agent system is implemented:
+
+### 3.1. `MathAgent`
+
+-   **Purpose**: A simple agent that provides basic mathematical operations.
+-   **A2A Interface (`A2AServer` on port 4001):**
+    -   Handles simple A2A text messages.
+    -   Can respond to a query like "what is your mcp endpoint?" by providing the URL to its MCP server.
+    -   Its `AgentCard` advertises its A2A capabilities and includes custom metadata pointing to its MCP endpoint and available tools.
+-   **MCP Provider (`fastmcp` server on port 7071):**
+    -   Exposes two tools:
+        -   `add`: Takes two numbers (`a`, `b`) and returns their sum.
+        -   `subtract`: Takes two numbers (`a`, `b`) and returns `a - b`.
+    -   Tool parameters are defined using `zod` schemas.
+
+### 3.2. `OrchestratorAgent`
+
+-   **Purpose**: A more complex agent designed to understand user queries, potentially delegate tasks to other agents (via A2A or MCP), and synthesize responses.
+-   **A2A Interface (`A2AServer` on port 4002):**
+    -   Accepts natural language queries from a user.
+    -   Its `TaskHandler` implements the core orchestration logic.
+-   **LLM Integration (Conceptual Design - Currently Simulated):**
+    -   The `decideToolCallWithLLM` function outlines how an LLM (like `artinet.v0.connect`) would be used.
+    -   The LLM would receive the user query and a list of available tools (including their descriptions and parameters, derived from MCP tool discovery or A2A agent cards).
+    -   The LLM's task is to determine:
+        1.  If a query can be answered directly.
+        2.  If an MCP tool should be called (and if so, which tool and with what arguments).
+        3.  If an A2A message should be sent to another agent.
+    -   The PoC currently *simulates* the LLM's JSON output for tool calls or direct responses due to the complexities of implementing robust LLM-based tool calling (parsing, error handling, multi-turn reasoning) within this single file.
+-   **MCP Consumer (`@modelcontextprotocol/sdk` client):**
+    -   An `MCPClient` instance is configured to connect to `MathAgent`'s MCP server URL (`http://localhost:7071`).
+    -   The `executeMcpTool` function uses this client to make `callTool` requests to the `MathAgent`.
+-   **A2A Communicator (Conceptual/Simulated):**
+    -   The `sendA2AMessageToMathAgent` function simulates sending a message to the `MathAgent` via A2A. A full A2A client implementation for this inter-agent communication is not present but would be needed in a production system.
+
+## 4. Key Functionalities Demonstrated
+
+-   **Multi-Agent Setup**: Running two distinct A2A agents (`MathAgent`, `OrchestratorAgent`) simultaneously.
+-   **MCP Tool Provision**: `MathAgent` uses `fastmcp` to define and serve `add` and `subtract` tools over HTTP.
+-   **MCP Tool Consumption**: `OrchestratorAgent` uses `@modelcontextprotocol/sdk` (`MCPClient` with `HttpConnector`) to connect to `MathAgent`'s MCP server and invoke its tools.
+-   **LLM Orchestration Pattern**: A clear (though simulated) pattern for how an LLM could be prompted to select appropriate tools or actions based on user input and available capabilities. This involves formatting tool descriptions for the LLM and parsing its structured (JSON) output.
+-   **A2A and MCP Synergy**: Agents communicate via A2A for higher-level tasks or information exchange, while MCP is used for standardized, often stateless, tool invocations. The `OrchestratorAgent` exemplifies this by using its A2A interface for user interaction and then deciding to use MCP for specific calculations.
+-   **Agent Card Customization**: The `MathAgent`'s card includes `customProperties` (pending linter fix for exact field name) to advertise its MCP endpoint.
+-   **Simulated Inter-Agent A2A**: The `OrchestratorAgent` has a placeholder for sending A2A messages to the `MathAgent`.
+
+## 5. Workflow Example: User asks OrchestratorAgent "What is 5 plus 3?"
+
+1.  User sends an A2A message "What is 5 plus 3?" to `OrchestratorAgent` (running on port 4002).
+2.  `OrchestratorAgent`'s `TaskHandler` receives the query.
+3.  It calls `decideToolCallWithLLM`.
+4.  The (simulated) LLM logic processes the query and the list of available tools (including "add" from `MathAgent`). It determines that the "add" tool should be called with arguments `{ a: 5, b: 3 }`.
+5.  `OrchestratorAgent` yields an update indicating it's calling the tool.
+6.  It then calls `executeMcpTool("add", { a: 5, b: 3 })`.
+7.  The `MCPClient` in `OrchestratorAgent` sends an MCP `ToolCallRequest` over HTTP to `MathAgent`'s `fastmcp` server (listening on port 7071).
+8.  `MathAgent`'s `fastmcp` server routes the request to the "add" tool's `execute` function.
+9.  The `add` function calculates `5 + 3 = 8` and returns `{ "result": 8 }`.
+10. This result is sent back as an MCP `ToolCallResponse` to `OrchestratorAgent`.
+11. `executeMcpTool` in `OrchestratorAgent` receives the output `{ "result": 8 }`.
+12. The `OrchestratorAgent`'s `TaskHandler` then formats this result into a final answer (e.g., "Tool add executed. Result: {\"result\":8}").
+13. `OrchestratorAgent` yields a final `completed` update via A2A to the user with the answer.
+
+## 6. Code Structure (`quickstart/a2a-mcp.ts`)
+
+The file is organized as follows:
+-   **Imports**: Necessary modules from `@artinet/sdk`, `fastmcp`, `@modelcontextprotocol/sdk`, `zod`, and `http`.
+-   **Configuration**: Constants for ports, URLs, and API keys. Initialization of the Artinet client.
+-   **`MathAgent` Section**:
+    -   `startMathAgentMcpServer()`: Initializes and starts the `fastmcp` server with "add" and "subtract" tools.
+    -   `mathAgentLogic`: The `TaskHandler` for `MathAgent`'s A2A interface.
+    -   `mathA2AServer`: `A2AServer` instance for `MathAgent`.
+-   **`OrchestratorAgent` Section**:
+    -   `orchestratorMcpClient`: `MCPClient` instance configured to connect to `MathAgent`'s MCP server.
+    -   `LLMToolCallDecision` interface.
+    -   `decideToolCallWithLLM()`: Simulates LLM decision-making.
+    -   `executeMcpTool()`: Handles calling MCP tools using the `MCPClient`.
+    -   `sendA2AMessageToMathAgent()`: Simulates A2A messaging.
+    -   `orchestratorAgentLogic`: The `TaskHandler` for `OrchestratorAgent`.
+    -   `orchestratorA2AServer`: `A2AServer` instance for `OrchestratorAgent`.
+-   **Main Execution & Test Functions**:
+    -   `startAllServices()`: Starts all A2A and MCP servers.
+    -   `testAgentQuery()`: A helper function to log how one might test the agents (actual A2A client calls are manual).
+    -   `runTests()`: Queues a series of test scenarios by calling `testAgentQuery`.
+    -   `main()`: Orchestrates starting services and running tests.
+    -   `SIGINT` handler: For graceful shutdown of servers.
+
+## 7. Current Challenges & Linter Errors (Summary from last automated check)
+
+The PoC is currently not fully runnable due to TypeScript compilation errors. These primarily stem from:
+-   **Module Not Found**: `fastmcp` and `@modelcontextprotocol/sdk` need to be installed in the project (`npm install fastmcp @modelcontextprotocol/sdk zod`).
+-   **`@artinet/sdk` Type Mismatches**:
+    -   `Artinet` class import: The linter indicates `Artinet` might not be an exported member, or might be named differently (e.g., `ArtinetClient`).
+    -   `MessagePart` type: Similar import issue.
+    -   `UpdateEvent`: The structure of objects yielded by `TaskHandler`s (`mathAgentLogic`, `orchestratorAgentLogic`) does not align with the SDK's `UpdateEvent` type. The attempt to create a compatible `ArtinetUpdateEvent` interface also leads to errors. The exact structure of `UpdateEvent` (e.g., whether it uses `state` and `message` directly, or a `type` and `payload` structure) needs to be correctly implemented.
+    -   `AgentCard`: The use of `customProperties` (previously `metadata`) is not recognized as a standard field. The correct mechanism for adding arbitrary data to an `AgentCard` in the Artinet SDK needs to be used.
+-   **`TaskContext` Property**: Errors indicate `context.taskId` should likely be `context.task.id` (or similar, depending on the actual structure of `context.task`).
+-   **Interface Extension**: `interface ArtinetUpdateEvent extends UpdateEvent` causes an error if `UpdateEvent` is not an object type suitable for extension.
+
+## 8. Next Steps (Implied for Full Functionality)
+
+1.  **Dependency Installation**: Ensure all external libraries (`fastmcp`, `@modelcontextprotocol/sdk`, `zod`) are installed.
+2.  **Resolve Linter Errors**:
+    -   Correct import statements for `Artinet` and `MessagePart` from `@artinet/sdk`.
+    -   Accurately define and use the `UpdateEvent` structure as expected by `@artinet/sdk`'s `TaskHandler`.
+    -   Use the correct property for accessing the task ID from `TaskContext`.
+    -   Use the correct mechanism for storing custom data in `AgentCard` or find an alternative method to share MCP endpoint information.
+3.  **Implement Real LLM Calls**: Replace the simulated LLM logic in `decideToolCallWithLLM` with actual calls to `artinet.v0.connect` (or a similar LLM service). This will involve crafting precise prompts and robustly parsing LLM JSON outputs, including error handling.
+4.  **Implement A2A Client for Inter-Agent Communication**: Replace `sendA2AMessageToMathAgent` simulation with actual A2A client logic, potentially using components from `@artinet/sdk` if available for client-side A2A calls, or a general HTTP client if A2A tasks are initiated via simple POST requests.
+5.  **Enhance Error Handling**: Add more robust error handling throughout, especially for network requests (MCP calls, A2A calls, LLM calls).
+6.  **Refine Tool Discovery**: Instead of hardcoding the `mathAgentTools` list in `OrchestratorAgent`, implement dynamic discovery (e.g., by querying `MathAgent`'s A2A card or a hypothetical MCP discovery endpoint).
+7.  **Expand Test Suite**: Create comprehensive automated tests for all functionalities. The current `testAgentQuery` is a mock and relies on manual inspection of logs or external A2A client tools.
diff --git a/quickstart/quick-server.ts b/quickstart/quick-server.ts
index 2ac34e6..092c101 100644
--- a/quickstart/quick-server.ts
+++ b/quickstart/quick-server.ts
@@ -10,15 +10,18 @@ configureLogger({ level: "info" });
 // Define the simplest possible agent logic
 const quickAgentLogic: TaskHandler = async function* (context: TaskContext) {
   const userInput =
-    context.userMessage.parts[0].type === "text"
+    context.userMessage.parts[0].kind === "text"
       ? context.userMessage.parts[0].text
       : "";
   logger.info(`Quick server received: ${userInput}`);
+
   yield {
     state: "working",
     message: { role: "agent", parts: [{ type: "text", text: "Thinking..." }] },
   };
+
   await new Promise((resolve) => setTimeout(resolve, 500)); // Simulate work
+
   yield {
     state: "completed",
     message: {
@@ -26,6 +29,7 @@ const quickAgentLogic: TaskHandler = async function* (context: TaskContext) {
       parts: [{ type: "text", text: `You said: ${userInput}` }],
     },
   };
+
   logger.info(`Quick server responded.`);
 };
 
@@ -40,7 +44,19 @@ const server = new A2AServer({
     url: "http://localhost:4000/a2a",
     version: "0.1.0",
     capabilities: { streaming: true }, // Our handler uses yield
-    skills: [{ id: "echo", name: "Echo Skill" }],
+    skills: [
+      {
+        id: "echo",
+        name: "Echo Skill",
+        description: "Echo the user's message",
+        tags: ["echo"],
+        inputModes: ["text"],
+        outputModes: ["text"],
+      },
+    ],
+    description: "A simple agent that echoes the user's message",
+    defaultInputModes: ["text"],
+    defaultOutputModes: ["text"],
   },
 });
 
diff --git a/src/client/a2a-client.ts b/src/client/a2a-client.ts
index 317f091..6dd5110 100644
--- a/src/client/a2a-client.ts
+++ b/src/client/a2a-client.ts
@@ -1,24 +1,25 @@
 import type {
   AgentCard,
-  SendTaskRequest,
+  SendMessageRequest,
   GetTaskRequest,
   CancelTaskRequest,
-  SetTaskPushNotificationRequest,
-  GetTaskPushNotificationRequest,
-  TaskSendParams,
+  SetTaskPushNotificationConfigRequest,
+  GetTaskPushNotificationConfigRequest,
+  MessageSendParams,
   TaskQueryParams,
   TaskIdParams,
   TaskPushNotificationConfig,
-  SendTaskResponse,
+  SendMessageResponse,
   GetTaskResponse,
   CancelTaskResponse,
-  SetTaskPushNotificationResponse,
-  GetTaskPushNotificationResponse,
+  SetTaskPushNotificationConfigResponse,
+  GetTaskPushNotificationConfigResponse,
   Task,
-  TaskArtifactUpdateEvent,
-  TaskStatusUpdateEvent,
-  SendTaskStreamingRequest,
+  SendStreamingMessageRequest,
   TaskResubscriptionRequest,
+  Message,
+  SendStreamingMessageResponse,
+  UpdateEvent,
 } from "../types/index.js";
 
 import {
@@ -128,30 +129,48 @@ export class A2AClient implements Client {
 
   /**
    * Sends a task request to the agent (non-streaming).
-   * @param params The parameters for the tasks/send method.
+   * @param params The parameters for the message/send method.
    * @returns A promise resolving to the Task object or null.
    */
-  async sendTask(params: TaskSendParams): Promise<Task | null> {
-    return await executeJsonRpcRequest<SendTaskRequest, SendTaskResponse>(
+  async sendMessage(params: MessageSendParams): Promise<Message | Task | null> {
+    return await executeJsonRpcRequest<SendMessageRequest, SendMessageResponse>(
       this.baseUrl,
-      "tasks/send",
+      "message/send",
       params,
       this.customHeaders
     );
   }
 
+  /**
+   * @deprecated Use sendMessage instead.
+   * Sends a task request to the agent (non-streaming).
+   * @param params The parameters for the message/send method.
+   * @returns A promise resolving to the Task object or null.
+   */
+  async sendTask(params: MessageSendParams): Promise<Message | Task | null> {
+    return await this.sendMessage(params);
+  }
+
   /**
    * Sends a task and returns a subscription to status and artifact updates.
    * @param params Task parameters for the request
    * @returns An AsyncIterable that yields TaskStatusUpdateEvent or TaskArtifactUpdateEvent payloads.
    */
-  sendTaskSubscribe(
-    params: TaskSendParams
-  ): AsyncIterable<TaskStatusUpdateEvent | TaskArtifactUpdateEvent> {
+  sendStreamingMessage(params: MessageSendParams): AsyncIterable<UpdateEvent> {
     return executeStreamEvents<
-      SendTaskStreamingRequest,
-      { result: TaskStatusUpdateEvent | TaskArtifactUpdateEvent }
-    >(this.baseUrl, "tasks/sendSubscribe", params, this.customHeaders);
+      SendStreamingMessageRequest,
+      SendStreamingMessageResponse
+    >(this.baseUrl, "message/stream", params, this.customHeaders);
+  }
+
+  /**
+   * @deprecated Use sendStreamingMessage instead.
+   * Sends a task and returns a subscription to status and artifact updates.
+   * @param params Task parameters for the request
+   * @returns An AsyncIterable that yields TaskStatusUpdateEvent or TaskArtifactUpdateEvent payloads.
+   */
+  sendTaskSubscribe(params: MessageSendParams): AsyncIterable<UpdateEvent> {
+    return this.sendStreamingMessage(params);
   }
 
   /**
@@ -184,30 +203,40 @@ export class A2AClient implements Client {
 
   /**
    * Sets or updates the push notification config for a task.
-   * @param params The parameters for the tasks/pushNotification/set method (which is TaskPushNotificationConfig).
+   * @param params The parameters for the tasks/pushNotificationConfig/set method (which is TaskPushNotificationConfig).
    * @returns A promise resolving to the confirmed TaskPushNotificationConfig or null.
    */
   async setTaskPushNotification(
     params: TaskPushNotificationConfig
   ): Promise<TaskPushNotificationConfig | null> {
     return await executeJsonRpcRequest<
-      SetTaskPushNotificationRequest,
-      SetTaskPushNotificationResponse
-    >(this.baseUrl, "tasks/pushNotification/set", params, this.customHeaders);
+      SetTaskPushNotificationConfigRequest,
+      SetTaskPushNotificationConfigResponse
+    >(
+      this.baseUrl,
+      "tasks/pushNotificationConfig/set",
+      params,
+      this.customHeaders
+    );
   }
 
   /**
    * Retrieves the currently configured push notification config for a task.
-   * @param params The parameters for the tasks/pushNotification/get method.
+   * @param params The parameters for the tasks/pushNotificationConfig/get method.
    * @returns A promise resolving to the TaskPushNotificationConfig or null.
    */
   async getTaskPushNotification(
     params: TaskIdParams
   ): Promise<TaskPushNotificationConfig | null> {
     return await executeJsonRpcRequest<
-      GetTaskPushNotificationRequest,
-      GetTaskPushNotificationResponse
-    >(this.baseUrl, "tasks/pushNotification/get", params, this.customHeaders);
+      GetTaskPushNotificationConfigRequest,
+      GetTaskPushNotificationConfigResponse
+    >(
+      this.baseUrl,
+      "tasks/pushNotificationConfig/get",
+      params,
+      this.customHeaders
+    );
   }
 
   /**
@@ -215,12 +244,10 @@ export class A2AClient implements Client {
    * @param params Parameters identifying the task to resubscribe to
    * @returns An AsyncIterable that yields TaskStatusUpdateEvent or TaskArtifactUpdateEvent payloads.
    */
-  resubscribeTask(
-    params: TaskQueryParams
-  ): AsyncIterable<TaskStatusUpdateEvent | TaskArtifactUpdateEvent> {
+  resubscribeTask(params: TaskQueryParams): AsyncIterable<UpdateEvent> {
     return executeStreamEvents<
       TaskResubscriptionRequest,
-      { result: TaskStatusUpdateEvent | TaskArtifactUpdateEvent }
+      SendStreamingMessageResponse
     >(this.baseUrl, "tasks/resubscribe", params, this.customHeaders);
   }
 
diff --git a/src/server/a2a-server.ts b/src/server/a2a-server.ts
index 45f965a..8df13c6 100644
--- a/src/server/a2a-server.ts
+++ b/src/server/a2a-server.ts
@@ -7,13 +7,16 @@ import type {
   AgentCard,
   Task,
   Message,
-  SendTaskStreamingRequest,
+  SendStreamingMessageRequest,
   TaskResubscriptionRequest,
+  MessageSendConfiguration,
+  TaskArtifactUpdateEvent,
+  A2AExecutionContext,
+  ExecutionContext,
 } from "../types/index.js";
-
+import { TaskState } from "../types/index.js";
 import {
   getCurrentTimestamp,
-  validateTaskSendParams,
   INVALID_PARAMS,
   TASK_NOT_FOUND,
   INVALID_REQUEST,
@@ -24,6 +27,7 @@ import {
   logDebug,
   register,
   logInfo,
+  validateSendMessageParams,
 } from "../utils/index.js";
 
 import {
@@ -33,14 +37,16 @@ import {
 } from "../transport/index.js";
 
 import { TaskStore, TaskAndHistory } from "./interfaces/store.js";
-import { TaskHandler, TaskContext } from "../types/context.js";
+import { TaskHandler, TaskContext } from "../types/index.js";
 import { A2AServerParams, JSONRPCServerType } from "./interfaces/params.js";
 import { Server } from "./interfaces/server.js";
 
 import { defaultCreateJSONRPCServer } from "./lib/json-middleware.js";
 import { createExpressServer } from "./lib/express-server.js";
-import { updateState, loadState } from "./lib/state.js";
+import { loadState, processUpdate } from "./lib/state.js";
 import { InMemoryTaskStore } from "./lib/storage/memory.js";
+import { v4 as uuidv4 } from "uuid";
+import { Protocol } from "../types/services/index.js";
 
 /**
  * Implements an A2A protocol compliant server using Express.
@@ -48,7 +54,7 @@ import { InMemoryTaskStore } from "./lib/storage/memory.js";
  * Uses Jayson for JSON-RPC handling.
  */
 export class A2AServer implements Server {
-  private taskHandler: TaskHandler;
+  protected taskHandler: TaskHandler;
   private taskStore: TaskStore;
   private corsOptions: CorsOptions;
   private basePath: string;
@@ -58,8 +64,8 @@ export class A2AServer implements Server {
   private app: express.Express;
   private fallbackPath: string;
   private register: boolean;
-  private activeCancellations: Set<string> = new Set();
-  private activeStreams: Map<string, Response[]> = new Map();
+  protected activeCancellations: Set<string> = new Set();
+  protected activeStreams: Map<string, Response[]> = new Map();
 
   /** The agent card representing this server */
   public card!: AgentCard;
@@ -311,15 +317,20 @@ export class A2AServer implements Server {
    * @param data Task and history data
    * @param res Response object
    */
-  public async onCancel(data: TaskAndHistory, res: Response): Promise<void> {
-    const currentData = await updateState(this.taskStore, data, CANCEL_UPDATE);
+  public async onCancel(
+    context: TaskContext,
+    data: TaskAndHistory,
+    res: Response
+  ): Promise<void> {
+    const cancelUpdate = CANCEL_UPDATE(data.task.id, context.contextId);
+    const currentData = await processUpdate(this.taskStore, {
+      context: context,
+      current: data,
+      update: cancelUpdate,
+    });
 
     // Send the canceled status
-    sendSSEEvent(res, {
-      id: currentData.task.id,
-      status: currentData.task.status,
-      final: true,
-    });
+    sendSSEEvent(res, currentData.task.id, cancelUpdate);
 
     this.closeStreamsForTask(currentData.task.id);
   }
@@ -335,27 +346,44 @@ export class A2AServer implements Server {
   }
 
   /**
-   * Handles the tasks/sendSubscribe method.
+   * Handles the message/stream method.
    * @param req The SendTaskRequest object
    * @param res The Express Response object
    */
   public async handleTaskSendSubscribe(
-    req: SendTaskStreamingRequest,
+    req: SendStreamingMessageRequest,
     res: Response
   ): Promise<void> {
-    validateTaskSendParams(req.params);
-    const { id: taskId, message, sessionId, metadata } = req.params;
+    validateSendMessageParams(req.params);
+    const { message, metadata } = req.params;
+    if (!message.taskId) {
+      throw INVALID_PARAMS("Missing task ID");
+    }
+    const taskId = message.taskId;
+    let contextId = message.contextId ?? "unknown";
+
+    const executionContext: ExecutionContext<
+      A2AExecutionContext<SendStreamingMessageRequest>
+    > = {
+      id: taskId,
+      protocol: Protocol.A2A,
+      getRequestParams: () => req.params,
+      isCancelled: () => this.activeCancellations.has(taskId),
+    };
 
     // Set up SSE stream with initial status
     setupSseStream(
       res,
       taskId,
       {
-        id: taskId,
+        taskId: taskId,
+        contextId: contextId,
+        kind: "status-update",
         status: {
-          state: "submitted",
+          state: TaskState.Submitted,
           timestamp: getCurrentTimestamp(),
         },
+        final: false,
       },
       this.addStreamForTask.bind(this)
     );
@@ -363,10 +391,10 @@ export class A2AServer implements Server {
     // Load or create task
     let currentData = await loadState(
       this.taskStore,
-      taskId,
       message,
-      sessionId,
-      metadata
+      metadata,
+      taskId,
+      contextId
     );
 
     // Create task context
@@ -375,30 +403,28 @@ export class A2AServer implements Server {
       message,
       currentData.history
     );
-
-    currentData = await updateState(
-      this.taskStore,
-      currentData,
-      WORKING_UPDATE
-    );
+    contextId = currentData.task.contextId || contextId;
+    const workingUpdate = WORKING_UPDATE(taskId, contextId);
+    currentData = await processUpdate(this.taskStore, {
+      context: context,
+      current: currentData,
+      update: workingUpdate,
+    });
 
     // Send the working status
-    sendSSEEvent(res, {
-      id: taskId,
-      status: currentData.task.status,
-      final: false,
-    });
+    sendSSEEvent(res, currentData.task.id, workingUpdate);
 
     // Process the task using the shared method
     await processTaskStream(
+      context,
       this.taskStore,
       this.taskHandler,
       res,
       taskId,
-      context,
       currentData,
       this.onCancel.bind(this),
-      this.onEnd.bind(this)
+      this.onEnd.bind(this),
+      executionContext
     );
   }
 
@@ -417,6 +443,16 @@ export class A2AServer implements Server {
       throw INVALID_PARAMS("Missing task ID");
     }
 
+    // Create execution context
+    const executionContext: ExecutionContext<
+      A2AExecutionContext<TaskResubscriptionRequest>
+    > = {
+      id: taskId,
+      protocol: Protocol.A2A,
+      getRequestParams: () => req.params,
+      isCancelled: () => this.activeCancellations.has(taskId),
+    };
+
     // Try to load the task
     const data = await this.taskStore.load(taskId);
     if (!data) {
@@ -428,9 +464,12 @@ export class A2AServer implements Server {
       res,
       taskId,
       {
-        id: taskId,
+        taskId: taskId,
+        contextId: data.task.contextId || "unknown",
+        kind: "status-update",
         status: data.task.status,
         final: false,
+        metadata: data.task.metadata,
       },
       this.addStreamForTask.bind(this)
     );
@@ -440,11 +479,15 @@ export class A2AServer implements Server {
       // If the task is already complete, send all artifacts and close
       if (data.task.artifacts && data.task.artifacts.length > 0) {
         for (const artifact of data.task.artifacts) {
-          sendSSEEvent(res, {
-            id: taskId,
+          const response: TaskArtifactUpdateEvent = {
+            taskId: taskId,
+            contextId: data.task.contextId || "unknown",
+            kind: "artifact-update",
             artifact,
-            final: true,
-          });
+            lastChunk: true,
+            metadata: data.task.metadata,
+          };
+          sendSSEEvent(res, taskId, response);
         }
       }
 
@@ -472,14 +515,15 @@ export class A2AServer implements Server {
 
     // Continue processing the task using the shared method
     await processTaskStream(
+      context,
       this.taskStore,
       this.taskHandler,
       res,
       taskId,
-      context,
       data,
       this.onCancel.bind(this),
-      this.onEnd.bind(this)
+      this.onEnd.bind(this),
+      executionContext
     );
   }
 
@@ -536,6 +580,8 @@ export class A2AServer implements Server {
         stateTransitionHistory: true,
       },
       skills: [],
+      defaultInputModes: ["text"],
+      defaultOutputModes: ["text"],
     };
   }
 
@@ -549,12 +595,15 @@ export class A2AServer implements Server {
   public createTaskContext(
     task: Task,
     userMessage: Message,
-    history: Message[]
+    history: Message[],
+    configuration?: MessageSendConfiguration
   ): TaskContext {
     return {
+      contextId: task.contextId ?? userMessage.contextId ?? uuidv4(),
       task,
       userMessage,
       history,
+      configuration,
       isCancelled: () => this.activeCancellations.has(task.id),
     };
   }
diff --git a/src/server/interfaces/params.ts b/src/server/interfaces/params.ts
index 9af8328..33d8cc2 100644
--- a/src/server/interfaces/params.ts
+++ b/src/server/interfaces/params.ts
@@ -1,34 +1,40 @@
 import { CorsOptions } from "cors";
+
 import {
   A2AResponse,
-  RequestParams,
   AgentCard,
   CancelTaskRequest,
   CancelTaskResponse,
-  GetTaskPushNotificationRequest,
-  GetTaskPushNotificationResponse,
+  GetTaskPushNotificationConfigRequest,
+  GetTaskPushNotificationConfigResponse,
   GetTaskRequest,
   GetTaskResponse,
   Message,
-  SendTaskRequest,
-  SendTaskResponse,
-  SendTaskStreamingRequest,
-  SetTaskPushNotificationRequest,
-  SetTaskPushNotificationResponse,
+  SendMessageRequest,
+  SendMessageResponse,
+  SendStreamingMessageRequest,
+  SetTaskPushNotificationConfigRequest,
+  SetTaskPushNotificationConfigResponse,
   Task,
   TaskResubscriptionRequest,
+  MessageSendConfiguration,
+  A2ARequest,
 } from "../../types/extended-schema.js";
+
 import { TaskStore } from "./store.js";
-import { TaskHandler, TaskContext } from "../../types/context.js";
+import { TaskHandler, TaskContext } from "../../types/index.js";
+
 import jayson from "jayson";
+
 import { ErrorHandler } from "../../utils/common/errors.js";
 import { JSONRPCError } from "../../types/extended-schema.js";
+
 import { Response } from "express";
 
 export type JSONRPCServerType = jayson.Server;
 export const JSONRPCServer = jayson.Server;
 
-export type JSONRPCCallback<Res = A2AResponse | null> = (
+export type JSONRPCCallback<Res = A2AResponse | Task | null> = (
   error: JSONRPCError | null,
   result?: Res
 ) => void;
@@ -71,7 +77,8 @@ export type CloseStreamsForTask = (taskId: string) => void;
 export type CreateTaskContext = (
   task: Task,
   message: Message,
-  history: Message[]
+  history: Message[],
+  configuration?: MessageSendConfiguration
 ) => TaskContext;
 
 /**
@@ -126,7 +133,7 @@ export type CreateExpressServerParams = Omit<
     rpcServer: JSONRPCServerType;
     errorHandler: ErrorHandler;
     onTaskSendSubscribe: (
-      req: SendTaskStreamingRequest,
+      req: SendStreamingMessageRequest,
       res: Response
     ) => Promise<void>;
     onTaskResubscribe: (
@@ -139,11 +146,11 @@ export type CreateExpressServerParams = Omit<
  * This can be used by consumers to implement their own server solutions
  */
 export type A2AMethodHandler<
-  Params extends RequestParams,
-  Result extends A2AResponse | null,
+  RequestParamT extends A2ARequest["params"],
+  Result extends A2AResponse | Message | Task | null,
 > = (
   deps: CreateJSONRPCServerParams,
-  requestParams: Params,
+  requestParams: RequestParamT,
   callback: JSONRPCCallback<Result>
 ) => Promise<void>;
 
@@ -152,8 +159,8 @@ export type A2AMethodHandler<
  * This can be used by consumers to implement their own server solutions
  */
 export type SendTaskMethod = A2AMethodHandler<
-  SendTaskRequest["params"],
-  SendTaskResponse | null
+  SendMessageRequest["params"],
+  SendMessageResponse | Message | Task | null
 >;
 
 /**
@@ -162,7 +169,7 @@ export type SendTaskMethod = A2AMethodHandler<
  */
 export type GetTaskMethod = A2AMethodHandler<
   GetTaskRequest["params"],
-  GetTaskResponse | null
+  GetTaskResponse | Task | null
 >;
 
 /**
@@ -171,7 +178,7 @@ export type GetTaskMethod = A2AMethodHandler<
  */
 export type CancelTaskMethod = A2AMethodHandler<
   CancelTaskRequest["params"],
-  CancelTaskResponse | null
+  CancelTaskResponse | Task | null
 >;
 
 /**
@@ -179,8 +186,8 @@ export type CancelTaskMethod = A2AMethodHandler<
  * This can be used by consumers to implement their own server solutions
  */
 export type SetTaskPushNotificationMethod = A2AMethodHandler<
-  SetTaskPushNotificationRequest["params"],
-  SetTaskPushNotificationResponse | null
+  SetTaskPushNotificationConfigRequest["params"],
+  SetTaskPushNotificationConfigResponse | null
 >;
 
 /**
@@ -188,6 +195,6 @@ export type SetTaskPushNotificationMethod = A2AMethodHandler<
  * This can be used by consumers to implement their own server solutions
  */
 export type GetTaskPushNotificationMethod = A2AMethodHandler<
-  GetTaskPushNotificationRequest["params"],
-  GetTaskPushNotificationResponse | null
+  GetTaskPushNotificationConfigRequest["params"],
+  GetTaskPushNotificationConfigResponse | null
 >;
diff --git a/src/server/interfaces/server.ts b/src/server/interfaces/server.ts
index 9e80194..7accb4a 100644
--- a/src/server/interfaces/server.ts
+++ b/src/server/interfaces/server.ts
@@ -6,14 +6,14 @@ import {
   AgentCard,
   Message,
   Task,
-  SendTaskStreamingRequest,
+  SendStreamingMessageRequest,
   TaskResubscriptionRequest,
 } from "../../types/index.js";
 
 import { TaskStore } from "./store.js";
 import { JSONRPCServerType } from "./params.js";
 import { TaskAndHistory } from "./store.js";
-import { TaskContext, TaskHandler } from "../../types/context.js";
+import { TaskContext, TaskHandler } from "../../types/index.js";
 
 export interface Server {
   start(): express.Express;
@@ -35,13 +35,17 @@ export interface Server {
     userMessage: Message,
     history: Message[]
   ): TaskContext;
-  onCancel(data: TaskAndHistory, res: Response): Promise<void>;
+  onCancel(
+    context: TaskContext,
+    data: TaskAndHistory,
+    res: Response
+  ): Promise<void>;
   onEnd(taskId: string, res: Response): Promise<void>;
   addStreamForTask(taskId: string, res: Response): void;
   removeStreamForTask(taskId: string, res: Response): void;
   closeStreamsForTask(taskId: string): void;
   handleTaskSendSubscribe(
-    req: SendTaskStreamingRequest,
+    req: SendStreamingMessageRequest,
     res: Response
   ): Promise<void>;
   handleTaskResubscribe(
diff --git a/src/server/interfaces/store.ts b/src/server/interfaces/store.ts
index b4c1786..e66fccc 100644
--- a/src/server/interfaces/store.ts
+++ b/src/server/interfaces/store.ts
@@ -12,7 +12,8 @@ export interface TaskAndHistory {
 }
 
 /**
- * Interface for task storage providers.
+ * @deprecated Use the Store interface instead.
+ * @description Interface for task storage providers.
  * Abstracts the storage mechanism for tasks and their message history.
  */
 export interface TaskStore {
@@ -31,3 +32,26 @@ export interface TaskStore {
    */
   load(taskId: string): Promise<TaskAndHistory | null>;
 }
+
+export interface Store<T> {
+  set(data: T, id?: string): Promise<void>;
+  get(id: string): Promise<T | null>;
+}
+
+// type newTaskStore = Transformed<
+//   Store<TaskAndHistory>,
+//   {
+//     set: "save";
+//     get: "load";
+//   }
+// >;
+
+// const newTaskStoreTest: newTaskStore = {
+//   save: async (data, id) => {
+//     console.log("save", data, id);
+//   },
+//   load: async (id) => {
+//     console.log("load", id);
+//     return null;
+//   },
+// };
diff --git a/src/server/lib/express-server.ts b/src/server/lib/express-server.ts
index de5d867..35b2826 100644
--- a/src/server/lib/express-server.ts
+++ b/src/server/lib/express-server.ts
@@ -1,9 +1,20 @@
 import cors from "cors";
 import express, { NextFunction, Request, Response } from "express";
 import { CreateExpressServerParams } from "../interfaces/params.js";
+import { ServiceManager } from "../../services/manager.js";
+import {
+  ExpressServerInterface,
+  ExpressServerOptions,
+} from "../../types/express.js";
+import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
+import { Protocol } from "../../types/services/protocol.js";
+import { v4 as uuidv4 } from "uuid";
+import http from "http";
+import { CorsOptions } from "cors";
 
 /**
- * Creates an Express server for the A2A protocol.
+ * @deprecated Use ExpressServer instead.
+ * @description Creates an Express server for the A2A protocol.
  * Handles task creation, streaming, cancellation and more.
  * Uses Jayson for JSON-RPC handling.
  */
@@ -41,7 +52,7 @@ export function createExpressServer(params: CreateExpressServerParams): {
       try {
         const body = req.body;
         if (body && body.method) {
-          if (body.method === "tasks/sendSubscribe") {
+          if (body.method === "message/stream") {
             return await onTaskSendSubscribe(body, res);
           } else if (body.method === "tasks/resubscribe") {
             return await onTaskResubscribe(body, res);
@@ -62,3 +73,177 @@ export function createExpressServer(params: CreateExpressServerParams): {
 
   return { app };
 }
+
+/**
+ * @description The express server class.
+ */
+export class ExpressServer
+  extends ServiceManager
+  implements ExpressServerInterface
+{
+  protected basePath: string;
+  protected fallbackPath: string;
+  protected serverInstance: http.Server | undefined;
+  protected port: number;
+  protected app: express.Express;
+  protected register: boolean;
+  protected corsOptions: CorsOptions;
+  private initialized: boolean = false;
+
+  /**
+   * @description The constructor.
+   * @param {ExpressServerOptions} params The express server options.
+   */
+  constructor(params: ExpressServerOptions) {
+    super(params);
+    this.corsOptions = params.corsOptions ?? {
+      origin: "*",
+      methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
+      allowedHeaders: ["Content-Type", "Authorization"],
+    };
+    this.basePath = params.basePath ?? "/";
+    this.fallbackPath = params.fallbackPath ?? "/";
+    this.port = params.port ?? 41241;
+    this.app = params.app ?? express();
+    this.app.use(cors(this.corsOptions));
+    this.app.use(express.json());
+    this.register = params.register ?? false;
+  }
+
+  /**
+   * @description Registers the routes.
+   * @param {StreamableHTTPServerTransport} transport The mcp transport.
+   */
+  registerRoutes(transport?: StreamableHTTPServerTransport): void {
+    this.app.get(`/.well-known/agent.json`, (_, res) => {
+      res.json(this.getCard());
+    });
+    this.app.get(`/${this.fallbackPath}`, (_, res) => {
+      res.json(this.getCard());
+    });
+    for (const service of Object.values(this.services)) {
+      const path =
+        this.basePath === "/"
+          ? `/${service.protocol}`
+          : `${this.basePath}/${service.protocol}`;
+      this.app.get(
+        path,
+        async (
+          req: express.Request,
+          res: express.Response,
+          next: express.NextFunction
+        ) => {
+          try {
+            const { id, method, params } = req.body;
+            const context = this.createRequestContext({
+              id,
+              protocol: service.protocol,
+              method,
+              params: {
+                ...params,
+                protocol: service.protocol,
+              },
+              request: req,
+              response: res,
+              transport:
+                service.protocol === Protocol.MCP
+                  ? transport
+                    ? transport
+                    : new StreamableHTTPServerTransport({
+                        sessionIdGenerator: () => uuidv4(),
+                      })
+                  : undefined,
+            });
+            return await this.onRequest(context).catch((error) => {
+              res.status(500).json({ id, error: error.message });
+            });
+          } catch (error) {
+            console.error("Error in GET", error);
+            next(error);
+          }
+        }
+      );
+
+      this.app.post(
+        path,
+        async (
+          req: express.Request,
+          res: express.Response,
+          next: express.NextFunction
+        ) => {
+          try {
+            const { id, method, params } = req.body;
+            const context = this.createRequestContext({
+              id,
+              protocol: service.protocol,
+              method,
+              params: {
+                ...params,
+                protocol: service.protocol,
+              },
+              request: req,
+              response: res,
+              transport:
+                service.protocol === Protocol.MCP
+                  ? transport
+                    ? transport
+                    : new StreamableHTTPServerTransport({
+                        sessionIdGenerator: () => uuidv4(),
+                      })
+                  : undefined,
+            });
+            return await this.onRequest(context).catch((error) => {
+              res.status(500).json({ error: error.message });
+            });
+          } catch (error) {
+            console.error("Error in POST", error);
+            next(error);
+          }
+        }
+      );
+
+      this.app.delete(path, async (_, res: express.Response) => {
+        res.status(500).json({ error: "Not implemented" });
+      });
+    }
+    this.initialized = true;
+  }
+
+  /**
+   * @description Gets the app.
+   * @returns {express.Express} The app.
+   */
+  getApp(): express.Express {
+    if (!this.initialized) {
+      this.registerRoutes();
+    }
+    return this.app;
+  }
+
+  /**
+   * @description Starts the server.
+   * @returns {Promise<http.Server>} The server.
+   */
+  async start(): Promise<http.Server> {
+    if (!this.initialized) {
+      this.registerRoutes();
+    }
+    if (this.serverInstance) {
+      return this.serverInstance;
+    }
+    this.serverInstance = this.app.listen(this.port, () => {
+      console.log(`Server is running on port ${this.port}`);
+    });
+    return this.serverInstance;
+  }
+
+  /**
+   * @description Stops the server.
+   */
+  async stop(): Promise<void> {
+    if (this.serverInstance) {
+      this.serverInstance.close();
+      this.serverInstance = undefined;
+    }
+  }
+}
diff --git a/src/server/lib/middleware/a2a-methods.ts b/src/server/lib/middleware/a2a-methods.ts
index e4ba7b6..a0c47e3 100644
--- a/src/server/lib/middleware/a2a-methods.ts
+++ b/src/server/lib/middleware/a2a-methods.ts
@@ -1,7 +1,18 @@
-import { TaskState, TaskYieldUpdate, Task } from "../../../types/index.js";
-import { extractTaskId, getCurrentTimestamp } from "../../../utils/index.js";
+import {
+  TaskState,
+  Task,
+  SetTaskPushNotificationConfigResponse,
+  ExecutionContext,
+  SendMessageRequest,
+  A2AExecutionContext,
+} from "../../../types/index.js";
+import { Protocol } from "../../../types/services/protocol.js";
+import {
+  getCurrentTimestamp,
+  validateSendMessageParams,
+} from "../../../utils/index.js";
 import { logError, logWarn } from "../../../utils/index.js";
-import { loadState, updateState } from "../state.js";
+import { loadState, processUpdate } from "../state.js";
 import {
   INTERNAL_ERROR,
   INVALID_PARAMS,
@@ -19,40 +30,75 @@ import {
   GetTaskPushNotificationMethod,
 } from "../../interfaces/params.js";
 import { FINAL_STATES } from "../../../utils/index.js";
-
+//todo move to the a2a plugin
 export const defaultSendTaskMethod: SendTaskMethod = async (
   deps,
   requestParams,
   callback
 ) => {
+  validateSendMessageParams(requestParams);
   const { taskStore, taskHandler, createTaskContext } = deps;
-  const taskId = extractTaskId(requestParams.id);
-  const { message, sessionId, metadata } = requestParams;
+  const { message, configuration, metadata } = requestParams;
 
   let currentData = await loadState(
     taskStore,
-    taskId,
     message,
-    sessionId,
-    metadata
+    metadata,
+    message.taskId,
+    message.contextId
   );
   const context = createTaskContext(
     currentData.task,
     message,
-    currentData.history
+    currentData.history,
+    configuration
   );
-  const generator = taskHandler(context);
+  const requestContext: A2AExecutionContext<SendMessageRequest> = {
+    id: context.contextId,
+    protocol: Protocol.A2A,
+    method: "message/send",
+    params: requestParams,
+    task: currentData.task,
+    request: null,
+    response: null,
+  };
+  const executionContext: ExecutionContext<
+    A2AExecutionContext<SendMessageRequest>
+  > = {
+    id: context.contextId,
+    protocol: Protocol.A2A,
+    getRequestParams: () => requestParams,
+    isCancelled: () => deps.activeCancellations.has(context.task.id),
+    requestContext: requestContext,
+  };
+  const generator = taskHandler(executionContext);
   try {
     for await (const update of generator) {
-      currentData = await updateState(taskStore, currentData, update);
+      currentData = await processUpdate(taskStore, {
+        context: context,
+        current: currentData,
+        update: update,
+      });
     }
-    return callback(null, currentData.task); // Success
+    const task: Task = {
+      ...currentData.task,
+      kind: "task",
+      history: [...(currentData.task.history || []), ...currentData.history],
+    };
+    return callback(null, task); // Success
   } catch (innerError) {
-    const failedUpdate: TaskYieldUpdate = FAILED_UPDATE(
+    const failedUpdate = FAILED_UPDATE(
+      currentData.task.id,
+      currentData.task.contextId || "unknown",
+      "failed-update",
       `Task processing failed: ${innerError instanceof Error ? innerError.message : String(innerError)}`
     );
     // Ensure state is saved before calling callback with error
-    await updateState(taskStore, currentData, failedUpdate);
+    await processUpdate(taskStore, {
+      context: context,
+      current: currentData,
+      update: failedUpdate,
+    });
     // Throwing here would be caught by createMethod's catch block
     if (innerError instanceof SystemError) {
       throw innerError;
@@ -67,14 +113,14 @@ export const defaultGetTaskMethod: GetTaskMethod = async (
   callback
 ) => {
   const { taskStore } = deps;
-  const taskId = extractTaskId(requestParams.id);
+  const { id: taskId } = requestParams;
   if (!taskId) throw INVALID_PARAMS("Missing task ID");
   const data = await taskStore.load(taskId);
   if (!data) {
     logError("taskGetLogic", "Task not found", { taskId });
     throw TASK_NOT_FOUND("Task Id: " + taskId);
   }
-  callback(null, data.task); // Success
+  return callback(null, data.task); // Success
 };
 
 export const defaultCancelTaskMethod: CancelTaskMethod = async (
@@ -83,29 +129,37 @@ export const defaultCancelTaskMethod: CancelTaskMethod = async (
   callback
 ) => {
   const { taskStore, activeCancellations, closeStreamsForTask } = deps;
-  const taskId = extractTaskId(requestParams.id);
+  const { id: taskId } = requestParams;
   if (!taskId) throw INVALID_PARAMS("Missing task ID");
   const data = await taskStore.load(taskId);
   if (!data) throw TASK_NOT_FOUND("Task Id: " + taskId);
   if (FINAL_STATES.includes(data.task.status.state)) {
-    throw TASK_NOT_CANCELABLE("Task is in a final state");
+    throw TASK_NOT_CANCELABLE(
+      "Task is in a final state: " + data.task.status.state
+    );
   }
 
   activeCancellations.add(taskId);
+
   const canceledTask: Task = {
     ...data.task,
     status: {
       state: "canceled" as TaskState,
       timestamp: getCurrentTimestamp(),
       message: {
+        kind: "message",
+        messageId: data.task.status.message?.messageId || "canceled-task",
         role: "agent" as const,
-        parts: [{ type: "text" as const, text: "Task was canceled." }],
+        parts: [{ kind: "text" as const, text: "Task was canceled." }],
       },
     },
   };
+
   const updatedData = { task: canceledTask, history: data.history };
   await taskStore.save(updatedData);
+
   closeStreamsForTask(taskId);
+
   return callback(null, canceledTask);
 };
 
@@ -113,35 +167,39 @@ export const defaultSetTaskPushNotificationMethod: SetTaskPushNotificationMethod
   async (deps, requestParams, callback) => {
     const { taskStore, card } = deps;
     logWarn(
-      "tasks/pushNotification/set",
+      "tasks/pushNotificationConfig/set",
       "Push notifications not fully implemented."
     );
     if (!card.capabilities?.pushNotifications) {
       throw PUSH_NOTIFICATION_NOT_SUPPORTED("Push notifications not supported");
     }
     const config = requestParams;
-    const taskId = extractTaskId(config.id);
-    if (!taskId || !config.pushNotificationConfig?.url) {
+    if (!config.taskId || !config.pushNotificationConfig?.url) {
       throw INVALID_PARAMS("Missing task ID or push notification URL");
     }
-    const data = await taskStore.load(taskId);
+    const data = await taskStore.load(config.taskId);
     if (!data) {
-      throw TASK_NOT_FOUND("Task Id: " + taskId);
+      throw TASK_NOT_FOUND("Task Id: " + config.taskId);
     }
-    return callback(null, config);
+    const response: SetTaskPushNotificationConfigResponse = {
+      id: config.taskId,
+      jsonrpc: "2.0",
+      result: config,
+    };
+    return callback(null, response);
   };
 
 export const defaultGetTaskPushNotificationMethod: GetTaskPushNotificationMethod =
   async (deps, requestParams, callback) => {
     const { taskStore, card } = deps;
     logWarn(
-      "tasks/pushNotification/get",
+      "tasks/pushNotificationConfig/get",
       "Push notifications not fully implemented."
     );
     if (!card.capabilities?.pushNotifications) {
       throw PUSH_NOTIFICATION_NOT_SUPPORTED("Push notifications not supported");
     }
-    const taskId = extractTaskId(requestParams.id);
+    const { id: taskId } = requestParams;
     if (!taskId) {
       throw INVALID_PARAMS("Missing task ID");
     }
diff --git a/src/server/lib/middleware/factory.ts b/src/server/lib/middleware/factory.ts
index 123bc15..0e5bf0a 100644
--- a/src/server/lib/middleware/factory.ts
+++ b/src/server/lib/middleware/factory.ts
@@ -19,7 +19,12 @@ import {
   defaultSetTaskPushNotificationMethod,
   defaultGetTaskPushNotificationMethod,
 } from "./a2a-methods.js";
-import { A2AResponse, RequestParams } from "../../../types/index.js";
+import {
+  A2AResponse,
+  Message,
+  Task,
+  A2ARequest,
+} from "../../../types/index.js";
 
 /**
  * Creates a JSON-RPC method handler from a function
@@ -29,13 +34,13 @@ import { A2AResponse, RequestParams } from "../../../types/index.js";
  * @returns A JSON-RPC method handler
  */
 export function createJSONRPCMethod<
-  Params extends RequestParams,
-  Result extends A2AResponse | null,
+  RequestParamT extends A2ARequest["params"],
+  Result extends A2AResponse | Task | Message | null,
 >(
   deps: CreateJSONRPCServerParams,
-  funct: A2AMethodHandler<Params, Result>,
+  funct: A2AMethodHandler<RequestParamT, Result>,
   methodName: string // Pass method name for logging
-): JSONRPCMethodHandler<Params, Result> {
+): JSONRPCMethodHandler<RequestParamT, Result> {
   return async (requestParams, callback) => {
     try {
       if (!requestParams) {
@@ -70,7 +75,7 @@ export const defaultCreateJSONRPCServer: CreateJSONRPCServer = (params) => {
   const taskSendMethod = createJSONRPCMethod(
     params,
     defaultSendTaskMethod,
-    "tasks/send"
+    "message/send"
   );
   const taskGetMethod = createJSONRPCMethod(
     params,
@@ -85,21 +90,21 @@ export const defaultCreateJSONRPCServer: CreateJSONRPCServer = (params) => {
   const taskPushNotificationSetMethod = createJSONRPCMethod(
     params,
     defaultSetTaskPushNotificationMethod,
-    "tasks/pushNotification/set"
+    "tasks/pushNotificationConfig/set"
   );
   const taskPushNotificationGetMethod = createJSONRPCMethod(
     params,
     defaultGetTaskPushNotificationMethod,
-    "tasks/pushNotification/get"
+    "tasks/pushNotificationConfig/get"
   );
 
   return new JSONRPCServer(
     {
-      "tasks/send": taskSendMethod,
+      "message/send": taskSendMethod,
       "tasks/get": taskGetMethod,
       "tasks/cancel": taskCancelMethod,
-      "tasks/pushNotification/set": taskPushNotificationSetMethod,
-      "tasks/pushNotification/get": taskPushNotificationGetMethod,
+      "tasks/pushNotificationConfig/set": taskPushNotificationSetMethod,
+      "tasks/pushNotificationConfig/get": taskPushNotificationGetMethod,
     },
     { reviver: undefined, replacer: undefined }
   );
diff --git a/src/server/lib/state.ts b/src/server/lib/state.ts
index abc292c..de45e94 100644
--- a/src/server/lib/state.ts
+++ b/src/server/lib/state.ts
@@ -1,163 +1,121 @@
-import {
-  getCurrentTimestamp,
-  isArtifactUpdate,
-  isTaskStatusUpdate,
-} from "../../utils/common/utils.js";
+import { getCurrentTimestamp } from "../../utils/common/utils.js";
 import {
   Task,
-  TaskStatus,
   Artifact,
   Message,
-  TaskYieldUpdate,
+  TaskState,
 } from "../../types/extended-schema.js";
 import { TaskAndHistory } from "../interfaces/store.js";
-import { INVALID_REQUEST } from "../../utils/common/errors.js";
 import { TaskStore } from "../interfaces/store.js";
+import { v4 as uuidv4 } from "uuid";
+import { update, UpdateProps } from "./update/base.js";
 
-export function updateTaskStatus(
-  task: Task,
-  update: TaskYieldUpdate
-): TaskStatus {
-  return { ...task.status, ...update, timestamp: getCurrentTimestamp() };
-}
-
-export function checkBounds(index: number, length: number): boolean {
-  return index >= 0 && index < length;
-}
-
+//todo: move to update.ts
 export function updateByIndex(
+  append: boolean,
   artifacts: Artifact[],
   index: number,
-  update: Artifact
+  artifactUpdate: Artifact
 ): { artifacts: Artifact[]; replaced: boolean } {
-  const existingArtifact: Artifact = artifacts[index];
-  if (update.append) {
-    //deep copy to avoid mutating original
-    const appendedArtifact: Artifact = JSON.parse(
-      JSON.stringify(existingArtifact)
-    );
-    appendedArtifact.parts.push(...update.parts);
+  if (append) {
+    const existingArtifact: Artifact = artifacts[index];
+    existingArtifact.parts.push(...artifactUpdate.parts);
 
-    if (update.metadata) {
-      appendedArtifact.metadata = {
-        ...(appendedArtifact.metadata || {}),
-        ...update.metadata,
+    if (artifactUpdate.metadata) {
+      existingArtifact.metadata = {
+        ...(existingArtifact.metadata || {}),
+        ...artifactUpdate.metadata,
       };
     }
 
-    if (update.lastChunk !== undefined) {
-      appendedArtifact.lastChunk = update.lastChunk;
+    if (artifactUpdate.description) {
+      existingArtifact.description = artifactUpdate.description;
     }
 
-    if (update.description) {
-      appendedArtifact.description = update.description;
+    if (artifactUpdate.name) {
+      existingArtifact.name = artifactUpdate.name;
     }
 
-    artifacts[index] = appendedArtifact;
+    artifacts[index] = existingArtifact;
   } else {
-    artifacts[index] = { ...update };
+    artifacts[index] = { ...artifactUpdate };
   }
   return { artifacts, replaced: true };
 }
 
-export function updateByName(
-  artifacts: Artifact[],
-  update: Artifact
-): { artifacts: Artifact[]; replaced: boolean } {
-  const namedIndex = artifacts.findIndex((a) => a.name === update.name);
-  if (namedIndex >= 0) {
-    artifacts[namedIndex] = { ...update };
-    return { artifacts, replaced: true };
-  }
-  return { artifacts: artifacts, replaced: false };
-}
-
+//todo: move to update.ts
 export function processArtifactUpdate(
+  append: boolean,
   artifacts: Artifact[],
-  update: Artifact
-): { artifacts: Artifact[]; replaced: boolean } {
-  const existingIndex = update.index ?? -1;
+  artifactUpdate: Artifact
+): Artifact[] {
+  const existingIndex = artifacts.findIndex(
+    (a) => a.artifactId === artifactUpdate.artifactId
+  );
+
   let replaced = false;
   let newArtifacts = artifacts;
-  if (checkBounds(existingIndex, artifacts.length)) {
+
+  if (existingIndex !== -1) {
     ({ artifacts: newArtifacts, replaced } = updateByIndex(
+      append,
       artifacts,
       existingIndex,
-      update
+      artifactUpdate
     ));
-  } else if (update.name) {
-    ({ artifacts: newArtifacts, replaced } = updateByName(artifacts, update));
   }
   if (!replaced) {
-    newArtifacts.push({ ...update });
-    if (newArtifacts.some((a) => a.index !== undefined)) {
-      newArtifacts.sort((a, b) => (a.index ?? 0) - (b.index ?? 0));
-    }
-    replaced = true;
+    newArtifacts.push({ ...artifactUpdate });
   }
-  return { artifacts: newArtifacts, replaced };
+  return newArtifacts;
 }
 
-export async function updateState(
+export async function processUpdate(
   taskStore: TaskStore,
-  current: TaskAndHistory,
-  update: TaskYieldUpdate
+  updateProps: UpdateProps
 ): Promise<TaskAndHistory> {
-  const newTask = { ...current.task };
-  const newHistory = [...current.history];
-
-  if (isTaskStatusUpdate(update)) {
-    newTask.status = updateTaskStatus(newTask, update);
-    if (update.message?.role === "agent") {
-      newHistory.push(update.message);
-    }
-  } else if (isArtifactUpdate(update)) {
-    const artifacts = !newTask.artifacts ? [] : [...newTask.artifacts];
-    const { artifacts: newArtifacts, replaced } = processArtifactUpdate(
-      artifacts,
-      update
-    );
-    if (!replaced) {
-      throw INVALID_REQUEST("Invalid artifact update");
-    }
-    newTask.artifacts = newArtifacts;
+  if (!(await update(updateProps))) {
+    throw new Error("processUpdate: Invalid update");
   }
-
-  const currentData = { task: newTask, history: newHistory };
-  await taskStore.save(currentData);
-
-  return currentData;
+  await taskStore.save(updateProps.current);
+  return updateProps.current;
 }
 
 /**
  * Loads or creates a task and its history.
  * @param taskId The task ID
  * @param message The message to process
- * @param sessionId Optional session ID
+ * @param contextId Optional context ID
  * @param metadata Optional metadata
  * @returns The task and history
  */
 export async function loadState(
   taskStore: TaskStore,
-  taskId: string,
   message: Message,
-  sessionId?: string,
-  metadata?: Record<string, unknown>
+  metadata?: Record<string, unknown>,
+  taskId?: string,
+  contextId?: string
 ): Promise<TaskAndHistory> {
-  const existingData = await taskStore.load(taskId);
-  if (existingData) {
-    return existingData;
+  if (taskId) {
+    const existingData: TaskAndHistory | null = await taskStore.load(taskId);
+    if (existingData) {
+      return existingData;
+    }
   }
+
   const timestamp = getCurrentTimestamp();
   const newTask: Task = {
-    id: taskId,
-    sessionId: sessionId,
+    id: taskId ?? uuidv4(),
+    contextId: contextId ?? uuidv4(),
+    kind: "task",
     status: {
-      state: "submitted",
+      state: TaskState.Submitted,
       timestamp,
     },
     metadata: metadata,
   };
+  message.taskId = newTask.id;
+  message.contextId = newTask.contextId;
   const newHistory: Message[] = [message];
   return { task: newTask, history: newHistory };
 }
diff --git a/src/server/lib/storage/memory.ts b/src/server/lib/storage/memory.ts
index 8fdd79f..7d4d021 100644
--- a/src/server/lib/storage/memory.ts
+++ b/src/server/lib/storage/memory.ts
@@ -33,7 +33,6 @@ export class InMemoryTaskStore implements TaskStore {
    */
   async save(data: TaskAndHistory): Promise<void> {
     logDebug("InMemoryTaskStore", `Saving task: ${data.task.id}`);
-
     // Store copies to prevent internal mutation if caller reuses objects
     this.store.set(data.task.id, {
       task: { ...data.task },
diff --git a/src/server/lib/update/base.ts b/src/server/lib/update/base.ts
new file mode 100644
index 0000000..90df4f1
--- /dev/null
+++ b/src/server/lib/update/base.ts
@@ -0,0 +1,145 @@
+import { TaskContext } from "../../../types/index.js";
+import {
+  Message,
+  Task,
+  TaskArtifactUpdateEvent,
+  TaskStatusUpdateEvent,
+  UpdateEvent,
+} from "../../../types/extended-schema.js";
+import { getCurrentTimestamp } from "../../../utils/common/utils.js";
+import { logError } from "../../../utils/logging/log.js";
+import { TaskAndHistory } from "../../interfaces/store.js";
+import { processArtifactUpdate } from "../state.js";
+
+export enum UpdateKind {
+  Message = "message",
+  Task = "task",
+  StatusUpdate = "status-update",
+  ArtifactUpdate = "artifact-update",
+}
+
+export interface UpdateProps<T extends UpdateEvent = UpdateEvent> {
+  context: TaskContext;
+  current: TaskAndHistory;
+  update: T;
+}
+
+export type Update<T extends UpdateEvent> = (
+  props: UpdateProps<T>
+) => Promise<boolean>;
+
+const isMessageInHistory = (task: Task, message: Message) => {
+  return task.history?.find((msg) => msg.messageId === message.messageId);
+};
+
+const updateHistory = (current: TaskAndHistory, updateMessage: Message) => {
+  if (!isMessageInHistory(current.task, updateMessage)) {
+    current.history = [...(current.history ?? []), updateMessage];
+    current.task.history = [...(current.task.history ?? []), updateMessage];
+  }
+};
+
+export const updateMessage: Update<Message> = async (props) => {
+  const { context, update } = props;
+  if (!update || update.kind !== UpdateKind.Message) {
+    logError("updateMessage", "Invalid update", update);
+    return false;
+  }
+  context.latestUserMessage = update;
+  return true;
+};
+
+export const updateTask: Update<Task> = async (props) => {
+  const { context, current, update } = props;
+  if (!update || update.kind !== UpdateKind.Task) {
+    logError("updateTask", "Invalid update kind", update);
+    return false;
+  }
+  current.task = { ...current.task, ...update };
+  if (
+    context.latestUserMessage &&
+    !isMessageInHistory(current.task, context.latestUserMessage)
+  ) {
+    current.task.history = [
+      context.latestUserMessage,
+      ...(current.task.history ?? []),
+    ];
+    current.history = [context.latestUserMessage, ...(current.history ?? [])];
+  }
+  return true;
+};
+
+export const updateTaskStatusUpdate: Update<TaskStatusUpdateEvent> = async (
+  props
+) => {
+  const { current, update } = props;
+  if (!update || update.kind !== UpdateKind.StatusUpdate) {
+    logError("updateTaskStatusUpdate", "Invalid update kind", update);
+    return false;
+  }
+  if (current.task.id === update.taskId) {
+    current.task.status = update.status;
+    current.task.status.timestamp = getCurrentTimestamp();
+    if (update.status.message) {
+      updateHistory(current, update.status.message);
+    }
+    return true;
+  }
+  logError("updateTaskStatusUpdate", "Invalid task id", update);
+  return false;
+};
+
+export const updateTaskArtifactUpdate: Update<TaskArtifactUpdateEvent> = async (
+  props
+) => {
+  const { current, update } = props;
+  if (!update || update.kind !== UpdateKind.ArtifactUpdate) {
+    logError("updateTaskArtifactUpdate", "Invalid update kind", update);
+    return false;
+  }
+  if (current.task.id === update.taskId) {
+    current.task.artifacts = processArtifactUpdate(
+      update.append ?? false,
+      current.task.artifacts ?? [],
+      update.artifact
+    );
+  }
+  return true;
+};
+
+export const update: Update<UpdateEvent> = async (props): Promise<boolean> => {
+  const { context, current, update } = props;
+  if (!update || !update.kind) {
+    logError("update", "Invalid update", update);
+    return false;
+  }
+
+  switch (update.kind) {
+    case UpdateKind.Message:
+      return updateMessage({
+        context,
+        current,
+        update: update as Message,
+      });
+    case UpdateKind.Task:
+      return updateTask({
+        context,
+        current,
+        update: update as Task,
+      });
+    case UpdateKind.StatusUpdate:
+      return updateTaskStatusUpdate({
+        context,
+        current,
+        update: update as TaskStatusUpdateEvent,
+      });
+    case UpdateKind.ArtifactUpdate:
+      return updateTaskArtifactUpdate({
+        context,
+        current,
+        update: update as TaskArtifactUpdateEvent,
+      });
+    default:
+      return false;
+  }
+};
diff --git a/src/services/a2a/index.ts b/src/services/a2a/index.ts
new file mode 100644
index 0000000..00d1e84
--- /dev/null
+++ b/src/services/a2a/index.ts
@@ -0,0 +1,2 @@
+export * from "./repository.js";
+export * from "./service.js";
diff --git a/src/services/a2a/repository.ts b/src/services/a2a/repository.ts
new file mode 100644
index 0000000..2217344
--- /dev/null
+++ b/src/services/a2a/repository.ts
@@ -0,0 +1,171 @@
+import { TaskAndHistory, TaskStore } from "../../server/interfaces/store.js";
+import {
+  AgentCard,
+  Message,
+  MessageSendConfiguration,
+  Task,
+} from "../../types/index.js";
+import { TaskContext } from "../../types/index.js";
+import { CANCEL_UPDATE } from "../../utils/index.js";
+import { processUpdate } from "../../server/lib/state.js";
+import { sendSSEEvent } from "../../transport/streaming/stream.js";
+import { logDebug } from "../../utils/logging/log.js";
+import { InMemoryTaskStore } from "../../server/lib/storage/memory.js";
+import {
+  A2ARepositoryInterface,
+  A2ARepositoryParams,
+} from "../../types/services/a2a/repository.js";
+
+import { v4 as uuidv4 } from "uuid";
+import express, { Response } from "express";
+
+/**
+ * @description The A2ARepository class.
+ */
+export class A2ARepository implements A2ARepositoryInterface {
+  protected taskStore: TaskStore;
+  protected basePath: string;
+  protected fallbackPath: string;
+  protected port: number;
+  protected app: express.Express;
+  protected register: boolean;
+  protected activeCancellations: Set<string>;
+  protected activeStreams: Map<string, Response[]>;
+  protected card: AgentCard;
+
+  constructor(params: A2ARepositoryParams) {
+    this.taskStore = params.taskStore ?? new InMemoryTaskStore();
+    this.basePath = params.basePath ?? "/";
+    this.fallbackPath = params.fallbackPath ?? "agent-card";
+    this.port = params.port ?? 3000;
+    this.app = params.app ?? express();
+    this.register = params.register ?? false;
+    this.card = params.card;
+    this.activeCancellations = new Set();
+    this.activeStreams = new Map();
+  }
+
+  public getCard(): AgentCard {
+    return this.card;
+  }
+
+  public getActiveCancellations(): Set<string> {
+    return this.activeCancellations;
+  }
+
+  public getTaskStore(): TaskStore {
+    return this.taskStore;
+  }
+
+  /**
+   * Creates a TaskContext object for a task handler.
+   * @param task The task
+   * @param userMessage The user message
+   * @param history The message history
+   * @returns A TaskContext object
+   */
+  createTaskContext(
+    task: Task,
+    userMessage: Message,
+    history: Message[],
+    configuration?: MessageSendConfiguration
+  ): TaskContext {
+    return {
+      contextId: task.contextId ?? userMessage.contextId ?? uuidv4(),
+      task,
+      userMessage,
+      history,
+      configuration,
+      isCancelled: () => this.activeCancellations.has(task.id),
+    };
+  }
+
+  /**
+   * Handles task cancellation
+   * @param data Task and history data
+   * @param res Response object
+   */
+  async onCancel(
+    context: TaskContext,
+    data: TaskAndHistory,
+    res: Response
+  ): Promise<void> {
+    const cancelUpdate = CANCEL_UPDATE(data.task.id, context.contextId);
+    const currentData = await processUpdate(this.taskStore, {
+      context: context,
+      current: data,
+      update: cancelUpdate,
+    });
+
+    // Send the canceled status
+    sendSSEEvent(res, currentData.task.id, cancelUpdate);
+
+    this.closeStreamsForTask(currentData.task.id);
+  }
+
+  /**
+   * Adds a response stream to the tracking map for a task.
+   * @param taskId The task ID
+   * @param res The response stream
+   */
+  public addStreamForTask(taskId: string, res: Response): void {
+    if (!this.activeStreams.has(taskId)) {
+      this.activeStreams.set(taskId, []);
+    }
+    logDebug("A2AServer", "Adding stream for task", {
+      taskId,
+      activeStreams: this.activeStreams,
+    });
+    this.activeStreams.get(taskId)?.push(res);
+  }
+
+  /**
+   * Removes a response stream from the tracking map for a task.
+   * @param taskId The task ID
+   * @param res The response stream
+   */
+  public removeStreamForTask(taskId: string, res: Response): void {
+    const streams = this.activeStreams.get(taskId);
+    if (streams) {
+      const index = streams.indexOf(res);
+      if (index !== -1) {
+        streams.splice(index, 1);
+        if (streams.length === 0) {
+          logDebug("A2AServer", "Removing stream for task", {
+            taskId,
+            activeStreams: this.activeStreams,
+          });
+          this.activeStreams.delete(taskId);
+        }
+      }
+    }
+  }
+
+  /**
+   * Closes any active streams for a task.
+   * @param taskId The task ID
+   */
+  public closeStreamsForTask(taskId: string): void {
+    const streams = this.activeStreams.get(taskId);
+    if (streams) {
+      // Send close event to all streams
+      for (const stream of streams) {
+        if (stream.writable) {
+          stream.write("event: close\ndata: {}\n\n");
+          stream.end();
+        }
+      }
+      this.activeStreams.delete(taskId);
+    }
+  }
+
+  /**
+   * Handles cleanup when a task stream ends
+   * @param taskId The task ID
+   * @param res Response object
+   */
+  public async onEnd(taskId: string, res: Response): Promise<void> {
+    this.activeCancellations.delete(taskId);
+    this.removeStreamForTask(taskId, res);
+  }
+}
diff --git a/src/services/a2a/service.ts b/src/services/a2a/service.ts
new file mode 100644
index 0000000..aa6d989
--- /dev/null
+++ b/src/services/a2a/service.ts
@@ -0,0 +1,384 @@
+import {
+  defaultCancelTaskMethod,
+  createJSONRPCMethod,
+  defaultGetTaskPushNotificationMethod,
+  defaultSetTaskPushNotificationMethod,
+  defaultGetTaskMethod,
+  defaultSendTaskMethod,
+  CreateJSONRPCServerParams,
+  JSONRPCCallback,
+} from "../../server/index.js";
+import {
+  Task,
+  Message,
+  TaskResubscriptionRequest,
+  SendStreamingMessageRequest,
+  SendMessageRequest,
+  SendMessageResponse,
+  A2ARequest,
+  A2AResponse,
+  GetTaskRequest,
+  CancelTaskRequest,
+  SetTaskPushNotificationConfigRequest,
+  GetTaskPushNotificationConfigRequest,
+  TaskState,
+  TaskArtifactUpdateEvent,
+} from "../../types/index.js";
+import {
+  AgentEngine,
+  ExecutionContext,
+  A2AExecutionContext,
+} from "../../types/services/context.js";
+import { Protocol } from "../../types/services/protocol.js";
+import { Response } from "express";
+import { loadState, processUpdate } from "../../server/lib/state.js";
+import {
+  FINAL_STATES,
+  getCurrentTimestamp,
+  INVALID_PARAMS,
+  INVALID_REQUEST,
+  METHOD_NOT_FOUND,
+  TASK_NOT_FOUND,
+  validateSendMessageParams,
+  WORKING_UPDATE,
+} from "../../utils/index.js";
+import { processTaskStream } from "../../transport/streaming/stream.js";
+import { sendSSEEvent, setupSseStream } from "../../index.js";
+import { A2ARepositoryParams } from "../../types/services/a2a/repository.js";
+import { A2AServiceInterface } from "../../types/services/a2a/service.js";
+import { A2ARepository } from "./repository.js";
+
+export class A2AService implements A2AServiceInterface {
+  readonly name: string = "a2a";
+  readonly protocol: Protocol = Protocol.A2A;
+  readonly engine: AgentEngine;
+  readonly state: A2ARepository;
+
+  constructor(params: A2ARepositoryParams & { engine: AgentEngine }) {
+    this.engine = params.engine;
+    this.state = new A2ARepository(params);
+  }
+
+  /**
+   * Handles the message/stream method.
+   * @param req The SendTaskRequest object
+   * @param res The Express Response object
+   */
+  public async handleTaskSendSubscribe(
+    req: SendStreamingMessageRequest,
+    res: Response
+  ): Promise<void> {
+    validateSendMessageParams(req.params);
+    const { message, metadata } = req.params;
+    if (!message.taskId) {
+      throw INVALID_PARAMS("Missing task ID");
+    }
+    const taskId = message.taskId;
+    let contextId = message.contextId ?? "unknown";
+
+    const executionContext: ExecutionContext<
+      A2AExecutionContext<SendStreamingMessageRequest>
+    > = {
+      id: taskId,
+      protocol: Protocol.A2A,
+      getRequestParams: () => req.params,
+      isCancelled: () => this.state.getActiveCancellations().has(taskId),
+    };
+
+    // Set up SSE stream with initial status
+    setupSseStream(
+      res,
+      taskId,
+      {
+        taskId: taskId,
+        contextId: contextId,
+        kind: "status-update",
+        status: {
+          state: TaskState.Submitted,
+          timestamp: getCurrentTimestamp(),
+        },
+        final: false,
+      },
+      this.state.addStreamForTask.bind(this)
+    );
+
+    // Load or create task
+    let currentData = await loadState(
+      this.state.getTaskStore(),
+      message,
+      metadata,
+      taskId,
+      contextId
+    );
+
+    // Create task context
+    const context = this.state.createTaskContext(
+      currentData.task,
+      message,
+      currentData.history
+    );
+
+    contextId = currentData.task.contextId || contextId;
+    const workingUpdate = WORKING_UPDATE(taskId, contextId);
+    currentData = await processUpdate(this.state.getTaskStore(), {
+      context: context,
+      current: currentData,
+      update: workingUpdate,
+    });
+
+    // Send the working status
+    sendSSEEvent(res, currentData.task.id, workingUpdate);
+
+    // Process the task using the shared method
+    await processTaskStream(
+      context,
+      this.state.getTaskStore(),
+      this.engine,
+      res,
+      taskId,
+      currentData,
+      this.state.onCancel.bind(this),
+      this.state.onEnd.bind(this),
+      executionContext
+    );
+  }
+
+  /**
+   * Handles the tasks/resubscribe method.
+   * @param req The TaskResubscriptionRequest object
+   * @param res The Express Response object
+   */
+  public async handleTaskResubscribe(
+    req: TaskResubscriptionRequest,
+    res: Response
+  ): Promise<void> {
+    const { id: taskId } = req.params;
+    if (!taskId) {
+      console.error("Task ID is required", req);
+      throw INVALID_PARAMS("Missing task ID");
+    }
+
+    const executionContext: ExecutionContext<
+      A2AExecutionContext<TaskResubscriptionRequest>
+    > = {
+      id: taskId,
+      protocol: Protocol.A2A,
+      getRequestParams: () => req.params,
+      isCancelled: () => this.state.getActiveCancellations().has(taskId),
+    };
+
+    // Try to load the task
+    const data = await this.state.getTaskStore().load(taskId);
+    if (!data) {
+      throw TASK_NOT_FOUND("Task Id: " + taskId);
+    }
+
+    // Set up SSE stream with current task status
+    setupSseStream(
+      res,
+      taskId,
+      {
+        taskId: taskId,
+        contextId: data.task.contextId || "unknown",
+        kind: "status-update",
+        status: data.task.status,
+        final: false,
+        metadata: data.task.metadata,
+      },
+      this.state.addStreamForTask.bind(this)
+    );
+
+    // Check if task is in final state
+    if (FINAL_STATES.includes(data.task.status.state)) {
+      // If the task is already complete, send all artifacts and close
+      if (data.task.artifacts && data.task.artifacts.length > 0) {
+        for (const artifact of data.task.artifacts) {
+          const response: TaskArtifactUpdateEvent = {
+            taskId: taskId,
+            contextId: data.task.contextId || "unknown",
+            kind: "artifact-update",
+            artifact,
+            lastChunk: true,
+            metadata: data.task.metadata,
+          };
+          sendSSEEvent(res, taskId, response);
+        }
+      }
+
+      // Remove from tracking and close
+      this.state.removeStreamForTask(taskId, res);
+      res.write("event: close\ndata: {}\n\n");
+      res.end();
+      return;
+    }
+
+    // For non-final states, create context and continue processing
+    // We need to use the last user message as the current message
+    const lastUserMessage = data.history
+      .filter((msg) => msg.role === "user")
+      .pop();
+    if (!lastUserMessage) {
+      throw INVALID_REQUEST("No user message found");
+    }
+
+    const context = this.state.createTaskContext(
+      data.task,
+      lastUserMessage,
+      data.history
+    );
+
+    // Continue processing the task using the shared method
+    await processTaskStream(
+      context,
+      this.state.getTaskStore(),
+      this.engine,
+      res,
+      taskId,
+      data,
+      this.state.onCancel.bind(this),
+      this.state.onEnd.bind(this),
+      executionContext
+    );
+  }
+
+  /**
+   * Executes a method on the A2A service.
+   * @param executionContext The execution context.
+   * @param engine The agent engine.
+   */
+  async execute({
+    executionContext,
+    engine,
+  }: {
+    executionContext: ExecutionContext<A2AExecutionContext>;
+    engine: AgentEngine;
+  }): Promise<void> {
+    if (!executionContext.requestContext) {
+      throw INVALID_REQUEST({
+        message: "Invalid request",
+        data: {
+          method: "unknown",
+          params: executionContext.getRequestParams(),
+        },
+      });
+    }
+    if (!executionContext.requestContext?.method) {
+      throw METHOD_NOT_FOUND({ method: "unknown" });
+    }
+    let closeConnection = false;
+    const callback = (error: any, result: any) => {
+      if (error) {
+        executionContext.requestContext?.response.status(500).send({
+          jsonrpc: "2.0",
+          id: executionContext.id,
+          error: error,
+        });
+        closeConnection = true;
+      } else {
+        executionContext.requestContext?.response.send({
+          jsonrpc: "2.0",
+          id: executionContext.id,
+          result,
+        });
+      }
+      if (closeConnection) {
+        executionContext.requestContext?.response.end();
+      }
+    };
+    switch (executionContext.requestContext?.method) {
+      case "message/send":
+      case "tasks/get":
+      case "tasks/cancel":
+      case "tasks/pushNotificationConfig/set":
+      case "tasks/pushNotificationConfig/get":
+        closeConnection = true;
+        return await A2AService.dispatchMethod(
+          executionContext.requestContext.method,
+          executionContext.requestContext.params,
+          callback,
+          {
+            taskStore: this.state.getTaskStore(),
+            card: this.state.getCard(),
+            taskHandler: engine,
+            activeCancellations: this.state.getActiveCancellations(),
+            createTaskContext: this.state.createTaskContext.bind(this),
+            closeStreamsForTask: this.state.closeStreamsForTask.bind(this),
+          }
+        );
+      case "message/stream": //todo make the following functions leverage callback
+        return await this.handleTaskSendSubscribe(
+          executionContext.requestContext.request,
+          executionContext.requestContext.response
+        ).catch((error) => {
+          closeConnection = true;
+          callback(error, null);
+        });
+      case "tasks/resubscribe":
+        return await this.handleTaskResubscribe(
+          executionContext.requestContext.request,
+          executionContext.requestContext.response
+        ).catch((error) => {
+          closeConnection = true;
+          callback(error, null);
+        });
+      default:
+        callback(
+          METHOD_NOT_FOUND({ method: executionContext.requestContext?.method }),
+          null
+        );
+        break;
+    }
+  }
+
+  /**
+   * Dispatches a method to the A2A service.
+   * @param method The method to dispatch.
+   * @param params The parameters to dispatch.
+   * @param callback The callback to dispatch.
+   * @param deps The dependencies to dispatch.
+   */
+  static async dispatchMethod<T extends A2ARequest>(
+    method: T["method"],
+    params: T["params"],
+    callback: JSONRPCCallback<A2AResponse | Task | Message | null>,
+    deps: CreateJSONRPCServerParams
+  ) {
+    switch (method) {
+      case "message/send":
+        return await createJSONRPCMethod<
+          SendMessageRequest["params"],
+          SendMessageResponse | Task | Message | null
+        >(
+          deps,
+          defaultSendTaskMethod,
+          method
+        )(params as SendMessageRequest["params"], callback);
+      case "tasks/get":
+        return await createJSONRPCMethod(
+          deps,
+          defaultGetTaskMethod,
+          method
+        )(params as GetTaskRequest["params"], callback);
+      case "tasks/cancel":
+        return await createJSONRPCMethod(
+          deps,
+          defaultCancelTaskMethod,
+          method
+        )(params as CancelTaskRequest["params"], callback);
+      case "tasks/pushNotificationConfig/set":
+        return await createJSONRPCMethod(
+          deps,
+          defaultSetTaskPushNotificationMethod,
+          method
+        )(params as SetTaskPushNotificationConfigRequest["params"], callback);
+      case "tasks/pushNotificationConfig/get":
+        return await createJSONRPCMethod(
+          deps,
+          defaultGetTaskPushNotificationMethod,
+          method
+        )(params as GetTaskPushNotificationConfigRequest["params"], callback);
+      default:
+        throw new Error(`Unknown method: ${method}`);
+    }
+  }
+}
diff --git a/src/services/index.ts b/src/services/index.ts
new file mode 100644
index 0000000..e69de29
diff --git a/src/services/manager.ts b/src/services/manager.ts
new file mode 100644
index 0000000..e386f08
--- /dev/null
+++ b/src/services/manager.ts
@@ -0,0 +1,54 @@
+import { BaseExecutionContext } from "../types/services/context.js";
+import { AgentCard } from "../types/index.js";
+import { ServiceDispatcher } from "../types/services/dispatcher.js";
+import { v4 as uuidv4 } from "uuid";
+import { ManagerInterface, ManagerOptions } from "../types/services/manager.js";
+
+/**
+ * @description The service manager class.
+ */
+export class ServiceManager
+  extends ServiceDispatcher
+  implements ManagerInterface
+{
+  /**
+   * @description The agent card.
+   * @type {AgentCard}
+   */
+  protected card: AgentCard;
+  /**
+   * @description The constructor.
+   * @param {ManagerOptions} params The service manager params.
+   */
+  constructor(params: ManagerOptions) {
+    super(params);
+    this.card = params.card;
+  }
+
+  /**
+   * @description Creates a request context.
+   * @param {T} req The request.
+   * @returns {T} The request context.
+   */
+  createRequestContext<T extends BaseExecutionContext>(req: T): T {
+    if (!req.protocol || !req.method || !req.params) {
+      throw new Error("Invalid request parameters");
+    }
+    const context: T = {
+      ...req,
+      id: req.id ?? uuidv4(),
+      protocol: req.protocol,
+      method: req.method,
+      params: req.params,
+    } as T;
+    return context;
+  }
+
+  /**
+   * @description Gets the agent card.
+   * @returns {AgentCard} The agent card.
+   */
+  getCard(): AgentCard {
+    return this.card;
+  }
+}
diff --git a/src/services/mcp/index.ts b/src/services/mcp/index.ts
new file mode 100644
index 0000000..2f69ec2
--- /dev/null
+++ b/src/services/mcp/index.ts
@@ -0,0 +1 @@
+export * from "./service.js";
diff --git a/src/services/mcp/service.ts b/src/services/mcp/service.ts
new file mode 100644
index 0000000..325abcf
--- /dev/null
+++ b/src/services/mcp/service.ts
@@ -0,0 +1,132 @@
+import {
+  McpServer,
+  ToolCallback,
+} from "@modelcontextprotocol/sdk/server/mcp.js";
+import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
+import { Protocol } from "../../types/services/protocol.js";
+import {
+  ExecutionContext,
+  MCPExecutionContext,
+} from "../../types/services/context.js";
+import { AgentSkill } from "../../types/index.js";
+import {
+  CallToolResult,
+  Implementation,
+} from "@modelcontextprotocol/sdk/types.js";
+import { ServerOptions } from "@modelcontextprotocol/sdk/server/index.js";
+import { AgentEngine } from "../../types/services/context.js";
+import { ZodRawShape } from "zod";
+import {
+  MCPTool,
+  MCPRequestParamsSchema,
+  MCPServiceInterface,
+} from "../../types/services/mcp/service.js";
+
+export class MCPService<
+    T extends StreamableHTTPServerTransport = StreamableHTTPServerTransport,
+  >
+  extends McpServer
+  implements MCPServiceInterface
+{
+  readonly name: string;
+  readonly protocol: Protocol.MCP;
+  readonly engine: AgentEngine;
+  constructor({
+    serverInfo,
+    engine,
+    options,
+    skills,
+  }: {
+    serverInfo: Implementation;
+    engine: AgentEngine;
+    skills?: AgentSkill[];
+    options?: ServerOptions;
+  }) {
+    super(serverInfo, options);
+    this.name = "mcp";
+    this.protocol = Protocol.MCP;
+    this.engine = engine;
+    if (skills) {
+      this.initialize(skills);
+    }
+  }
+
+  initialize(skills: AgentSkill[]) {
+    for (const skill of skills) {
+      const tool = MCPService.skillToTool(
+        skill,
+        MCPRequestParamsSchema.shape,
+        MCPService.mcpFactory(this.engine)
+      );
+
+      super.tool(
+        skill.name,
+        skill.description ?? "",
+        tool.paramsSchemaOrAnnotations,
+        tool.cb
+      );
+    }
+  }
+
+  async execute({
+    executionContext,
+  }: {
+    executionContext: ExecutionContext<MCPExecutionContext>;
+    engine: AgentEngine;
+  }): Promise<void> {
+    if (!executionContext.requestContext) {
+      throw new Error("No request context");
+    }
+    const { request, transport, response } = executionContext.requestContext;
+    const validTransport = transport as T;
+    if (!validTransport) {
+      throw new Error("Invalid transport");
+    }
+    await super.connect(validTransport);
+    await validTransport.handleRequest(request, response, request.body);
+  }
+
+  static mcpFactory<Args extends MCPExecutionContext = MCPExecutionContext>(
+    engine: AgentEngine
+  ): (args: Args["params"]) => Promise<string> {
+    return async (args: Args["params"]) => {
+      const context: ExecutionContext<Args> = {
+        id: "",
+        protocol: Protocol.MCP,
+        getRequestParams: () => args,
+        isCancelled: () => false,
+      };
+      const generator = await engine(context);
+      let finalResult: any;
+      for await (const event of generator) {
+        finalResult = event;
+      }
+      await Promise.resolve();
+      return JSON.stringify(finalResult);
+    };
+  }
+
+  static skillToTool<Args extends ZodRawShape = ZodRawShape>(
+    skill: AgentSkill,
+    argShape: Args,
+    agentHandler: (...args: Parameters<ToolCallback<Args>>) => Promise<string>
+  ): MCPTool<Args> {
+    const skillTool: MCPTool<Args> = {
+      name: skill.name,
+      description: skill.description,
+      paramsSchemaOrAnnotations: argShape,
+      cb: async (...args) => {
+        const toolResult: CallToolResult = {
+          content: [
+            {
+              type: "text",
+              text: await agentHandler(...args),
+            },
+          ],
+        };
+        return toolResult;
+      },
+    };
+    return skillTool;
+  }
+}
diff --git a/src/transport/rpc/parser.ts b/src/transport/rpc/parser.ts
index 6b7f305..a9d6387 100644
--- a/src/transport/rpc/parser.ts
+++ b/src/transport/rpc/parser.ts
@@ -1,6 +1,7 @@
-import { JSONRPCResponse } from "../../types/extended-schema.js";
+import { JSONRPCError, JSONRPCResponse } from "../../types/extended-schema.js";
 import { SystemError, PARSE_ERROR } from "../../utils/common/errors.js";
 import { logError } from "../../utils/logging/log.js";
+
 /**
  * Parses a JSON-RPC response string and validates its structure.
  * If the response contains an error, it is thrown as an A2AError.
@@ -18,10 +19,11 @@ export function parseResponse<Res extends JSONRPCResponse>(data: string): Res {
   try {
     const parsed = JSON.parse(data) as Res;
     if (parsed.error) {
-      throw new SystemError(
-        parsed.error.message,
-        parsed.error.code,
-        parsed.error.data
+      const parsedError = parsed.error as JSONRPCError<number, unknown>;
+      throw new SystemError<JSONRPCError<number, unknown>>(
+        parsedError.message,
+        parsedError.code,
+        parsedError.data
       );
     }
 
@@ -30,7 +32,7 @@ export function parseResponse<Res extends JSONRPCResponse>(data: string): Res {
       parsed === null ||
       parsed.jsonrpc !== "2.0"
     ) {
-      throw PARSE_ERROR<string>("invalid jsonrpc");
+      throw PARSE_ERROR("invalid jsonrpc");
     }
 
     if (parsed.result === undefined) {
diff --git a/src/transport/streaming/stream.ts b/src/transport/streaming/stream.ts
index c8337fa..561993c 100644
--- a/src/transport/streaming/stream.ts
+++ b/src/transport/streaming/stream.ts
@@ -1,16 +1,20 @@
 import { Response } from "express";
-import { Artifact, JSONRPCError, JSONRPCResponse } from "../../types/schema.js";
-import { TaskEvent } from "../../types/extended-schema.js";
-import { updateState } from "../../server/lib/state.js";
+import { JSONRPCError, JSONRPCResponse } from "../../types/index.js";
+import { TaskEvent, UpdateEvent } from "../../types/extended-schema.js";
+import { processUpdate } from "../../server/lib/state.js";
 import { TaskStore, TaskAndHistory } from "../../server/interfaces/store.js";
-import { TaskContext, TaskHandler } from "../../types/context.js";
-import { FAILED_UPDATE, INTERNAL_ERROR } from "../../utils/common/errors.js";
 import {
-  isArtifactUpdate,
-  isTaskStatusUpdate,
-} from "../../utils/common/utils.js";
+  AgentEngine,
+  ExecutionContext,
+  TaskContext,
+  A2AExecutionContext,
+} from "../../types/index.js";
+import { FAILED_UPDATE, INTERNAL_ERROR } from "../../utils/common/errors.js";
 import { logError } from "../../utils/logging/log.js";
-import { FINAL_STATES } from "../../utils/common/constants.js";
+import {
+  SendStreamingMessageRequest,
+  TaskResubscriptionRequest,
+} from "../../types/index.js";
 
 /**
  * Sets up a Server-Sent Events stream with appropriate headers
@@ -41,7 +45,7 @@ export function setupSseStream(
 
   // Send initial status if provided
   if (initialStatus) {
-    sendSSEEvent(res, initialStatus);
+    sendSSEEvent(res, taskId, initialStatus);
   }
 }
 
@@ -51,14 +55,18 @@ export function setupSseStream(
  * @param reqId The request ID
  * @param eventData The event data to send
  */
-export function sendSSEEvent(res: Response, update: TaskEvent): void {
+export function sendSSEEvent(
+  res: Response,
+  id: string,
+  update: UpdateEvent
+): void {
   if (!res.writable) {
     return;
   }
 
-  const response: JSONRPCResponse<TaskEvent> = {
+  const response: JSONRPCResponse<UpdateEvent> = {
     jsonrpc: "2.0",
-    id: update.id,
+    id: id,
     result: update,
   };
 
@@ -95,70 +103,61 @@ export function sendSSEError(
  * @param context The task context
  * @param initialData The initial task data
  */
-export async function processTaskStream(
+export async function processTaskStream<
+  T extends A2AExecutionContext<
+    SendStreamingMessageRequest | TaskResubscriptionRequest
+  >,
+>(
+  context: TaskContext,
   taskStore: TaskStore,
-  taskHandler: TaskHandler,
+  engine: AgentEngine,
   res: Response,
   taskId: string,
-  context: TaskContext,
   initialData: TaskAndHistory,
-  onCancel: (data: TaskAndHistory, res: Response) => Promise<void>,
-  onEnd: (taskId: string, res: Response) => Promise<void>
+  onCancel: (
+    context: TaskContext,
+    data: TaskAndHistory,
+    res: Response
+  ) => Promise<void>,
+  onEnd: (taskId: string, res: Response) => Promise<void>,
+  executionContext: ExecutionContext<T>
 ): Promise<void> {
   let currentData = initialData;
 
-  const generator = taskHandler(context);
+  const generator = engine(executionContext);
 
   try {
     for await (const yieldValue of generator) {
       if (context.isCancelled()) {
-        await onCancel(currentData, res);
+        await onCancel(context, currentData, res);
         return;
       }
 
-      currentData = await updateState(taskStore, currentData, yieldValue);
+      currentData = await processUpdate(taskStore, {
+        context: context,
+        current: currentData,
+        update: yieldValue,
+      });
 
       context.task = currentData.task;
-
-      if (isTaskStatusUpdate(yieldValue)) {
-        sendSSEEvent(res, {
-          id: taskId,
-          status: currentData.task.status,
-          final: FINAL_STATES.includes(currentData.task.status.state),
-        });
-      } else if (isArtifactUpdate(yieldValue)) {
-        const artifactIndex =
-          currentData.task.artifacts?.findIndex(
-            (a: Artifact) => a.name && a.name === yieldValue.name
-          ) ??
-          yieldValue.index ??
-          -1;
-
-        if (
-          artifactIndex >= 0 &&
-          currentData.task.artifacts &&
-          artifactIndex < currentData.task.artifacts.length
-        ) {
-          sendSSEEvent(res, {
-            id: taskId,
-            artifact: currentData.task.artifacts[artifactIndex],
-            final: FINAL_STATES.includes(currentData.task.status.state),
-          });
-        }
-      }
+      sendSSEEvent(res, taskId, yieldValue);
     }
   } catch (error) {
     try {
       const failedUpdate = FAILED_UPDATE(
+        taskId,
+        context.contextId,
+        "failed-update",
         error instanceof Error ? error.message : String(error)
       );
 
-      currentData = await updateState(taskStore, currentData, failedUpdate);
-
-      sendSSEEvent(res, {
-        id: taskId,
-        status: currentData.task.status,
+      currentData = await processUpdate(taskStore, {
+        context: context,
+        current: currentData,
+        update: failedUpdate,
       });
+
+      sendSSEEvent(res, taskId, failedUpdate);
     } catch (saveError) {
       logError(
         "A2AServer",
diff --git a/src/types/client.ts b/src/types/client.ts
index 0980efb..2a4af0f 100644
--- a/src/types/client.ts
+++ b/src/types/client.ts
@@ -1,14 +1,14 @@
 import {
   TaskPushNotificationConfig,
-  TaskArtifactUpdateEvent,
   TaskIdParams,
   Task,
 } from "./extended-schema.js";
 import type {
   AgentCard,
   TaskQueryParams,
-  TaskSendParams,
-  TaskStatusUpdateEvent,
+  MessageSendParams,
+  Message,
+  UpdateEvent,
 } from "./extended-schema.js";
 
 /**
@@ -40,22 +40,39 @@ export interface Client {
 
   /**
    * @description Sends a task request to the agent server.
-   * @param {TaskSendParams} params Parameters required to send the task, including the task definition and metadata.
+   * @param {MessageSendParams} params Parameters required to send the task, including the task definition and metadata.
    * @returns {Promise<Task | null>} A promise that resolves with the initial Task object representing the submitted task, or null if the submission failed.
    * @async
    */
-  sendTask(params: TaskSendParams): Promise<Task | null>;
+  sendMessage(params: MessageSendParams): Promise<Message | Task | null>;
 
   /**
+   * @deprecated Use sendMessage instead.
+   * @description Sends a task request to the agent server.
+   * @param {MessageSendParams} params Parameters required to send the task, including the task definition and metadata.
+   * @returns {Promise<Task | null>} A promise that resolves with the initial Task object representing the submitted task, or null if the submission failed.
+   * @async
+   */
+  sendTask(params: MessageSendParams): Promise<Message | Task | null>;
+
+  /**
+   * @description Sends a task request and subscribes to real-time updates (status changes, artifact updates) for that task.
+   * This uses a streaming connection if available.
+   * @param {MessageSendParams} params Parameters required to send the task.
+   * @returns {AsyncIterable<UpdateEvent>} An async iterable that yields task status and artifact updates.
+   * @async
+   */
+  sendStreamingMessage(params: MessageSendParams): AsyncIterable<UpdateEvent>;
+
+  /**
+   * @deprecated Use sendStreamingMessage instead.
    * @description Sends a task request and subscribes to real-time updates (status changes, artifact updates) for that task.
    * This uses a streaming connection if available.
-   * @param {TaskSendParams} params Parameters required to send the task.
-   * @returns {AsyncIterable<TaskStatusUpdateEvent | TaskArtifactUpdateEvent>} An async iterable that yields task status and artifact updates.
+   * @param {MessageSendParams} params Parameters required to send the task.
+   * @returns {AsyncIterable<UpdateEvent>} An async iterable that yields task status and artifact updates.
    * @async
    */
-  sendTaskSubscribe(
-    params: TaskSendParams
-  ): AsyncIterable<TaskStatusUpdateEvent | TaskArtifactUpdateEvent>;
+  sendTaskSubscribe(params: MessageSendParams): AsyncIterable<UpdateEvent>;
 
   /**
    * @description Retrieves the current state of a specific task by its ID.
@@ -99,12 +116,10 @@ export interface Client {
    * @description Resubscribes to updates for an existing task, potentially after a connection drop or client restart.
    * This allows resuming the stream of status and artifact updates.
    * @param {TaskQueryParams} params Parameters containing the task ID to resubscribe to.
-   * @returns {AsyncIterable<TaskStatusUpdateEvent | TaskArtifactUpdateEvent>} An async iterable that yields task status and artifact updates.
+   * @returns {AsyncIterable<UpdateEvent>} An async iterable that yields task status and artifact updates.
    * @async
    */
-  resubscribeTask(
-    params: TaskQueryParams
-  ): AsyncIterable<TaskStatusUpdateEvent | TaskArtifactUpdateEvent>;
+  resubscribeTask(params: TaskQueryParams): AsyncIterable<UpdateEvent>;
 
   /**
    * @description Checks if the agent server supports a specific capability.
diff --git a/src/types/context.ts b/src/types/context.ts
deleted file mode 100644
index 6759a52..0000000
--- a/src/types/context.ts
+++ /dev/null
@@ -1,47 +0,0 @@
-import type { Task, Message, TaskYieldUpdate } from "./extended-schema.js";
-
-/**
- * Context object provided to the TaskHandler.
- * Contains the information needed for the handler to process the task.
- */
-export interface TaskContext {
-  /**
-   * The current state of the task when the handler is invoked or resumed.
-   * This is a snapshot - the latest state may need to be reloaded during async operations.
-   */
-  task: Task;
-
-  /**
-   * The specific user message that triggered this handler invocation or resumption.
-   */
-  userMessage: Message;
-
-  /**
-   * Function to check if cancellation has been requested for this task.
-   * Handlers should check this periodically during long-running operations.
-   * @returns True if cancellation has been requested, false otherwise.
-   */
-  isCancelled(): boolean;
-
-  /**
-   * The message history associated with the task up to the point the handler is invoked.
-   */
-  history: Message[];
-}
-
-/**
- * Defines the signature for a task handler function.
- *
- * Handlers are implemented as async generators. They receive context about the
- * task and the triggering message. They perform work and yield status
- * or artifact updates (TaskYieldUpdate). The server consumes these yields,
- * updates the task state in the store, and streams events if applicable.
- *
- * @param context The TaskContext object containing task details and state.
- * @yields Updates to the task's status or artifacts.
- * @returns Optionally returns the final complete Task object (needed for non-streaming 'tasks/send').
- *   If void is returned, the server uses the last known state after processing all yields.
- */
-export type TaskHandler = (
-  context: TaskContext
-) => AsyncGenerator<TaskYieldUpdate, Task | void, unknown>;
diff --git a/src/types/express.ts b/src/types/express.ts
new file mode 100644
index 0000000..183e53a
--- /dev/null
+++ b/src/types/express.ts
@@ -0,0 +1,60 @@
+import express from "express";
+import http from "http";
+import { CorsOptions } from "cors";
+import { ManagerOptions } from "./services/manager.js";
+
+/**
+ * @description The express server options.
+ */
+export interface ExpressServerOptions extends ManagerOptions {
+  /**
+   * @description The app.
+   * @type {express.Express}
+   */
+  app?: express.Express;
+  /**
+   * @description The cors options.
+   * @type {CorsOptions}
+   */
+  corsOptions?: CorsOptions;
+  /**
+   * @description The base path.
+   * @type {string}
+   */
+  basePath?: string;
+  /**
+   * @description The fallback path.
+   * @type {string}
+   */
+  fallbackPath?: string;
+  /**
+   * @description The register.
+   * @type {boolean}
+   */
+  register?: boolean;
+  /**
+   * @description The port.
+   * @type {number}
+   */
+  port?: number;
+}
+
+/**
+ * @description The express server interface.
+ */
+export interface ExpressServerInterface {
+  /**
+   * @description Gets the app.
+   * @returns {express.Express} The app.
+   */
+  getApp(): express.Express;
+  /**
+   * @description Starts the server.
+   * @returns {Promise<http.Server>} The server.
+   */
+  start(): Promise<http.Server>;
+  /**
+   * @description Stops the server.
+   */
+  stop(): Promise<void>;
+}
diff --git a/src/types/extended-schema.ts b/src/types/extended-schema.ts
index dddaf9c..0177b44 100644
--- a/src/types/extended-schema.ts
+++ b/src/types/extended-schema.ts
@@ -8,72 +8,142 @@ import type {
   TaskStatusUpdateEvent,
   TaskArtifactUpdateEvent,
   TaskStatus,
-  Artifact,
   A2ARequest,
   JSONRPCRequest,
   JSONRPCResponse,
   AgentCard,
-  JSONRPCMessage,
-  JSONRPCError,
-} from "./schema.js";
+  FileWithBytes,
+  FileWithUri,
+  Task,
+  Message,
+  MessageSendConfiguration,
+} from "./schemas/a2a/index.js";
+import {
+  ExecutionContext,
+  executionContextConfig,
+} from "./services/context.js";
+import { Transformed } from "./transform.js";
+import { AgentEngine } from "./services/index.js";
 
 /**
- * Improved JSON-RPC Response types using discriminated unions
- * These provide better type safety than the standard optional field approach
+ * Represents the content of a file, either as base64 encoded bytes or a URI.
+ * @description Ensures that either 'bytes' or 'uri' is provided, but not both. (Note: This constraint is informational in TypeScript types).
  */
+export type FileContent = FileWithBytes | FileWithUri;
 
 /**
- * @deprecated Use JSONRPCResponse instead
- * Represents a successful JSON-RPC response with a result.
+ * Represents the possible types of events that can be yielded by a TaskHandler.
+ * @description Either a partial TaskStatus (without the server-managed timestamp)
+ * or a complete Artifact object.
+ */
+export type TaskEvent = TaskStatusUpdateEvent | TaskArtifactUpdateEvent;
+
+/**
+ * Represents the possible types of updates that can be yielded by a TaskHandler.
+ * @description Either a Message, Task, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent.
+ */
+export type UpdateEvent =
+  | Message
+  | Task
+  | TaskStatusUpdateEvent
+  | TaskArtifactUpdateEvent;
+
+/**
+ * @deprecated use UpdateEvent instead
+ * Represents the possible types of updates a TaskHandler can yield.
+ * Either a partial TaskStatus (without the server-managed timestamp)
+ * or a complete Artifact object.
  */
-export interface JSONRPCSuccessResponse<R = any> extends JSONRPCMessage {
+export type TaskYieldUpdate = UpdateEvent;
+
+/**
+ * @deprecated This interface will be removed in the future. Use TaskStatus instead.
+ * Represents the possible types of updates that can be yielded by a TaskHandler.
+ * Either a partial TaskStatus (without the server-managed timestamp)
+ * or a complete Artifact object.
+ */
+export type ExtendedTaskStatusUpdate = Omit<TaskStatus, "timestamp">;
+
+/**
+ * @deprecated This interface will be removed in the future. Use ExecutionContext instead.
+ * Context object provided to the TaskHandler.
+ * Contains the information needed for the handler to process the task.
+ */
+export interface TaskContext
+  extends Transformed<
+    Omit<ExecutionContext, "getRequestParams" | "protocol">,
+    typeof executionContextConfig
+  > {
   /**
-   * The result of the method invocation.
+   * The context ID of the task.
    */
-  result: R;
+  contextId: string;
 
   /**
-   * In a success response, error must never be present.
+   * The current state of the task when the handler is invoked or resumed.
+   * This is a snapshot - the latest state may need to be reloaded during async operations.
    */
-  error?: never;
-}
+  task: Task;
+
+  /**
+   * The specific user message that triggered this handler invocation or resumption.
+   */
+  userMessage: Message;
 
-/**
- * @deprecated Use JSONRPCResponse instead
- * Represents an error JSON-RPC response.
- */
-export interface JSONRPCErrorResponse<E = any> extends JSONRPCMessage {
   /**
-   * The error object.
+   * Function to check if cancellation has been requested for this task.
+   * Handlers should check this periodically during long-running operations.
+   * @returns True if cancellation has been requested, false otherwise.
    */
-  error: JSONRPCError<E>;
+  isCancelled(): boolean;
 
   /**
-   * In an error response, result must never be present.
+   * The message history associated with the task up to the point the handler is invoked.
    */
-  result?: never;
+  history: Message[];
+
+  /**
+   * @description The latest user message that triggered this handler invocation or resumption.
+   * @note It's unclear whether this is necessary as userMessage already exists
+   */
+  latestUserMessage?: Message;
+
+  /**
+   * The configuration for the task.
+   */
+  configuration?: MessageSendConfiguration;
 }
 
 /**
- * @deprecated Use JSONRPCResponse instead
- * Combined JSON-RPC response type as a discriminated union.
- * This ensures a response is either a success with a result, or an error.
+ * Defines the signature for a task handler function.
+ *
+ * Handlers are implemented as async generators. They receive context about the
+ * task and the triggering message. They perform work and yield status
+ * or artifact updates (TaskYieldUpdate). The server consumes these yields,
+ * updates the task state in the store, and streams events if applicable.
+ *
+ * @param context The TaskContext object containing task details and state.
+ * @yields Updates to the task's status or artifacts.
+ * @returns Optionally returns the final complete Task object (needed for non-streaming 'message/send').
+ *   If void is returned, the server uses the last known state after processing all yields.
  */
-export type ExtendedJSONRPCResponse<R = any, E = any> =
-  | JSONRPCSuccessResponse<R>
-  | JSONRPCErrorResponse<E>;
+export type TaskHandler = AgentEngine;
 
-export type TaskEvent = TaskStatusUpdateEvent | TaskArtifactUpdateEvent;
 /**
- * Represents the possible types of updates a TaskHandler can yield.
- * Either a partial TaskStatus (without the server-managed timestamp)
- * or a complete Artifact object.
+ * @description This interface will be removed in the future. Use A2AContext instead.
+ * Represents the parameters for an A2A request.
  */
-export type TaskYieldUpdate = Omit<TaskStatus, "timestamp"> | Artifact;
+export type A2AContext = Pick<A2ARequest, "params">;
 
-export type ExtendedTaskStatusUpdate = Omit<TaskStatus, "timestamp">;
-export type RequestParams = Required<Pick<A2ARequest, "params">>["params"];
+/**
+ * @description This interface will be removed in the future. Use A2AContext instead.
+ * Represents the parameters for an A2A request.
+ */
+export type RequestParams = Required<A2AContext>;
 
+/**
+ * @description Represents the parameters for an A2A request.
+ */
 export interface ServerDeploymentRequestParams {
   /**
    * The name of the server
@@ -143,8 +213,11 @@ export interface TestServerDeploymentRequest extends JSONRPCRequest {
   params: ServerDeploymentRequestParams;
 }
 
+/**
+ * @description Represents the response for a server deployment request.
+ */
 export type ServerDeploymentResponse =
   JSONRPCResponse<ServerDeploymentSuccessResponseParams>;
 
-export * from "./schema.js";
-export type { A2AError as A2AErrorType } from "./schema.js";
+export * from "./schemas/a2a/index.js";
+export type { A2AError as A2AErrorType } from "./schemas/a2a/index.js";
diff --git a/src/types/index.ts b/src/types/index.ts
index 585c5ac..73ce7fd 100644
--- a/src/types/index.ts
+++ b/src/types/index.ts
@@ -1,4 +1,5 @@
+export * from "./schemas/index.js";
 export * from "./extended-schema.js";
 export * from "./proxy.js";
-export * from "./context.js";
+export * from "./services/context.js";
 export * from "./client.js";
diff --git a/src/types/proxy.ts b/src/types/proxy.ts
index c4a8a6d..7225906 100644
--- a/src/types/proxy.ts
+++ b/src/types/proxy.ts
@@ -1,15 +1,14 @@
-import { TaskYieldUpdate } from "./extended-schema.js";
-import { TaskHandler } from "./context.js";
+import { UpdateEvent, TaskHandler } from "./extended-schema.js";
 import { Client } from "./client.js";
 
 /**
  * Represents a proxy function for sending task yield updates.
  * This function is typically provided by the host environment to allow
  * an agent to communicate updates about its task execution.
- * @param taskYieldUpdate - The update object yielded by the task.
+ * @param updateEvent - The update object yielded by the task.
  * @returns A promise that resolves when the update has been processed.
  */
-export type TaskProxy = (taskYieldUpdate: TaskYieldUpdate) => Promise<void>;
+export type TaskProxy = (updateEvent: UpdateEvent) => Promise<void>;
 
 /**
  * Properties for the TaskManager function.
@@ -17,7 +16,7 @@ export type TaskProxy = (taskYieldUpdate: TaskYieldUpdate) => Promise<void>;
 export interface TaskManagerProps {
   /**
    * The core task-handling generator function of an agent.
-   * This function takes a `TaskContext` and yields `TaskYieldUpdate` objects,
+   * This function takes a `TaskContext` and yields `UpdateEvent` objects,
    * eventually returning a `Task` or void.
    */
   taskHandler: TaskHandler;
diff --git a/src/types/schema.ts b/src/types/schema.ts
deleted file mode 100644
index 7340016..0000000
--- a/src/types/schema.ts
+++ /dev/null
@@ -1,874 +0,0 @@
-// === JSON-RPC Base Structures
-
-/**
- * Base interface for identifying JSON-RPC messages.
- */
-export interface JSONRPCMessageIdentifier {
-  /**
-   * Request identifier. Can be a string, number.
-   * Responses must have the same ID as the request they relate to.
-   * Notifications (requests without an expected response) should omit the ID.
-   */
-  id?: number | string;
-}
-
-/**
- * Base interface for all JSON-RPC messages (Requests and Responses).
- */
-export interface JSONRPCMessage extends JSONRPCMessageIdentifier {
-  /**
-   * Specifies the JSON-RPC version. Must be "2.0".
-   * @default "2.0"
-   * @const "2.0"
-   */
-  jsonrpc?: "2.0";
-}
-
-/**
- * Represents a JSON-RPC request object base structure.
- * Specific request types should extend this.
- */
-export interface JSONRPCRequest extends JSONRPCMessage {
-  /**
-   * The name of the method to be invoked.
-   */
-  method: string;
-
-  /**
-   * Parameters for the method. Can be a structured object, an array, or omitted.
-   * Specific request interfaces will define the exact type.
-   */
-  params?: unknown; // Base type; specific requests will override
-}
-
-/**
- * Represents a JSON-RPC error object.
- */
-export interface JSONRPCError<Data = unknown, Code = number> {
-  /**
-   * A number indicating the error type that occurred.
-   */
-  code: Code;
-
-  /**
-   * A string providing a short description of the error.
-   */
-  message: string;
-
-  /**
-   * Additional data about the error.
-   */
-  data: Data;
-}
-
-/**
- * Represents a JSON-RPC response object.
- */
-export interface JSONRPCResponse<R = unknown, E = unknown>
-  extends JSONRPCMessage {
-  /**
-   * The result of the method invocation. Required on success.
-   * Should be omitted if an error occurred.
-   */
-  result?: R;
-
-  /**
-   * An error object if an error occurred during the request. Required on failure.
-   * Should be omitted if the request was successful.
-   */
-  error?: JSONRPCError<E>;
-}
-
-// === Core A2A Data Structures
-
-/**
- * Represents the state of a task within the A2A protocol.
- * @description An enumeration.
- */
-export type TaskState =
-  | "submitted"
-  | "working"
-  | "input-required"
-  | "completed"
-  | "canceled"
-  | "failed"
-  | "unknown";
-
-/**
- * Defines the authentication schemes and credentials for an agent.
- */
-export interface AgentAuthentication {
-  /**
-   * List of supported authentication schemes.
-   */
-  schemes: string[];
-
-  /**
-   * Credentials for authentication. Can be a string (e.g., token) or omitted if not required initially.
-   */
-  credentials?: string;
-}
-
-/**
- * Describes the capabilities of an agent.
- */
-export interface AgentCapabilities {
-  /**
-   * Indicates if the agent supports streaming responses.
-   * @default false
-   */
-  streaming?: boolean;
-
-  /**
-   * Indicates if the agent supports push notification mechanisms.
-   * @default false
-   */
-  pushNotifications?: boolean;
-
-  /**
-   * Indicates if the agent supports providing state transition history.
-   * @default false
-   */
-  stateTransitionHistory?: boolean;
-}
-
-/**
- * Represents the provider or organization behind an agent.
- */
-export interface AgentProvider {
-  /**
-   * The name of the organization providing the agent.
-   */
-  organization: string;
-
-  /**
-   * URL associated with the agent provider.
-   */
-  url?: string;
-}
-
-/**
- * Defines a specific skill or capability offered by an agent.
- */
-export interface AgentSkill {
-  /**
-   * Unique identifier for the skill.
-   */
-  id: string;
-
-  /**
-   * Human-readable name of the skill.
-   */
-  name: string;
-
-  /**
-   * Optional description of the skill.
-   */
-  description?: string;
-
-  /**
-   * Optional list of tags associated with the skill for categorization.
-   */
-  tags?: string[];
-
-  /**
-   * Optional list of example inputs or use cases for the skill.
-   */
-  examples?: string[];
-
-  /**
-   * Optional list of input modes supported by this skill, overriding agent defaults.
-   */
-  inputModes?: string[];
-
-  /**
-   * Optional list of output modes supported by this skill, overriding agent defaults.
-   */
-  outputModes?: string[];
-}
-
-/**
- * Represents the metadata card for an agent, describing its properties and capabilities.
- */
-export interface AgentCard {
-  /**
-   * The name of the agent.
-   */
-  name: string;
-
-  /**
-   * An optional description of the agent.
-   */
-  description?: string;
-
-  /**
-   * The base URL endpoint for interacting with the agent.
-   */
-  url: string;
-
-  /**
-   * Information about the provider of the agent.
-   */
-  provider?: AgentProvider;
-
-  /**
-   * The version identifier for the agent or its API.
-   */
-  version: string;
-
-  /**
-   * An optional URL pointing to the agent's documentation.
-   */
-  documentationUrl?: string;
-
-  /**
-   * The capabilities supported by the agent.
-   */
-  capabilities: AgentCapabilities;
-
-  /**
-   * Authentication details required to interact with the agent.
-   */
-  authentication?: AgentAuthentication;
-
-  /**
-   * Default input modes supported by the agent (e.g., 'text', 'file', 'json').
-   * @default ["text"]
-   */
-  defaultInputModes?: string[];
-
-  /**
-   * Default output modes supported by the agent (e.g., 'text', 'file', 'json').
-   * @default ["text"]
-   */
-  defaultOutputModes?: string[];
-
-  /**
-   * List of specific skills offered by the agent.
-   */
-  skills: AgentSkill[];
-}
-
-export interface FileContentBase {
-  /**
-   * Optional name of the file.
-   */
-  name?: string;
-
-  /**
-   * Optional MIME type of the file content.
-   */
-  mimeType?: string;
-
-  /**
-   * File content encoded as a Base64 string. Use this OR `uri`.
-   */
-  bytes?: string;
-
-  /**
-   * URI pointing to the file content. Use this OR `bytes`.
-   */
-  uri?: string;
-}
-
-export type FileContentBytes = FileContentBase & {
-  /* File content encoded as a Base64 string. Use this OR `uri`. */
-  bytes: string;
-  uri?: never;
-};
-
-export type FileContentUri = FileContentBase & {
-  /** URI pointing to the file content. */
-  uri: string;
-  bytes?: never;
-};
-
-/**
- * Represents the content of a file, either as base64 encoded bytes or a URI.
- * @description Ensures that either 'bytes' or 'uri' is provided, but not both. (Note: This constraint is informational in TypeScript types).
- */
-export type FileContent = FileContentBytes | FileContentUri;
-
-/**
- * Represents a part of a message containing text content.
- */
-export interface TextPart {
-  type: "text";
-
-  /**
-   * The text content.
-   */
-  text: string;
-
-  /**
-   * Optional metadata associated with this text part.
-   */
-  metadata?: Record<string, unknown>;
-}
-
-/**
- * Represents a part of a message containing file content.
- */
-export interface FilePart {
-  /**
-   * Type identifier for this part.
-   */
-  type: "file";
-
-  /**
-   * The file content, provided either inline or via URI.
-   */
-  file: FileContent;
-
-  /**
-   * Optional metadata associated with this file part.
-   */
-  metadata?: Record<string, unknown>;
-}
-
-/**
- * Represents a part of a message containing structured data (JSON).
- */
-export interface DataPart {
-  /**
-   * Type identifier for this part.
-   */
-  type: "data";
-
-  /**
-   * The structured data content as a JSON object.
-   */
-  data: Record<string, unknown>;
-
-  /**
-   * Optional metadata associated with this data part.
-   */
-  metadata?: Record<string, unknown>;
-}
-
-/**
- * Represents a single part of a multi-part message. Can be text, file, or data.
- */
-export type Part = TextPart | FilePart | DataPart;
-
-/**
- * Represents an artifact generated or used by a task, potentially composed of multiple parts.
- */
-export interface Artifact {
-  /**
-   * Optional name for the artifact.
-   */
-  name?: string;
-
-  /**
-   * Optional description of the artifact.
-   */
-  description?: string;
-
-  /**
-   * The constituent parts of the artifact.
-   */
-  parts: Part[];
-
-  /**
-   * Optional index for ordering artifacts, especially relevant in streaming or updates.
-   * @default 0
-   */
-  index?: number;
-
-  /**
-   * Optional flag indicating if this artifact content should append to previous content (for streaming).
-   */
-  append?: boolean;
-
-  /**
-   * Optional metadata associated with the artifact.
-   */
-  metadata?: Record<string, unknown>;
-
-  /**
-   * Optional flag indicating if this is the last chunk of data for this artifact (for streaming).
-   */
-  lastChunk?: boolean;
-}
-
-/**
- * Represents a message exchanged between a user and an agent.
- */
-export interface Message {
-  /**
-   * The role of the sender (user or agent).
-   */
-  role: "user" | "agent";
-
-  /**
-   * The content of the message, composed of one or more parts.
-   */
-  parts: Part[];
-
-  /**
-   * Optional metadata associated with the message.
-   */
-  metadata?: Record<string, unknown>;
-}
-
-/**
- * Represents the status of a task at a specific point in time.
- */
-export interface TaskStatus {
-  /**
-   * The current state of the task.
-   */
-  state: TaskState;
-
-  /**
-   * An optional message associated with the current status (e.g., progress update, final response).
-   */
-  message?: Message;
-
-  /**
-   * The timestamp when this status was recorded (ISO 8601 format).
-   * @format date-time
-   */
-  timestamp?: string;
-}
-
-/**
- * Represents a task being processed by an agent.
- */
-export interface Task {
-  /**
-   * Unique identifier for the task.
-   */
-  id: string;
-
-  /**
-   * Optional identifier for the session this task belongs to.
-   */
-  sessionId?: string;
-
-  /**
-   * The current status of the task.
-   */
-  status: TaskStatus;
-
-  /**
-   * Optional list of artifacts associated with the task (e.g., outputs, intermediate files).
-   */
-  artifacts?: Artifact[];
-
-  /**
-   * Optional metadata associated with the task.
-   */
-  metadata?: Record<string, unknown>;
-}
-
-/**
- * Represents the history of messages exchanged within a task's session.
- */
-export interface TaskHistory {
-  /**
-   * List of messages in chronological order.
-   * @default []
-   */
-  messageHistory?: Message[];
-}
-
-/**
- * Represents a status update event for a task, typically used in streaming scenarios.
- */
-export interface TaskStatusUpdateEvent {
-  /**
-   * The ID of the task being updated.
-   */
-  id: string;
-
-  /**
-   * The new status of the task.
-   */
-  status: TaskStatus;
-
-  /**
-   * Flag indicating if this is the final update for the task.
-   * @default false
-   */
-  final?: boolean;
-
-  /**
-   * Optional metadata associated with this update event.
-   */
-  metadata?: Record<string, unknown>;
-}
-
-/**
- * Represents an artifact update event for a task, typically used in streaming scenarios.
- */
-export interface TaskArtifactUpdateEvent {
-  /**
-   * The ID of the task being updated.
-   */
-  id: string;
-
-  /**
-   * The new or updated artifact for the task.
-   */
-  artifact: Artifact;
-
-  /**
-   * Flag indicating if this is the final update for the task.
-   * @default false
-   */
-  final?: boolean;
-
-  /**
-   * Optional metadata associated with this update event.
-   */
-  metadata?: Record<string, unknown>;
-}
-
-// Alias for backward compatibility
-export type TaskUpdateEvent = TaskStatusUpdateEvent;
-
-// === Error Types (Standard and A2A)
-
-/** Error code for JSON Parse Error (-32700). Invalid JSON was received by the server. */
-export const ErrorCodeParseError = -32700;
-export type ErrorCodeParseError = typeof ErrorCodeParseError;
-/** Error code for Invalid Request (-32600). The JSON sent is not a valid Request object. */
-export const ErrorCodeInvalidRequest = -32600;
-export type ErrorCodeInvalidRequest = typeof ErrorCodeInvalidRequest;
-/** Error code for Method Not Found (-32601). The method does not exist / is not available. */
-export const ErrorCodeMethodNotFound = -32601;
-export type ErrorCodeMethodNotFound = typeof ErrorCodeMethodNotFound;
-/** Error code for Invalid Params (-32602). Invalid method parameter(s). */
-export const ErrorCodeInvalidParams = -32602;
-export type ErrorCodeInvalidParams = typeof ErrorCodeInvalidParams;
-/** Error code for Internal Error (-32603). Internal JSON-RPC error. */
-export const ErrorCodeInternalError = -32603;
-export type ErrorCodeInternalError = typeof ErrorCodeInternalError;
-
-/** Error code for Task Not Found (-32001). The specified task was not found. */
-export const ErrorCodeTaskNotFound = -32001;
-export type ErrorCodeTaskNotFound = typeof ErrorCodeTaskNotFound;
-/** Error code for Task Not Cancelable (-32002). The specified task cannot be canceled. */
-export const ErrorCodeTaskNotCancelable = -32002;
-export type ErrorCodeTaskNotCancelable = typeof ErrorCodeTaskNotCancelable;
-/** Error code for Push Notification Not Supported (-32003). Push Notifications are not supported for this operation or agent. */
-export const ErrorCodePushNotificationNotSupported = -32003;
-export type ErrorCodePushNotificationNotSupported =
-  typeof ErrorCodePushNotificationNotSupported;
-/** Error code for Unsupported Operation (-32004). The requested operation is not supported by the agent. */
-export const ErrorCodeUnsupportedOperation = -32004;
-export type ErrorCodeUnsupportedOperation =
-  typeof ErrorCodeUnsupportedOperation;
-
-/**
- * Union of all well-known A2A and standard JSON-RPC error codes defined in this schema.
- * Use this type for checking against specific error codes. A server might theoretically
- * use other codes within the valid JSON-RPC ranges.
- */
-export type KnownErrorCode =
-  | typeof ErrorCodeParseError
-  | typeof ErrorCodeInvalidRequest
-  | typeof ErrorCodeMethodNotFound
-  | typeof ErrorCodeInvalidParams
-  | typeof ErrorCodeInternalError
-  | typeof ErrorCodeTaskNotFound
-  | typeof ErrorCodeTaskNotCancelable
-  | typeof ErrorCodePushNotificationNotSupported
-  | typeof ErrorCodeUnsupportedOperation;
-
-export type A2AError = JSONRPCError<unknown, KnownErrorCode | number>;
-
-// === Push Notifications and Authentication Info
-
-/**
- * Authentication information, potentially including additional properties beyond the standard ones.
- * (Note: Schema allows additional properties).
- */
-export interface AuthenticationInfo extends AgentAuthentication {
-  /** Allow any other properties */
-  [key: string]: any;
-}
-
-/**
- * Information required for setting up push notifications.
- */
-export interface PushNotificationConfig {
-  /**
-   * The URL endpoint where the agent should send notifications.
-   */
-  url: string;
-
-  /**
-   * A token to be included in push notification requests for verification/authentication.
-   */
-  token?: string;
-
-  /**
-   * Optional authentication details needed by the agent to call the notification URL.
-   */
-  authentication?: AuthenticationInfo;
-}
-
-/**
- * Represents the push notification information associated with a specific task ID.
- * Used as parameters for `tasks/pushNotification/set` and as a result type.
- */
-export interface TaskPushNotificationConfig {
-  /**
-   * The ID of the task the notification config is associated with.
-   */
-  id: string;
-  /**
-   * The push notification configuration details.
-   */
-  pushNotificationConfig: PushNotificationConfig;
-}
-
-// ================================================================= A2A Request Parameter Types
-// =================================================================
-
-/**
- * Parameters for the `tasks/send` method.
- */
-export interface TaskSendParams {
-  /**
-   * Unique identifier for the task being initiated or continued.
-   */
-  id: string;
-
-  /**
-   * Optional identifier for the session this task belongs to. If not provided, a new session might be implicitly created depending on the agent.
-   */
-  sessionId?: string;
-
-  /**
-   * The message content to send to the agent for processing.
-   */
-  message: Message;
-
-  /**
-   * Optional pushNotification information for receiving notifications about this task. Requires agent capability.
-   */
-  pushNotification?: PushNotificationConfig;
-
-  /**
-   * Optional parameter to specify how much message history to include in the response.
-   */
-  historyLength?: number;
-
-  /**
-   * Optional metadata associated with sending this message.
-   */
-  metadata?: Record<string, unknown>;
-}
-
-/**
- * Basic parameters used for task ID operations.
- * Used by: `tasks/cancel`, `tasks/pushNotification/get`.
- */
-export interface TaskIdParams {
-  /**
-   * The unique identifier of the task.
-   */
-  id: string;
-
-  /**
-   * Optional metadata to include with the operation.
-   */
-  metadata?: Record<string, unknown>;
-}
-
-/**
- * Parameters used for querying task-related information by ID.
- * Used by: `tasks/get`, `tasks/getHistory`, `tasks/subscribe`, `tasks/resubscribe`.
- */
-export interface TaskQueryParams extends TaskIdParams {
-  /**
-   * Optional history length to retrieve for the task.
-   */
-  historyLength?: number;
-}
-
-// === A2A Request Interfaces
-
-/**
- * Request to send a message/initiate a task.
- */
-export interface SendTaskRequest extends JSONRPCRequest {
-  /**
-   * Method name for sending a task message.
-   */
-  method: "tasks/send";
-  /**
-   * Parameters for the send task method.
-   */
-  params: TaskSendParams;
-}
-
-/**
- * Request to retrieve the current state of a task.
- */
-export interface GetTaskRequest extends JSONRPCRequest {
-  /**
-   * Method name for getting task status.
-   */
-  method: "tasks/get";
-  /**
-   * Parameters for the get task method.
-   */
-  params: TaskQueryParams;
-}
-
-/**
- * Request to cancel a currently running task.
- */
-export interface CancelTaskRequest extends JSONRPCRequest {
-  /**
-   * Method name for canceling a task.
-   */
-  method: "tasks/cancel";
-  /**
-   * Parameters for the cancel task method.
-   */
-  params: TaskIdParams;
-}
-
-/**
- * Request to set or update the push notification config for a task.
- */
-export interface SetTaskPushNotificationRequest extends JSONRPCRequest {
-  /**
-   * Method name for setting a task notifications.
-   */
-  method: "tasks/pushNotification/set";
-  /**
-   * Parameters for the set task push notification method.
-   */
-  params: TaskPushNotificationConfig; // Uses TaskPushNotificationConfig directly as params
-}
-
-/**
- * Request to retrieve the currently configured push notification configuration for a task.
- */
-export interface GetTaskPushNotificationRequest extends JSONRPCRequest {
-  /**
-   * Method name for getting task notification configuration.
-   */
-  method: "tasks/pushNotification/get";
-  /**
-   * Parameters for the get task push notification config method.
-   */
-  params: TaskIdParams;
-}
-
-/**
- * Request to resubscribe to updates for a task after a connection interruption.
- */
-export interface TaskResubscriptionRequest extends JSONRPCRequest {
-  /**
-   * Method name for resubscribing to task updates.
-   */
-  method: "tasks/resubscribe";
-  /**
-   * Parameters for the task resubscription method.
-   */
-  params: TaskQueryParams;
-}
-
-/**
- * Request to send a message/initiate a task and subscribe to streaming updates.
- */
-export interface SendTaskStreamingRequest extends JSONRPCRequest {
-  /**
-   * Method name for sending a task message and subscribing to updates.
-   */
-  method: "tasks/sendSubscribe";
-  /**
-   * Parameters for the streaming task send method.
-   */
-  params: TaskSendParams;
-}
-
-// === A2A Response Interfaces
-
-/**
- * Response to a `tasks/send` request.
- * Contains the Task object or an error.
- */
-export type SendTaskResponse = JSONRPCResponse<Task, A2AError>;
-
-/**
- * Response to a streaming task operation, either through `tasks/sendSubscribe` or a subscription.
- * Contains a TaskStatusUpdateEvent, TaskArtifactUpdateEvent, or an error.
- */
-export type SendTaskStreamingResponse = JSONRPCResponse<
-  TaskStatusUpdateEvent | TaskArtifactUpdateEvent,
-  A2AError
->;
-
-/**
- * Response to a `tasks/get` request. Contains the Task object or an error.
- */
-export type GetTaskResponse = JSONRPCResponse<Task, A2AError>;
-
-/**
- * Response to a `tasks/cancel` request. Contains the updated Task object (usually with 'canceled' state) or an error.
- */
-export type CancelTaskResponse = JSONRPCResponse<Task, A2AError>;
-
-/**
- * Response to a `tasks/getHistory` request. Contains the TaskHistory object or an error.
- */
-export type GetTaskHistoryResponse = JSONRPCResponse<TaskHistory, A2AError>;
-
-/**
- * Response to a `tasks/pushNotification/set` request. Contains the confirmed TaskPushNotificationConfig or an error.
- */
-export type SetTaskPushNotificationResponse = JSONRPCResponse<
-  TaskPushNotificationConfig,
-  A2AError
->;
-
-/**
- * Response to a `tasks/pushNotification/get` request. Contains the TaskPushNotificationConfig or an error.
- */
-export type GetTaskPushNotificationResponse = JSONRPCResponse<
-  TaskPushNotificationConfig,
-  A2AError
->;
-
-// Note: The response to TaskSubscriptionRequest is typically handled by the underlying protocol
-// (like WebSocket messages containing TaskUpdateEvent) rather than a single JSON-RPC response object.
-// The schema doesn't define a specific JSON-RPC response type for `tasks/subscribe`.
-
-// === Union Types for A2A Requests/Responses
-
-/**
- * Represents any valid request defined in the A2A protocol.
- */
-export type A2ARequest =
-  | SendTaskRequest
-  | GetTaskRequest
-  | CancelTaskRequest
-  // | GetTaskHistoryRequest // Removed as it's not in the latest spec
-  | SetTaskPushNotificationRequest
-  | GetTaskPushNotificationRequest
-  // | TaskSubscriptionRequest // Removed as it's replaced by sendSubscribe or resubscribe
-  | TaskResubscriptionRequest
-  | SendTaskStreamingRequest;
-
-/**
- * Represents any valid JSON-RPC response defined in the A2A protocol.
- * (This is a helper type, not explicitly defined with `oneOf` in the schema like A2ARequest, but useful).
- */
-export type A2AResponse =
-  | SendTaskResponse
-  | GetTaskResponse
-  | CancelTaskResponse
-  | GetTaskHistoryResponse
-  | SetTaskPushNotificationResponse
-  | GetTaskPushNotificationResponse;
-// Subscription responses are typically event streams (TaskUpdateEvent) sent over the transport,
-// not direct JSON-RPC responses to the subscribe request itself.
diff --git a/src/types/schemas/a2a/auth/auth.ts b/src/types/schemas/a2a/auth/auth.ts
new file mode 100644
index 0000000..ade88b4
--- /dev/null
+++ b/src/types/schemas/a2a/auth/auth.ts
@@ -0,0 +1,94 @@
+import { SecuritySchemeBase } from "./base.js";
+import { OAuthFlows } from "./oauth.js";
+
+/**
+ * @description API Key security scheme.
+ * @required type
+ * @required in
+ * @required name
+ */
+export interface APIKeySecurityScheme extends SecuritySchemeBase {
+  /**
+   * @required Type of the security scheme.
+   */
+  type: "apiKey";
+
+  /**
+   * @required The location of the API key. Valid values are "query", "header", or "cookie".
+   */
+  in: "query" | "header" | "cookie";
+
+  /**
+   * @required The name of the header, query or cookie parameter to be used.
+   */
+  name: string;
+}
+
+/**
+ * @description HTTP Authentication security scheme.
+ * @required type
+ * @required scheme
+ * @optional bearerFormat
+ */
+export interface HTTPAuthSecurityScheme extends SecuritySchemeBase {
+  /**
+   * @required Type of the security scheme.
+   */
+  type: "http";
+
+  /**
+   * @required The name of the HTTP Authentication scheme to be used in the Authorization header as defined
+   * in RFC7235. The values used SHOULD be registered in the IANA Authentication Scheme registry.
+   * The value is case-insensitive, as defined in RFC7235.
+   */
+  scheme: string;
+
+  /**
+   * @optional A hint to the client to identify how the bearer token is formatted. Bearer tokens are usually
+   * generated by an authorization server, so this information is primarily for documentation
+   * purposes.
+   */
+  bearerFormat?: string;
+}
+
+/**
+ * @description OAuth2 security scheme configuration.
+ * @required type
+ * @required flows
+ * Mirrors the OpenAPI Security Scheme Object
+ * (https://swagger.io/specification/#security-scheme-object)
+ */
+export interface OAuth2SecurityScheme extends SecuritySchemeBase {
+  /**
+   * @required Type of the security scheme.
+   */
+  type: "oauth2";
+
+  /**
+   * @required An object containing configuration information for the flow types supported.
+   */
+  flows: OAuthFlows;
+}
+
+/**
+ * @description OpenID Connect security scheme.
+ * @required type
+ * @required openIdConnectUrl
+ */
+export interface OpenIdConnectSecurityScheme extends SecuritySchemeBase {
+  /**
+   * @required Type of the security scheme.
+   */
+  type: "openIdConnect";
+
+  /**
+   * @required Well-known URL to discover the [[OpenID-Connect-Discovery]] provider metadata.
+   */
+  openIdConnectUrl: string;
+}
+
+export type SecurityScheme =
+  | APIKeySecurityScheme
+  | HTTPAuthSecurityScheme
+  | OAuth2SecurityScheme
+  | OpenIdConnectSecurityScheme;
diff --git a/src/types/schemas/a2a/auth/base.ts b/src/types/schemas/a2a/auth/base.ts
new file mode 100644
index 0000000..7738c8d
--- /dev/null
+++ b/src/types/schemas/a2a/auth/base.ts
@@ -0,0 +1,16 @@
+/**
+ * @description Base properties shared by all security schemes.
+ * @required type
+ * @optional description
+ */
+export interface SecuritySchemeBase {
+  /**
+   * @required Type of the security scheme.
+   */
+  type: "apiKey" | "http" | "oauth2" | "openIdConnect";
+
+  /**
+   * @optional Description of this security scheme.
+   */
+  description?: string;
+}
diff --git a/src/types/schemas/a2a/auth/index.ts b/src/types/schemas/a2a/auth/index.ts
new file mode 100644
index 0000000..cccb88c
--- /dev/null
+++ b/src/types/schemas/a2a/auth/index.ts
@@ -0,0 +1,3 @@
+export * from "./base.js";
+export * from "./auth.js";
+export * from "./oauth.js";
diff --git a/src/types/schemas/a2a/auth/oauth.ts b/src/types/schemas/a2a/auth/oauth.ts
new file mode 100644
index 0000000..791baf4
--- /dev/null
+++ b/src/types/schemas/a2a/auth/oauth.ts
@@ -0,0 +1,139 @@
+/**
+ * @description Configuration details for a supported Authorization Code OAuth Flow
+ * @required authorizationUrl
+ * @required tokenUrl
+ * @optional refreshUrl
+ * @required scopes
+ */
+export interface AuthorizationCodeOAuthFlow {
+  /**
+   * @required The authorization URL to be used for this flow. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS
+   */
+  authorizationUrl: string;
+
+  /**
+   * @required The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard
+   * requires the use of TLS.
+   */
+  tokenUrl: string;
+
+  /**
+   * @optional The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS.
+   */
+  refreshUrl?: string;
+
+  /**
+   * @required The available scopes for the OAuth2 security scheme. A map between the scope name and a short
+   * description for it. The map MAY be empty.
+   */
+  scopes: Record<string, string>;
+}
+
+/**
+ * @description Configuration details for a supported Client Credentials OAuth Flow
+ * @required tokenUrl
+ * @optional refreshUrl
+ * @required scopes
+ */
+export interface ClientCredentialsOAuthFlow {
+  /**
+   * @required The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard
+   * requires the use of TLS.
+   */
+  tokenUrl: string;
+
+  /**
+   * @optional The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS.
+   */
+  refreshUrl?: string;
+
+  /**
+   * @required The available scopes for the OAuth2 security scheme. A map between the scope name and a short
+   * description for it. The map MAY be empty.
+   */
+  scopes: Record<string, string>;
+}
+
+/**
+ * @description Configuration details for a supported Implicit OAuth Flow
+ * @required authorizationUrl
+ * @optional refreshUrl
+ * @required scopes
+ */
+export interface ImplicitOAuthFlow {
+  /**
+   * @required The authorization URL to be used for this flow. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS
+   */
+  authorizationUrl: string;
+
+  /**
+   * @optional The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS.
+   */
+  refreshUrl?: string;
+
+  /**
+   * @required The available scopes for the OAuth2 security scheme. A map between the scope name and a short
+   * description for it. The map MAY be empty.
+   */
+  scopes: Record<string, string>;
+}
+
+/**
+ * @description Configuration details for a supported Password OAuth Flow
+ * @required tokenUrl
+ * @optional refreshUrl
+ * @required scopes
+ */
+export interface PasswordOAuthFlow {
+  /**
+   * @required The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard
+   * requires the use of TLS.
+   */
+  tokenUrl: string;
+
+  /**
+   * @optional The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS.
+   */
+  refreshUrl?: string;
+
+  /**
+   * @required The available scopes for the OAuth2 security scheme. A map between the scope name and a short
+   * description for it. The map MAY be empty.
+   */
+  scopes: Record<string, string>;
+}
+
+/**
+ * @description The configuration of supported OAuth Flows
+ * @optional authorizationCode
+ * @optional clientCredentials
+ * @optional implicit
+ * @optional password
+ */
+export interface OAuthFlows {
+  /**
+   * @optional Configuration for the OAuth Authorization Code flow. Previously called accessCode in OpenAPI 2.0.
+   */
+  authorizationCode?: AuthorizationCodeOAuthFlow;
+
+  /**
+   * @optional Configuration for the OAuth Client Credentials flow. Previously called application in OpenAPI 2.0
+   */
+  clientCredentials?: ClientCredentialsOAuthFlow;
+
+  /**
+   * @optional Configuration for the OAuth Implicit flow
+   */
+  implicit?: ImplicitOAuthFlow;
+
+  /**
+   * @optional Configuration for the OAuth Resource Owner Password flow
+   */
+  password?: PasswordOAuthFlow;
+}
diff --git a/src/types/schemas/a2a/error.ts b/src/types/schemas/a2a/error.ts
new file mode 100644
index 0000000..0604715
--- /dev/null
+++ b/src/types/schemas/a2a/error.ts
@@ -0,0 +1,157 @@
+import { JSONRPCError } from "./rpc.js";
+
+/**
+ * @description Error code for JSON Parse Error (-32700). Invalid JSON was received by the server.
+ */
+export const ErrorCodeParseError = -32700;
+export type ErrorCodeParseError = typeof ErrorCodeParseError;
+
+export type JSONParseError<Data = unknown> = JSONRPCError<
+  ErrorCodeParseError,
+  Data
+>;
+
+/**
+ * @description Error code for Invalid Request (-32600). The JSON sent is not a valid Request object.
+ */
+export const ErrorCodeInvalidRequest = -32600;
+export type ErrorCodeInvalidRequest = typeof ErrorCodeInvalidRequest;
+
+export type InvalidRequestError<Data = unknown> = JSONRPCError<
+  ErrorCodeInvalidRequest,
+  Data
+>;
+
+/**
+ * @description Error code for Method Not Found (-32601). The method does not exist / is not available.
+ */
+export const ErrorCodeMethodNotFound = -32601;
+export type ErrorCodeMethodNotFound = typeof ErrorCodeMethodNotFound;
+
+export type MethodNotFoundError<Data = unknown> = JSONRPCError<
+  ErrorCodeMethodNotFound,
+  Data
+>;
+
+/**
+ * @description Error code for Invalid Params (-32602). Invalid method parameter(s).
+ */
+export const ErrorCodeInvalidParams = -32602;
+export type ErrorCodeInvalidParams = typeof ErrorCodeInvalidParams;
+
+export type InvalidParamsError<Data = unknown> = JSONRPCError<
+  ErrorCodeInvalidParams,
+  Data
+>;
+
+/**
+ * @description Error code for Internal Error (-32603). Internal JSON-RPC error.
+ */
+export const ErrorCodeInternalError = -32603;
+export type ErrorCodeInternalError = typeof ErrorCodeInternalError;
+
+export type InternalError<Data = unknown> = JSONRPCError<
+  ErrorCodeInternalError,
+  Data
+>;
+
+/**
+ * @description Error code for Task Not Found (-32001). The specified task was not found.
+ */
+export const ErrorCodeTaskNotFound = -32001;
+export type ErrorCodeTaskNotFound = typeof ErrorCodeTaskNotFound;
+
+export type TaskNotFoundError<Data = unknown> = JSONRPCError<
+  ErrorCodeTaskNotFound,
+  Data
+>;
+
+/**
+ * @description Error code for Task Not Cancelable (-32002). The specified task cannot be canceled.
+ */
+export const ErrorCodeTaskNotCancelable = -32002;
+export type ErrorCodeTaskNotCancelable = typeof ErrorCodeTaskNotCancelable;
+
+export type TaskNotCancelableError<Data = unknown> = JSONRPCError<
+  ErrorCodeTaskNotCancelable,
+  Data
+>;
+
+/**
+ * @description Error code for Push Notification Not Supported (-32003). Push Notifications are not supported for this operation or agent.
+ */
+export const ErrorCodePushNotificationNotSupported = -32003;
+export type ErrorCodePushNotificationNotSupported =
+  typeof ErrorCodePushNotificationNotSupported;
+
+export type PushNotificationNotSupportedError<Data = unknown> = JSONRPCError<
+  ErrorCodePushNotificationNotSupported,
+  Data
+>;
+
+/**
+ * @description Error code for Unsupported Operation (-32004). The requested operation is not supported by the agent.
+ */
+export const ErrorCodeUnsupportedOperation = -32004;
+export type ErrorCodeUnsupportedOperation =
+  typeof ErrorCodeUnsupportedOperation;
+
+export type UnsupportedOperationError<Data = unknown> = JSONRPCError<
+  ErrorCodeUnsupportedOperation,
+  Data
+>;
+
+/**
+ * @description Error code for Content Type Not Supported (-32005). The requested content type is not supported by the agent.
+ */
+export const ErrorCodeContentTypeNotSupported = -32005;
+export type ErrorCodeContentTypeNotSupported =
+  typeof ErrorCodeContentTypeNotSupported;
+
+export type ContentTypeNotSupportedError<Data = unknown> = JSONRPCError<
+  ErrorCodeContentTypeNotSupported,
+  Data
+>;
+
+/**
+ * @description Error code for Invalid Agent Response (-32006). The agent returned an invalid response for the current method.
+ */
+export const ErrorCodeInvalidAgentResponse = -32006;
+export type ErrorCodeInvalidAgentResponse =
+  typeof ErrorCodeInvalidAgentResponse;
+
+export type InvalidAgentResponseError<Data = unknown> = JSONRPCError<
+  ErrorCodeInvalidAgentResponse,
+  Data
+>;
+
+/**
+ * Union of all well-known A2A and standard JSON-RPC error codes defined in this schema.
+ * Use this type for checking against specific error codes. A server might theoretically
+ * use other codes within the valid JSON-RPC ranges.
+ */
+export type KnownErrorCode =
+  | typeof ErrorCodeParseError
+  | typeof ErrorCodeInvalidRequest
+  | typeof ErrorCodeMethodNotFound
+  | typeof ErrorCodeInvalidParams
+  | typeof ErrorCodeInternalError
+  | typeof ErrorCodeTaskNotFound
+  | typeof ErrorCodeTaskNotCancelable
+  | typeof ErrorCodePushNotificationNotSupported
+  | typeof ErrorCodeUnsupportedOperation
+  | typeof ErrorCodeContentTypeNotSupported
+  | typeof ErrorCodeInvalidAgentResponse;
+
+export type A2AError<Data = unknown> =
+  | JSONParseError<Data>
+  | InvalidRequestError<Data>
+  | MethodNotFoundError<Data>
+  | InvalidParamsError<Data>
+  | InternalError<Data>
+  | TaskNotFoundError<Data>
+  | TaskNotCancelableError<Data>
+  | PushNotificationNotSupportedError<Data>
+  | UnsupportedOperationError<Data>
+  | ContentTypeNotSupportedError<Data>
+  | InvalidAgentResponseError<Data>;
diff --git a/src/types/schemas/a2a/index.ts b/src/types/schemas/a2a/index.ts
new file mode 100644
index 0000000..a6397f1
--- /dev/null
+++ b/src/types/schemas/a2a/index.ts
@@ -0,0 +1,307 @@
+import { SecurityScheme } from "./auth/auth.js";
+/**
+ * @description Represents the provider or organization behind an agent.
+ */
+export interface AgentProvider {
+  /**
+   * @required The name of the organization providing the agent.
+   */
+  organization: string;
+
+  /**
+   * @required URL associated with the agent provider.
+   */
+  url: string;
+}
+
+/**
+ * @description Defines optional capabilities supported by an agent.
+ */
+export interface AgentCapabilities {
+  /**
+   * @required Indicates if the agent supports streaming responses.
+   */
+  streaming?: boolean;
+
+  /**
+   * @required Indicates if the agent supports push notification mechanisms.
+   */
+  pushNotifications?: boolean;
+
+  /**
+   * @required Indicates if the agent supports providing state transition history.
+   */
+  stateTransitionHistory?: boolean;
+
+  /**
+   * @optional Extensions supported by this agent.
+   */
+  extensions?: AgentExtension[];
+}
+
+/**
+ * @description A declaration of an extension supported by an Agent.
+ */
+export interface AgentExtension {
+  /**
+   * @required The URI of the extension.
+   */
+  uri: string;
+  /**
+   * @optional A description of how this agent uses this extension.
+   */
+  description?: string;
+
+  /**
+   * @optional Whether the client must follow specific requirements of the extension.
+   */
+  required?: boolean;
+
+  /**
+   * @optional Optional configuration for the extension.
+   */
+  params?: Record<string, unknown>;
+}
+
+/**
+ * @description Represents a unit of capability that an agent can perform.
+ */
+export interface AgentSkill {
+  /**
+   * @required Unique identifier for the skill.
+   */
+  id: string;
+
+  /**
+   * @required Human-readable name of the skill.
+   */
+  name: string;
+
+  /**
+   * @required description of the skill.
+   * @description Description of the skill - will be used by the client or a human
+   * as a hint to understand what the skill does.
+   */
+  description: string;
+
+  /**
+   * @required list of tags associated with the skill for categorization.
+   * @description Set of tagwords describing classes of capabilities for this specific skill.
+   * @example ["cooking", "customer support", "billing"]
+   */
+  tags: string[];
+
+  /**
+   * @optional list of example inputs or use cases for the skill.
+   * @description The set of example scenarios that the skill can perform.
+   * Will be used by the client as a hint to understand how the skill can be used.
+   * @example ["I need a recipe for bread"]
+   */
+  examples?: string[];
+
+  /**
+   * @optional list of input modes supported by this skill.
+   * @description The set of interaction modes that the skill supports
+   * (if different than the default).
+   * Supported mime types for input.
+   */
+  inputModes?: string[];
+
+  /**
+   * @optional list of output modes supported by this skil.
+   * @description Supported mime types for output.
+   */
+  outputModes?: string[];
+}
+
+/**
+ * @description An AgentCard conveys key information:
+ * - Overall details (version, name, description, uses)
+ * - Skills: A set of capabilities the agent can perform
+ * - Default modalities/content types supported by the agent.
+ * - Authentication requirements
+ * @required name
+ * @required description
+ * @required url
+ * @optional iconUrl
+ * @required version
+ * @required capabilities
+ * @required defaultInputModes
+ * @required defaultOutputModes
+ * @required skills
+ * @optional provider
+ * @optional documentationUrl
+ * @optional securitySchemes
+ * @optional security
+ * @optional supportsAuthenticatedExtendedCard
+ */
+export interface AgentCard {
+  /**
+   * @required Human readable name of the agent.
+   * @example "Recipe Agent"
+   */
+  name: string;
+
+  /**
+   * @required A human-readable description of the agent.
+   * @description Used to assist users and other agents in understanding what the agent can do.
+   * @example "Agent that helps users with recipes and cooking."
+   */
+  description: string;
+
+  /**
+   * @required The base URL endpoint for interacting with the agent.
+   * @description The URL where the agent is hosted.
+   * @example "https://recipe-agent.com"
+   */
+  url: string;
+
+  /**
+   * @optional The URL of the agent's icon.
+   * @description The URL of the agent's icon.
+   * @example "https://recipe-agent.com/icon.png"
+   */
+  iconUrl?: string;
+
+  /**
+   * @optional the service provider of the agent.
+   * @description The organization or entity that provides the agent.
+   * @example { organization: "Recipe Inc.", url: "https://recipe-inc.com" }
+   */
+  provider?: AgentProvider;
+
+  /**
+   * @required The version identifier for the agent or its API.
+   * @description The version of the agent - format is up to the provider.
+   * @example "1.0.0"
+   */
+  version: string;
+
+  /**
+   * @optional An optional URL pointing to the agent's documentation.
+   * @description A URL to documentation for the agent.
+   * @example "https://recipe-agent.com/docs"
+   */
+  documentationUrl?: string;
+
+  /**
+   * @required The capabilities supported by the agent.
+   * @description The capabilities supported by the agent.
+   * @example { "streaming": true, "pushNotifications": true, "stateTransitionHistory": true }
+   */
+  capabilities: AgentCapabilities;
+
+  /**
+   * @optional Security scheme details used for authenticating with this agent.
+   * @description The security schemes supported by the agent.
+   */
+  securitySchemes?: Record<string, SecurityScheme>;
+
+  /**
+   * @optional Security requirements for contacting the agent.
+   * @description The security requirements for contacting the agent.
+   */
+  security?: Record<string, string[]>[];
+
+  /**
+   * @required The default input modes supported by the agent.
+   * @description The set of interaction modes that the agent supports across all skills. This can be overridden per-skill.
+   * Supported mime types for input.
+   */
+  defaultInputModes: string[];
+
+  /**
+   * @required The default output modes supported by the agent.
+   * @description Supported mime types for output.
+   */
+  defaultOutputModes: string[];
+
+  /**
+   * @required List of specific skills offered by the agent.
+   * @description The set of skills that the agent can perform.
+   * @example [{ "id": "recipe-search", "name": "Recipe Search", "description": "Search for recipes", "tags": ["cooking", "recipes"], "examples": ["I need a recipe for bread"] }]
+   */
+  skills: AgentSkill[];
+
+  /**
+   * @optional true if the agent supports providing an extended agent card when the user is authenticated.
+   */
+  supportsAuthenticatedExtendedCard?: boolean;
+}
+
+export * from "./task.js";
+export * from "./message.js";
+export * from "./parameters.js";
+export * from "./notification.js";
+export * from "./auth/index.js";
+export * from "./rpc.js";
+
+import {
+  SendMessageRequest,
+  SendMessageResponse,
+  SendStreamingMessageRequest,
+  SendStreamingMessageResponse,
+} from "./message.js";
+import {
+  CancelTaskRequest,
+  CancelTaskResponse,
+  GetTaskRequest,
+  GetTaskResponse,
+  TaskResubscriptionRequest,
+} from "./task.js";
+import {
+  SetTaskPushNotificationConfigResponse,
+  GetTaskPushNotificationConfigResponse,
+  SetTaskPushNotificationConfigRequest,
+  GetTaskPushNotificationConfigRequest,
+} from "./notification.js";
+
+export type A2ARequest =
+  | SendMessageRequest
+  | GetTaskRequest
+  | CancelTaskRequest
+  | SetTaskPushNotificationConfigRequest
+  | GetTaskPushNotificationConfigRequest
+  | TaskResubscriptionRequest
+  | SendStreamingMessageRequest;
+
+/**
+ * Represents any valid JSON-RPC response defined in the A2A protocol.
+ * (This is a helper type, not explicitly defined with `oneOf` in the schema like A2ARequest, but useful).
+ */
+export type A2AResponse =
+  | SendMessageResponse
+  | SendStreamingMessageResponse
+  | GetTaskResponse
+  | CancelTaskResponse
+  | SetTaskPushNotificationConfigResponse
+  | GetTaskPushNotificationConfigResponse;
+
+export * from "./error.js";
+
+import {
+  JSONParseError,
+  InvalidRequestError,
+  MethodNotFoundError,
+  InvalidParamsError,
+  InternalError,
+  TaskNotFoundError,
+  TaskNotCancelableError,
+  PushNotificationNotSupportedError,
+  UnsupportedOperationError,
+  ContentTypeNotSupportedError,
+  InvalidAgentResponseError,
+} from "./error.js";
+
+export type A2AError =
+  | JSONParseError
+  | InvalidRequestError
+  | MethodNotFoundError
+  | InvalidParamsError
+  | InternalError
+  | TaskNotFoundError
+  | TaskNotCancelableError
+  | PushNotificationNotSupportedError
+  | UnsupportedOperationError
+  | ContentTypeNotSupportedError
+  | InvalidAgentResponseError;
diff --git a/src/types/schemas/a2a/message.ts b/src/types/schemas/a2a/message.ts
new file mode 100644
index 0000000..1dd302a
--- /dev/null
+++ b/src/types/schemas/a2a/message.ts
@@ -0,0 +1,122 @@
+import { PushNotificationConfig } from "./notification.js";
+import { Message } from "./parameters.js";
+import { TaskArtifactUpdateEvent } from "./task.js";
+import { TaskStatusUpdateEvent } from "./task.js";
+import {
+  JSONRPCErrorResponse,
+  JSONRPCRequestWithParams,
+  JSONRPCSuccessResponse,
+} from "./rpc.js";
+import { Task } from "./task.js";
+
+/**
+ * @description Configuration for the send message request.
+ * @required acceptedOutputModes
+ * @optional historyLength
+ * @optional pushNotificationConfig
+ * @optional blocking
+ */
+export interface MessageSendConfiguration {
+  /**
+   * @required Accepted output modalities by the client.
+   */
+  acceptedOutputModes: string[];
+
+  /**
+   * @optional Number of recent messages to be retrieved.
+   */
+  historyLength?: number;
+
+  /**
+   * @optional Where the server should send notifications when disconnected.
+   */
+  pushNotificationConfig?: PushNotificationConfig;
+
+  /**
+   * @optional If the server should treat the client as a blocking request.
+   */
+  blocking?: boolean;
+}
+
+/**
+ * @description Sent by the client to the agent as a request. May create, continue or restart a task.
+ * @required message
+ * @optional configuration
+ * @optional metadata
+ */
+export interface MessageSendParams {
+  /**
+   * @required The message content to send to the agent for processing.
+   */
+  message: Message;
+
+  /**
+   * @optional configuration information for the message.
+   */
+  configuration?: MessageSendConfiguration;
+
+  /**
+   * @optional Extension metadata.
+   */
+  metadata?: Record<string, unknown>;
+}
+
+/**
+ * @description Request to send a message/initiate a task.
+ * @required id
+ * @required method
+ * @required params
+ */
+export type SendMessageRequest = JSONRPCRequestWithParams<
+  "message/send",
+  MessageSendParams
+>;
+
+/**
+ * @description JSON-RPC success response model for the 'message/send' method.
+ * @required result
+ * @never error
+ * @oneOf Message | Task
+ */
+export type SendMessageSuccessResponse = JSONRPCSuccessResponse<Message | Task>;
+
+/**
+ * @description JSON-RPC response model for the 'message/send' method.
+ * @oneOf SendMessageSuccessResponse | JSONRPCErrorResponse
+ */
+export type SendMessageResponse =
+  | SendMessageSuccessResponse
+  | JSONRPCErrorResponse;
+
+// Note: The response to SendMessageStreamingRequest is typically handled by the underlying protocol
+// (like WebSocket messages containing TaskUpdateEvent) rather than a single JSON-RPC response object.
+// The schema doesn't define a specific JSON-RPC response type for `tasks/subscribe`.
+
+/**
+ * @description Request to send a message/initiate a task and subscribe to streaming updates.
+ * @required id
+ * @required method
+ * @required params
+ */
+export type SendStreamingMessageRequest = JSONRPCRequestWithParams<
+  "message/stream",
+  MessageSendParams
+>;
+
+/**
+ * @description JSON-RPC success response model for the 'message/stream' method.
+ * @required result
+ * @never error
+ * @oneOf Message | Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
+ */
+export type SendStreamingMessageSuccessResponse = JSONRPCSuccessResponse<
+  Message | Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
+>;
+
+/**
+ * @description Response to a streaming task operation, either through `message/stream` or a subscription.
+ * @oneOf Message | Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
+ */
+export type SendStreamingMessageResponse =
+  | SendStreamingMessageSuccessResponse
+  | JSONRPCErrorResponse;
diff --git a/src/types/schemas/a2a/notification.ts b/src/types/schemas/a2a/notification.ts
new file mode 100644
index 0000000..5c25ee7
--- /dev/null
+++ b/src/types/schemas/a2a/notification.ts
@@ -0,0 +1,114 @@
+import {
+  JSONRPCErrorResponse,
+  JSONRPCRequestWithParams,
+  JSONRPCSuccessResponse,
+} from "./rpc.js";
+import { TaskIdParams } from "./task.js";
+
+/**
+ * @description Information required for setting up push notifications.
+ * @required schemes
+ * @optional credentials
+ */
+export interface PushNotificationAuthenticationInfo {
+  /**
+   * @required Supported authentication schemes - e.g. Basic, Bearer */
+  schemes: string[];
+
+  /**
+   * @optional credentials
+   */
+  credentials?: string;
+}
+
+/**
+ * @description Configuration for setting up push notifications for task updates.
+ * @required url
+ * @optional token
+ * @optional authentication
+ */
+export interface PushNotificationConfig {
+  /**
+   * @optional Push Notification ID - created by server to support multiple callbacks.
+   */
+  id?: string;
+  /**
+   * @required The URL endpoint where the agent should send notifications.
+   */
+  url: string;
+
+  /**
+   * @optional A token to be included in push notification requests for verification/authentication.
+   */
+  token?: string;
+
+  /**
+   * @optional authentication details needed by the agent to call the notification URL.
+   */
+  authentication?: PushNotificationAuthenticationInfo;
+}
+
+/**
+ * @description Represents the push notification information associated with a specific task ID.
+ * Used as parameters for `tasks/pushNotificationConfig/set` and as a result type.
+ * @required taskId
+ * @required pushNotificationConfig
+ */
+export interface TaskPushNotificationConfig {
+  /**
+   * @required The ID of the task the notification config is associated with.
+   */
+  taskId: string;
+  /**
+   * @required The push notification configuration details.
+   */
+  pushNotificationConfig: PushNotificationConfig;
+}
+
+/**
+ * @description Request to set or update the push notification config for a task.
+ * @required TaskPushNotificationConfig
+ */
+export type SetTaskPushNotificationConfigRequest = JSONRPCRequestWithParams<
+  "tasks/pushNotificationConfig/set",
+  TaskPushNotificationConfig
+>;
+
+/**
+ * @description JSON-RPC success response model for the 'tasks/pushNotificationConfig/set' method.
+ * @required TaskPushNotificationConfig
+ */
+export type SetTaskPushNotificationConfigSuccessResponse =
+  JSONRPCSuccessResponse<TaskPushNotificationConfig>;
+
+/**
+ * @description Response to a `tasks/pushNotificationConfig/set` request. Contains the confirmed TaskPushNotificationConfig or an error.
+ * @oneOf SetTaskPushNotificationConfigSuccessResponse | JSONRPCErrorResponse
+ */
+export type SetTaskPushNotificationConfigResponse =
+  | SetTaskPushNotificationConfigSuccessResponse
+  | JSONRPCErrorResponse;
+
+/**
+ * @description Request to retrieve the currently configured push notification configuration for a task.
+ * @required TaskIdParams
+ */
+export type GetTaskPushNotificationConfigRequest = JSONRPCRequestWithParams<
+  "tasks/pushNotificationConfig/get",
+  TaskIdParams
+>;
+
+/**
+ * @description JSON-RPC success response model for the 'tasks/pushNotificationConfig/get' method.
+ * @required TaskPushNotificationConfig
+ */
+export type GetTaskPushNotificationConfigSuccessResponse =
+  JSONRPCSuccessResponse<TaskPushNotificationConfig>;
+
+/**
+ * @description Response to a `tasks/pushNotificationConfig/get` request. Contains the TaskPushNotificationConfig or an error.
+ * @oneOf GetTaskPushNotificationConfigSuccessResponse | JSONRPCErrorResponse
+ */
+export type GetTaskPushNotificationConfigResponse =
+  | GetTaskPushNotificationConfigSuccessResponse
+  | JSONRPCErrorResponse;
diff --git a/src/types/schemas/a2a/parameters.ts b/src/types/schemas/a2a/parameters.ts
new file mode 100644
index 0000000..515a819
--- /dev/null
+++ b/src/types/schemas/a2a/parameters.ts
@@ -0,0 +1,215 @@
+/**
+ * @description Represents the base entity for FileParts
+ * @optional name
+ * @optional mimeType
+ */
+export interface FileBase {
+  /**
+   * @optional name of the file.
+   */
+  name?: string;
+
+  /**
+   * @optional MIME type of the file content.
+   */
+  mimeType?: string;
+}
+
+/**
+ * @description Represents a file with its content encoded as a Base64 string.
+ * @required bytes
+ * @optional uri
+ */
+export interface FileWithBytes extends FileBase {
+  /**
+   * @required File content encoded as a Base64 string. Use this OR `uri`.
+   */
+  bytes: string;
+
+  /**
+   * @optional URI pointing to the file content.
+   */
+  uri?: never;
+}
+
+/**
+ * @description Represents a file with its content encoded as a Base64 string.
+ * @required uri
+ * @optional bytes
+ */
+export interface FileWithUri extends FileBase {
+  /**
+   * @required URI pointing to the file content.
+   */
+  uri: string;
+
+  /**
+   * @optional File content encoded as a Base64 string. Use this OR `uri`.
+   */
+  bytes?: never;
+}
+
+/**
+ * @description Represents the base entity for Parts
+ * @optional metadata
+ */
+export interface PartBase {
+  /**
+   * @optional metadata associated with the part.
+   */
+  metadata?: Record<string, unknown>;
+}
+
+/**
+ * @description Represents a part of a message containing text content.
+ * @required kind
+ * @required text
+ */
+export interface TextPart extends PartBase {
+  /**
+   * @required Type identifier for this part.
+   */
+  kind: "text";
+
+  /**
+   * @required The text content.
+   */
+  text: string;
+}
+
+/**
+ * @description Represents a part of a message containing file content.
+ * @required kind
+ * @required file
+ */
+export interface FilePart extends PartBase {
+  /**
+   * @required Type identifier for this part.
+   */
+  kind: "file";
+
+  /**
+   * @required The file content, provided either inline or via URI.
+   */
+  file: FileWithBytes | FileWithUri;
+}
+
+/**
+ * @description Represents a part of a message containing structured data (JSON).
+ * @required kind
+ * @required data
+ */
+export interface DataPart extends PartBase {
+  /**
+   * @required Type identifier for this part.
+   */
+  kind: "data";
+
+  /**
+   * @required The structured data content as a JSON object.
+   */
+  data: Record<string, unknown>;
+}
+
+/**
+ * @description Represents a single part of a multi-part message. Can be text, file, or data.
+ */
+export type Part = TextPart | FilePart | DataPart;
+
+/**
+ * @description Represents an artifact generated or used by a task, potentially composed of multiple parts.
+ * @required artifactId
+ * @optional name
+ * @optional description
+ * @required parts
+ * @optional metadata
+ * @optional extensions
+ */
+export interface Artifact {
+  /**
+   * @required Unique identifier for the artifact.
+   */
+  artifactId: string;
+
+  /**
+   * @optional name for the artifact.
+   */
+  name?: string;
+
+  /**
+   * @optional description of the artifact.
+   */
+  description?: string;
+
+  /**
+   * @required The constituent parts of the artifact.
+   */
+  parts: Part[];
+
+  /**
+   * @optional metadata associated with the artifact.
+   */
+  metadata?: Record<string, unknown>;
+
+  /**
+   * @optional The URIs of extensions that are present or contributed to this Artifact.
+   */
+  extension?: string;
+}
+
+/**
+ * @description Represents a message exchanged between a user and an agent.
+ * @required role
+ * @required parts
+ * @optional metadata
+ * @optional extensions
+ * @optional referenceTaskIds
+ * @optional messageId
+ * @optional taskId
+ */
+export interface Message {
+  /**
+   * @required The role of the sender (user or agent).
+   */
+  role: "user" | "agent";
+
+  /**
+   * @required The content of the message, composed of one or more parts.
+   */
+  parts: Part[];
+
+  /**
+   * @optional metadata associated with the message.
+   */
+  metadata?: Record<string, unknown>;
+
+  /**
+   * @optional The URIs of extensions that are present or contributed to this Message.
+   */
+  extensions?: string[];
+
+  /**
+   * @optional List of tasks referenced as context by this message.
+   */
+  referenceTaskIds?: string[];
+
+  /**
+   * @required Identifier created by the message creator
+   */
+  messageId: string;
+
+  /**
+   * @optional Identifier of task the message is related to
+   */
+  taskId?: string;
+
+  /**
+   * @optional The context the message is associated with
+   */
+  contextId?: string;
+
+  /**
+   * @required Event type
+   */
+  kind: "message";
+}
diff --git a/src/types/schemas/a2a/ref.ts b/src/types/schemas/a2a/ref.ts
new file mode 100644
index 0000000..731e748
--- /dev/null
+++ b/src/types/schemas/a2a/ref.ts
@@ -0,0 +1,2111 @@
+/* eslint-disable */
+/**
+ * This file was automatically generated by json-schema-to-typescript.
+ * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
+ * and run json-schema-to-typescript to regenerate this file.
+ */
+
+/**
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "A2AError".
+ */
+export type A2AError =
+  | JSONParseError
+  | InvalidRequestError
+  | MethodNotFoundError
+  | InvalidParamsError
+  | InternalError
+  | TaskNotFoundError
+  | TaskNotCancelableError
+  | PushNotificationNotSupportedError
+  | UnsupportedOperationError
+  | ContentTypeNotSupportedError
+  | InvalidAgentResponseError;
+/**
+ * A2A supported request types
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "A2ARequest".
+ */
+export type A2ARequest =
+  | SendMessageRequest
+  | SendStreamingMessageRequest
+  | GetTaskRequest
+  | CancelTaskRequest
+  | SetTaskPushNotificationConfigRequest
+  | GetTaskPushNotificationConfigRequest
+  | TaskResubscriptionRequest;
+/**
+ * Represents a part of a message, which can be text, a file, or structured data.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "Part".
+ */
+export type Part = TextPart | FilePart | DataPart;
+/**
+ * Mirrors the OpenAPI Security Scheme Object
+ * (https://swagger.io/specification/#security-scheme-object)
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "SecurityScheme".
+ */
+export type SecurityScheme =
+  | APIKeySecurityScheme
+  | HTTPAuthSecurityScheme
+  | OAuth2SecurityScheme
+  | OpenIdConnectSecurityScheme;
+/**
+ * JSON-RPC response for the 'tasks/cancel' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "CancelTaskResponse".
+ */
+export type CancelTaskResponse =
+  | JSONRPCErrorResponse
+  | CancelTaskSuccessResponse;
+/**
+ * JSON-RPC response for the 'tasks/pushNotificationConfig/set' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "GetTaskPushNotificationConfigResponse".
+ */
+export type GetTaskPushNotificationConfigResponse =
+  | JSONRPCErrorResponse
+  | GetTaskPushNotificationConfigSuccessResponse;
+/**
+ * JSON-RPC response for the 'tasks/get' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "GetTaskResponse".
+ */
+export type GetTaskResponse = JSONRPCErrorResponse | GetTaskSuccessResponse;
+/**
+ * Represents a JSON-RPC 2.0 Response object.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "JSONRPCResponse".
+ */
+export type JSONRPCResponse =
+  | JSONRPCErrorResponse
+  | SendMessageSuccessResponse
+  | SendStreamingMessageSuccessResponse
+  | GetTaskSuccessResponse
+  | CancelTaskSuccessResponse
+  | SetTaskPushNotificationConfigSuccessResponse
+  | GetTaskPushNotificationConfigSuccessResponse;
+/**
+ * JSON-RPC response model for the 'message/send' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "SendMessageResponse".
+ */
+export type SendMessageResponse =
+  | JSONRPCErrorResponse
+  | SendMessageSuccessResponse;
+/**
+ * JSON-RPC response model for the 'message/stream' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "SendStreamingMessageResponse".
+ */
+export type SendStreamingMessageResponse =
+  | JSONRPCErrorResponse
+  | SendStreamingMessageSuccessResponse;
+/**
+ * JSON-RPC response for the 'tasks/pushNotificationConfig/set' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "SetTaskPushNotificationConfigResponse".
+ */
+export type SetTaskPushNotificationConfigResponse =
+  | JSONRPCErrorResponse
+  | SetTaskPushNotificationConfigSuccessResponse;
+
+export interface MySchema {
+  [k: string]: unknown;
+}
+/**
+ * JSON-RPC error indicating invalid JSON was received by the server.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "JSONParseError".
+ */
+export interface JSONParseError {
+  /**
+   * A Number that indicates the error type that occurred.
+   */
+  code: -32700;
+  /**
+   * A Primitive or Structured value that contains additional information about the error.
+   * This may be omitted.
+   */
+  data?: {
+    [k: string]: unknown;
+  };
+  /**
+   * A String providing a short description of the error.
+   */
+  message: string;
+}
+/**
+ * JSON-RPC error indicating the JSON sent is not a valid Request object.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "InvalidRequestError".
+ */
+export interface InvalidRequestError {
+  /**
+   * A Number that indicates the error type that occurred.
+   */
+  code: -32600;
+  /**
+   * A Primitive or Structured value that contains additional information about the error.
+   * This may be omitted.
+   */
+  data?: {
+    [k: string]: unknown;
+  };
+  /**
+   * A String providing a short description of the error.
+   */
+  message: string;
+}
+/**
+ * JSON-RPC error indicating the method does not exist or is not available.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "MethodNotFoundError".
+ */
+export interface MethodNotFoundError {
+  /**
+   * A Number that indicates the error type that occurred.
+   */
+  code: -32601;
+  /**
+   * A Primitive or Structured value that contains additional information about the error.
+   * This may be omitted.
+   */
+  data?: {
+    [k: string]: unknown;
+  };
+  /**
+   * A String providing a short description of the error.
+   */
+  message: string;
+}
+/**
+ * JSON-RPC error indicating invalid method parameter(s).
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "InvalidParamsError".
+ */
+export interface InvalidParamsError {
+  /**
+   * A Number that indicates the error type that occurred.
+   */
+  code: -32602;
+  /**
+   * A Primitive or Structured value that contains additional information about the error.
+   * This may be omitted.
+   */
+  data?: {
+    [k: string]: unknown;
+  };
+  /**
+   * A String providing a short description of the error.
+   */
+  message: string;
+}
+/**
+ * JSON-RPC error indicating an internal JSON-RPC error on the server.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "InternalError".
+ */
+export interface InternalError {
+  /**
+   * A Number that indicates the error type that occurred.
+   */
+  code: -32603;
+  /**
+   * A Primitive or Structured value that contains additional information about the error.
+   * This may be omitted.
+   */
+  data?: {
+    [k: string]: unknown;
+  };
+  /**
+   * A String providing a short description of the error.
+   */
+  message: string;
+}
+/**
+ * A2A specific error indicating the requested task ID was not found.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "TaskNotFoundError".
+ */
+export interface TaskNotFoundError {
+  /**
+   * A Number that indicates the error type that occurred.
+   */
+  code: -32001;
+  /**
+   * A Primitive or Structured value that contains additional information about the error.
+   * This may be omitted.
+   */
+  data?: {
+    [k: string]: unknown;
+  };
+  /**
+   * A String providing a short description of the error.
+   */
+  message: string;
+}
+/**
+ * A2A specific error indicating the task is in a state where it cannot be canceled.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "TaskNotCancelableError".
+ */
+export interface TaskNotCancelableError {
+  /**
+   * A Number that indicates the error type that occurred.
+   */
+  code: -32002;
+  /**
+   * A Primitive or Structured value that contains additional information about the error.
+   * This may be omitted.
+   */
+  data?: {
+    [k: string]: unknown;
+  };
+  /**
+   * A String providing a short description of the error.
+   */
+  message: string;
+}
+/**
+ * A2A specific error indicating the agent does not support push notifications.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "PushNotificationNotSupportedError".
+ */
+export interface PushNotificationNotSupportedError {
+  /**
+   * A Number that indicates the error type that occurred.
+   */
+  code: -32003;
+  /**
+   * A Primitive or Structured value that contains additional information about the error.
+   * This may be omitted.
+   */
+  data?: {
+    [k: string]: unknown;
+  };
+  /**
+   * A String providing a short description of the error.
+   */
+  message: string;
+}
+/**
+ * A2A specific error indicating the requested operation is not supported by the agent.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "UnsupportedOperationError".
+ */
+export interface UnsupportedOperationError {
+  /**
+   * A Number that indicates the error type that occurred.
+   */
+  code: -32004;
+  /**
+   * A Primitive or Structured value that contains additional information about the error.
+   * This may be omitted.
+   */
+  data?: {
+    [k: string]: unknown;
+  };
+  /**
+   * A String providing a short description of the error.
+   */
+  message: string;
+}
+/**
+ * A2A specific error indicating incompatible content types between request and agent capabilities.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "ContentTypeNotSupportedError".
+ */
+export interface ContentTypeNotSupportedError {
+  /**
+   * A Number that indicates the error type that occurred.
+   */
+  code: -32005;
+  /**
+   * A Primitive or Structured value that contains additional information about the error.
+   * This may be omitted.
+   */
+  data?: {
+    [k: string]: unknown;
+  };
+  /**
+   * A String providing a short description of the error.
+   */
+  message: string;
+}
+/**
+ * A2A specific error indicating agent returned invalid response for the current method
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "InvalidAgentResponseError".
+ */
+export interface InvalidAgentResponseError {
+  /**
+   * A Number that indicates the error type that occurred.
+   */
+  code: -32006;
+  /**
+   * A Primitive or Structured value that contains additional information about the error.
+   * This may be omitted.
+   */
+  data?: {
+    [k: string]: unknown;
+  };
+  /**
+   * A String providing a short description of the error.
+   */
+  message: string;
+}
+/**
+ * JSON-RPC request model for the 'message/send' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "SendMessageRequest".
+ */
+export interface SendMessageRequest {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id: string | number;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+  /**
+   * A String containing the name of the method to be invoked.
+   */
+  method: "message/send";
+  params: MessageSendParams;
+}
+/**
+ * A Structured value that holds the parameter values to be used during the invocation of the method.
+ */
+export interface MessageSendParams {
+  configuration?: MessageSendConfiguration;
+  message: Message;
+  /**
+   * Extension metadata.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+}
+/**
+ * Send message configuration.
+ */
+export interface MessageSendConfiguration {
+  /**
+   * Accepted output modalities by the client.
+   */
+  acceptedOutputModes: string[];
+  /**
+   * If the server should treat the client as a blocking request.
+   */
+  blocking?: boolean;
+  /**
+   * Number of recent messages to be retrieved.
+   */
+  historyLength?: number;
+  pushNotificationConfig?: PushNotificationConfig;
+}
+/**
+ * Where the server should send notifications when disconnected.
+ */
+export interface PushNotificationConfig {
+  authentication?: PushNotificationAuthenticationInfo;
+  /**
+   * Push Notification ID - created by server to support multiple callbacks
+   */
+  id?: string;
+  /**
+   * Token unique to this task/session.
+   */
+  token?: string;
+  /**
+   * URL for sending the push notifications.
+   */
+  url: string;
+}
+/**
+ * Defines authentication details for push notifications.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "PushNotificationAuthenticationInfo".
+ */
+export interface PushNotificationAuthenticationInfo {
+  /**
+   * Optional credentials
+   */
+  credentials?: string;
+  /**
+   * Supported authentication schemes - e.g. Basic, Bearer
+   */
+  schemes: string[];
+}
+/**
+ * The message being sent to the server.
+ */
+export interface Message {
+  /**
+   * The context the message is associated with
+   */
+  contextId?: string;
+  /**
+   * The URIs of extensions that are present or contributed to this Message.
+   */
+  extensions?: string[]; //not in spec
+  /**
+   * Event type
+   */
+  kind: "message";
+  /**
+   * Identifier created by the message creator
+   */
+  messageId: string;
+  /**
+   * Extension metadata.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+  /**
+   * Message content
+   */
+  parts: Part[];
+  /**
+   * List of tasks referenced as context by this message.
+   */
+  referenceTaskIds?: string[];
+  /**
+   * Message sender's role
+   */
+  role: "agent" | "user";
+  /**
+   * Identifier of task the message is related to
+   */
+  taskId?: string;
+}
+/**
+ * Represents a text segment within parts.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "TextPart".
+ */
+export interface TextPart {
+  /**
+   * Part type - text for TextParts
+   */
+  kind: "text";
+  /**
+   * Optional metadata associated with the part.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+  /**
+   * Text content
+   */
+  text: string;
+}
+/**
+ * Represents a File segment within parts.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "FilePart".
+ */
+export interface FilePart {
+  /**
+   * File content either as url or bytes
+   */
+  file: FileWithBytes | FileWithUri;
+  /**
+   * Part type - file for FileParts
+   */
+  kind: "file";
+  /**
+   * Optional metadata associated with the part.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+}
+/**
+ * Define the variant where 'bytes' is present and 'uri' is absent
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "FileWithBytes".
+ */
+export interface FileWithBytes {
+  /**
+   * base64 encoded content of the file
+   */
+  bytes: string;
+  /**
+   * Optional mimeType for the file
+   */
+  mimeType?: string;
+  /**
+   * Optional name for the file
+   */
+  name?: string;
+}
+/**
+ * Define the variant where 'uri' is present and 'bytes' is absent
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "FileWithUri".
+ */
+export interface FileWithUri {
+  /**
+   * Optional mimeType for the file
+   */
+  mimeType?: string;
+  /**
+   * Optional name for the file
+   */
+  name?: string;
+  /**
+   * URL for the File content
+   */
+  uri: string;
+}
+/**
+ * Represents a structured data segment within a message part.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "DataPart".
+ */
+export interface DataPart {
+  /**
+   * Structured data content
+   */
+  data: {
+    [k: string]: unknown;
+  };
+  /**
+   * Part type - data for DataParts
+   */
+  kind: "data";
+  /**
+   * Optional metadata associated with the part.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+}
+/**
+ * JSON-RPC request model for the 'message/stream' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "SendStreamingMessageRequest".
+ */
+export interface SendStreamingMessageRequest {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id: string | number;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+  /**
+   * A String containing the name of the method to be invoked.
+   */
+  method: "message/stream";
+  params: MessageSendParams1;
+}
+/**
+ * A Structured value that holds the parameter values to be used during the invocation of the method.
+ */
+export interface MessageSendParams1 {
+  configuration?: MessageSendConfiguration;
+  message: Message;
+  /**
+   * Extension metadata.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+}
+/**
+ * JSON-RPC request model for the 'tasks/get' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "GetTaskRequest".
+ */
+export interface GetTaskRequest {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id: string | number;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+  /**
+   * A String containing the name of the method to be invoked.
+   */
+  method: "tasks/get";
+  params: TaskQueryParams;
+}
+/**
+ * A Structured value that holds the parameter values to be used during the invocation of the method.
+ */
+export interface TaskQueryParams {
+  /**
+   * Number of recent messages to be retrieved.
+   */
+  historyLength?: number;
+  /**
+   * Task id.
+   */
+  id: string;
+  metadata?: {
+    [k: string]: unknown;
+  };
+}
+/**
+ * JSON-RPC request model for the 'tasks/cancel' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "CancelTaskRequest".
+ */
+export interface CancelTaskRequest {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id: string | number;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+  /**
+   * A String containing the name of the method to be invoked.
+   */
+  method: "tasks/cancel";
+  params: TaskIdParams;
+}
+/**
+ * A Structured value that holds the parameter values to be used during the invocation of the method.
+ */
+export interface TaskIdParams {
+  /**
+   * Task id.
+   */
+  id: string;
+  metadata?: {
+    [k: string]: unknown;
+  };
+}
+/**
+ * JSON-RPC request model for the 'tasks/pushNotificationConfig/set' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "SetTaskPushNotificationConfigRequest".
+ */
+export interface SetTaskPushNotificationConfigRequest {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id: string | number;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+  /**
+   * A String containing the name of the method to be invoked.
+   */
+  method: "tasks/pushNotificationConfig/set";
+  params: TaskPushNotificationConfig;
+}
+/**
+ * A Structured value that holds the parameter values to be used during the invocation of the method.
+ */
+export interface TaskPushNotificationConfig {
+  pushNotificationConfig: PushNotificationConfig1;
+  /**
+   * Task id.
+   */
+  taskId: string;
+}
+/**
+ * Push notification configuration.
+ */
+export interface PushNotificationConfig1 {
+  authentication?: PushNotificationAuthenticationInfo;
+  /**
+   * Push Notification ID - created by server to support multiple callbacks
+   */
+  id?: string;
+  /**
+   * Token unique to this task/session.
+   */
+  token?: string;
+  /**
+   * URL for sending the push notifications.
+   */
+  url: string;
+}
+/**
+ * JSON-RPC request model for the 'tasks/pushNotificationConfig/get' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "GetTaskPushNotificationConfigRequest".
+ */
+export interface GetTaskPushNotificationConfigRequest {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id: string | number;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+  /**
+   * A String containing the name of the method to be invoked.
+   */
+  method: "tasks/pushNotificationConfig/get";
+  params: TaskIdParams1;
+}
+/**
+ * A Structured value that holds the parameter values to be used during the invocation of the method.
+ */
+export interface TaskIdParams1 {
+  /**
+   * Task id.
+   */
+  id: string;
+  metadata?: {
+    [k: string]: unknown;
+  };
+}
+/**
+ * JSON-RPC request model for the 'tasks/resubscribe' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "TaskResubscriptionRequest".
+ */
+export interface TaskResubscriptionRequest {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id: string | number;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+  /**
+   * A String containing the name of the method to be invoked.
+   */
+  method: "tasks/resubscribe";
+  params: TaskIdParams2;
+}
+/**
+ * A Structured value that holds the parameter values to be used during the invocation of the method.
+ */
+export interface TaskIdParams2 {
+  /**
+   * Task id.
+   */
+  id: string;
+  metadata?: {
+    [k: string]: unknown;
+  };
+}
+/**
+ * API Key security scheme.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "APIKeySecurityScheme".
+ */
+export interface APIKeySecurityScheme {
+  /**
+   * Description of this security scheme.
+   */
+  description?: string;
+  /**
+   * The location of the API key. Valid values are "query", "header", or "cookie".
+   */
+  in: "cookie" | "header" | "query";
+  /**
+   * The name of the header, query or cookie parameter to be used.
+   */
+  name: string;
+  type: "apiKey";
+}
+/**
+ * Defines optional capabilities supported by an agent.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "AgentCapabilities".
+ */
+export interface AgentCapabilities {
+  /**
+   * extensions supported by this agent.
+   */
+  extensions?: AgentExtension[];
+  /**
+   * true if the agent can notify updates to client.
+   */
+  pushNotifications?: boolean;
+  /**
+   * true if the agent exposes status change history for tasks.
+   */
+  stateTransitionHistory?: boolean;
+  /**
+   * true if the agent supports SSE.
+   */
+  streaming?: boolean;
+}
+/**
+ * A declaration of an extension supported by an Agent.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "AgentExtension".
+ */
+export interface AgentExtension {
+  /**
+   * A description of how this agent uses this extension.
+   */
+  description?: string;
+  /**
+   * Optional configuration for the extension.
+   */
+  params?: {
+    [k: string]: unknown;
+  };
+  /**
+   * Whether the client must follow specific requirements of the extension.
+   */
+  required?: boolean;
+  /**
+   * The URI of the extension.
+   */
+  uri: string;
+}
+/**
+ * An AgentCard conveys key information:
+ * - Overall details (version, name, description, uses)
+ * - Skills: A set of capabilities the agent can perform
+ * - Default modalities/content types supported by the agent.
+ * - Authentication requirements
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "AgentCard".
+ */
+export interface AgentCard {
+  capabilities: AgentCapabilities1;
+  /**
+   * The set of interaction modes that the agent supports across all skills. This can be overridden per-skill.
+   * Supported media types for input.
+   */
+  defaultInputModes: string[];
+  /**
+   * Supported media types for output.
+   */
+  defaultOutputModes: string[];
+  /**
+   * A human-readable description of the agent. Used to assist users and
+   * other agents in understanding what the agent can do.
+   */
+  description: string;
+  /**
+   * A URL to documentation for the agent.
+   */
+  documentationUrl?: string;
+  /**
+   * A URL to an icon for the agent.
+   */
+  iconUrl?: string;
+  /**
+   * Human readable name of the agent.
+   */
+  name: string;
+  provider?: AgentProvider;
+  /**
+   * Security requirements for contacting the agent.
+   */
+  security?: {
+    [k: string]: string[];
+  }[];
+  /**
+   * Security scheme details used for authenticating with this agent.
+   */
+  securitySchemes?: {
+    [k: string]: SecurityScheme;
+  };
+  /**
+   * Skills are a unit of capability that an agent can perform.
+   */
+  skills: AgentSkill[];
+  /**
+   * true if the agent supports providing an extended agent card when the user is authenticated.
+   * Defaults to false if not specified.
+   */
+  supportsAuthenticatedExtendedCard?: boolean;
+  /**
+   * A URL to the address the agent is hosted at.
+   */
+  url: string;
+  /**
+   * The version of the agent - format is up to the provider.
+   */
+  version: string;
+}
+/**
+ * Optional capabilities supported by the agent.
+ */
+export interface AgentCapabilities1 {
+  /**
+   * extensions supported by this agent.
+   */
+  extensions?: AgentExtension[];
+  /**
+   * true if the agent can notify updates to client.
+   */
+  pushNotifications?: boolean;
+  /**
+   * true if the agent exposes status change history for tasks.
+   */
+  stateTransitionHistory?: boolean;
+  /**
+   * true if the agent supports SSE.
+   */
+  streaming?: boolean;
+}
+/**
+ * The service provider of the agent
+ */
+export interface AgentProvider {
+  /**
+   * Agent provider's organization name.
+   */
+  organization: string;
+  /**
+   * Agent provider's URL.
+   */
+  url: string;
+}
+/**
+ * HTTP Authentication security scheme.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "HTTPAuthSecurityScheme".
+ */
+export interface HTTPAuthSecurityScheme {
+  /**
+   * A hint to the client to identify how the bearer token is formatted. Bearer tokens are usually
+   * generated by an authorization server, so this information is primarily for documentation
+   * purposes.
+   */
+  bearerFormat?: string;
+  /**
+   * Description of this security scheme.
+   */
+  description?: string;
+  /**
+   * The name of the HTTP Authentication scheme to be used in the Authorization header as defined
+   * in RFC7235. The values used SHOULD be registered in the IANA Authentication Scheme registry.
+   * The value is case-insensitive, as defined in RFC7235.
+   */
+  scheme: string;
+  type: "http";
+}
+/**
+ * OAuth2.0 security scheme configuration.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "OAuth2SecurityScheme".
+ */
+export interface OAuth2SecurityScheme {
+  /**
+   * Description of this security scheme.
+   */
+  description?: string;
+  flows: OAuthFlows;
+  type: "oauth2";
+}
+/**
+ * An object containing configuration information for the flow types supported.
+ */
+export interface OAuthFlows {
+  authorizationCode?: AuthorizationCodeOAuthFlow;
+  clientCredentials?: ClientCredentialsOAuthFlow;
+  implicit?: ImplicitOAuthFlow;
+  password?: PasswordOAuthFlow;
+}
+/**
+ * Configuration for the OAuth Authorization Code flow. Previously called accessCode in OpenAPI 2.0.
+ */
+export interface AuthorizationCodeOAuthFlow {
+  /**
+   * The authorization URL to be used for this flow. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS
+   */
+  authorizationUrl: string;
+  /**
+   * The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS.
+   */
+  refreshUrl?: string;
+  /**
+   * The available scopes for the OAuth2 security scheme. A map between the scope name and a short
+   * description for it. The map MAY be empty.
+   */
+  scopes: {
+    [k: string]: string;
+  };
+  /**
+   * The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard
+   * requires the use of TLS.
+   */
+  tokenUrl: string;
+}
+/**
+ * Configuration for the OAuth Client Credentials flow. Previously called application in OpenAPI 2.0
+ */
+export interface ClientCredentialsOAuthFlow {
+  /**
+   * The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS.
+   */
+  refreshUrl?: string;
+  /**
+   * The available scopes for the OAuth2 security scheme. A map between the scope name and a short
+   * description for it. The map MAY be empty.
+   */
+  scopes: {
+    [k: string]: string;
+  };
+  /**
+   * The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard
+   * requires the use of TLS.
+   */
+  tokenUrl: string;
+}
+/**
+ * Configuration for the OAuth Implicit flow
+ */
+export interface ImplicitOAuthFlow {
+  /**
+   * The authorization URL to be used for this flow. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS
+   */
+  authorizationUrl: string;
+  /**
+   * The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS.
+   */
+  refreshUrl?: string;
+  /**
+   * The available scopes for the OAuth2 security scheme. A map between the scope name and a short
+   * description for it. The map MAY be empty.
+   */
+  scopes: {
+    [k: string]: string;
+  };
+}
+/**
+ * Configuration for the OAuth Resource Owner Password flow
+ */
+export interface PasswordOAuthFlow {
+  /**
+   * The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS.
+   */
+  refreshUrl?: string;
+  /**
+   * The available scopes for the OAuth2 security scheme. A map between the scope name and a short
+   * description for it. The map MAY be empty.
+   */
+  scopes: {
+    [k: string]: string;
+  };
+  /**
+   * The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard
+   * requires the use of TLS.
+   */
+  tokenUrl: string;
+}
+/**
+ * OpenID Connect security scheme configuration.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "OpenIdConnectSecurityScheme".
+ */
+export interface OpenIdConnectSecurityScheme {
+  /**
+   * Description of this security scheme.
+   */
+  description?: string;
+  /**
+   * Well-known URL to discover the [[OpenID-Connect-Discovery]] provider metadata.
+   */
+  openIdConnectUrl: string;
+  type: "openIdConnect";
+}
+/**
+ * Represents a unit of capability that an agent can perform.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "AgentSkill".
+ */
+export interface AgentSkill {
+  /**
+   * Description of the skill - will be used by the client or a human
+   * as a hint to understand what the skill does.
+   */
+  description: string;
+  /**
+   * The set of example scenarios that the skill can perform.
+   * Will be used by the client as a hint to understand how the skill can be used.
+   */
+  examples?: string[];
+  /**
+   * Unique identifier for the agent's skill.
+   */
+  id: string;
+  /**
+   * The set of interaction modes that the skill supports
+   * (if different than the default).
+   * Supported media types for input.
+   */
+  inputModes?: string[];
+  /**
+   * Human readable name of the skill.
+   */
+  name: string;
+  /**
+   * Supported media types for output.
+   */
+  outputModes?: string[];
+  /**
+   * Set of tagwords describing classes of capabilities for this specific skill.
+   */
+  tags: string[];
+}
+/**
+ * Represents the service provider of an agent.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "AgentProvider".
+ */
+export interface AgentProvider1 {
+  /**
+   * Agent provider's organization name.
+   */
+  organization: string;
+  /**
+   * Agent provider's URL.
+   */
+  url: string;
+}
+/**
+ * Represents an artifact generated for a task.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "Artifact".
+ */
+export interface Artifact {
+  /**
+   * Unique identifier for the artifact.
+   */
+  artifactId: string;
+  /**
+   * Optional description for the artifact.
+   */
+  description?: string;
+  /**
+   * The URIs of extensions that are present or contributed to this Artifact.
+   */
+  extensions?: string[];
+  /**
+   * Extension metadata.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+  /**
+   * Optional name for the artifact.
+   */
+  name?: string;
+  /**
+   * Artifact parts.
+   */
+  parts: Part[];
+}
+/**
+ * Configuration details for a supported OAuth Flow
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "AuthorizationCodeOAuthFlow".
+ */
+export interface AuthorizationCodeOAuthFlow1 {
+  /**
+   * The authorization URL to be used for this flow. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS
+   */
+  authorizationUrl: string;
+  /**
+   * The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS.
+   */
+  refreshUrl?: string;
+  /**
+   * The available scopes for the OAuth2 security scheme. A map between the scope name and a short
+   * description for it. The map MAY be empty.
+   */
+  scopes: {
+    [k: string]: string;
+  };
+  /**
+   * The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard
+   * requires the use of TLS.
+   */
+  tokenUrl: string;
+}
+/**
+ * Represents a JSON-RPC 2.0 Error Response object.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "JSONRPCErrorResponse".
+ */
+export interface JSONRPCErrorResponse {
+  error:
+    | JSONRPCError
+    | JSONParseError
+    | InvalidRequestError
+    | MethodNotFoundError
+    | InvalidParamsError
+    | InternalError
+    | TaskNotFoundError
+    | TaskNotCancelableError
+    | PushNotificationNotSupportedError
+    | UnsupportedOperationError
+    | ContentTypeNotSupportedError
+    | InvalidAgentResponseError;
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id: string | number | null;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+}
+/**
+ * Represents a JSON-RPC 2.0 Error object.
+ * This is typically included in a JSONRPCErrorResponse when an error occurs.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "JSONRPCError".
+ */
+export interface JSONRPCError {
+  /**
+   * A Number that indicates the error type that occurred.
+   */
+  code: number;
+  /**
+   * A Primitive or Structured value that contains additional information about the error.
+   * This may be omitted.
+   */
+  data?: {
+    [k: string]: unknown;
+  };
+  /**
+   * A String providing a short description of the error.
+   */
+  message: string;
+}
+/**
+ * JSON-RPC success response model for the 'tasks/cancel' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "CancelTaskSuccessResponse".
+ */
+export interface CancelTaskSuccessResponse {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id: string | number | null;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+  result: Task;
+}
+/**
+ * The result object on success.
+ */
+export interface Task {
+  /**
+   * Collection of artifacts created by the agent.
+   */
+  artifacts?: Artifact[];
+  /**
+   * Server-generated id for contextual alignment across interactions
+   */
+  contextId: string;
+  history?: Message1[];
+  /**
+   * Unique identifier for the task
+   */
+  id: string;
+  /**
+   * Event type
+   */
+  kind: "task";
+  /**
+   * Extension metadata.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+  status: TaskStatus;
+}
+/**
+ * Represents a single message exchanged between user and agent.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "Message".
+ */
+export interface Message1 {
+  /**
+   * The context the message is associated with
+   */
+  contextId?: string;
+  /**
+   * The URIs of extensions that are present or contributed to this Message.
+   */
+  extensions?: string[];
+  /**
+   * Event type
+   */
+  kind: "message";
+  /**
+   * Identifier created by the message creator
+   */
+  messageId: string;
+  /**
+   * Extension metadata.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+  /**
+   * Message content
+   */
+  parts: Part[];
+  /**
+   * List of tasks referenced as context by this message.
+   */
+  referenceTaskIds?: string[];
+  /**
+   * Message sender's role
+   */
+  role: "agent" | "user";
+  /**
+   * Identifier of task the message is related to
+   */
+  taskId?: string;
+}
+/**
+ * Current status of the task
+ */
+export interface TaskStatus {
+  message?: Message2;
+  state: TaskState;
+  /**
+   * ISO 8601 datetime string when the status was recorded.
+   */
+  timestamp?: string;
+}
+/**
+ * Represents a single message exchanged between user and agent.
+ */
+export interface Message2 {
+  /**
+   * The context the message is associated with
+   */
+  contextId?: string;
+  /**
+   * The URIs of extensions that are present or contributed to this Message.
+   */
+  extensions?: string[];
+  /**
+   * Event type
+   */
+  kind: "message";
+  /**
+   * Identifier created by the message creator
+   */
+  messageId: string;
+  /**
+   * Extension metadata.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+  /**
+   * Message content
+   */
+  parts: Part[];
+  /**
+   * List of tasks referenced as context by this message.
+   */
+  referenceTaskIds?: string[];
+  /**
+   * Message sender's role
+   */
+  role: "agent" | "user";
+  /**
+   * Identifier of task the message is related to
+   */
+  taskId?: string;
+}
+/**
+ * Configuration details for a supported OAuth Flow
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "ClientCredentialsOAuthFlow".
+ */
+export interface ClientCredentialsOAuthFlow1 {
+  /**
+   * The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS.
+   */
+  refreshUrl?: string;
+  /**
+   * The available scopes for the OAuth2 security scheme. A map between the scope name and a short
+   * description for it. The map MAY be empty.
+   */
+  scopes: {
+    [k: string]: string;
+  };
+  /**
+   * The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard
+   * requires the use of TLS.
+   */
+  tokenUrl: string;
+}
+/**
+ * Represents the base entity for FileParts
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "FileBase".
+ */
+export interface FileBase {
+  /**
+   * Optional mimeType for the file
+   */
+  mimeType?: string;
+  /**
+   * Optional name for the file
+   */
+  name?: string;
+}
+/**
+ * JSON-RPC success response model for the 'tasks/pushNotificationConfig/get' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "GetTaskPushNotificationConfigSuccessResponse".
+ */
+export interface GetTaskPushNotificationConfigSuccessResponse {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id: string | number | null;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+  result: TaskPushNotificationConfig1;
+}
+/**
+ * The result object on success.
+ */
+export interface TaskPushNotificationConfig1 {
+  pushNotificationConfig: PushNotificationConfig1;
+  /**
+   * Task id.
+   */
+  taskId: string;
+}
+/**
+ * JSON-RPC success response for the 'tasks/get' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "GetTaskSuccessResponse".
+ */
+export interface GetTaskSuccessResponse {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id: string | number | null;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+  result: Task1;
+}
+/**
+ * The result object on success.
+ */
+export interface Task1 {
+  /**
+   * Collection of artifacts created by the agent.
+   */
+  artifacts?: Artifact[];
+  /**
+   * Server-generated id for contextual alignment across interactions
+   */
+  contextId: string;
+  history?: Message1[];
+  /**
+   * Unique identifier for the task
+   */
+  id: string;
+  /**
+   * Event type
+   */
+  kind: "task";
+  /**
+   * Extension metadata.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+  status: TaskStatus;
+}
+/**
+ * Configuration details for a supported OAuth Flow
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "ImplicitOAuthFlow".
+ */
+export interface ImplicitOAuthFlow1 {
+  /**
+   * The authorization URL to be used for this flow. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS
+   */
+  authorizationUrl: string;
+  /**
+   * The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS.
+   */
+  refreshUrl?: string;
+  /**
+   * The available scopes for the OAuth2 security scheme. A map between the scope name and a short
+   * description for it. The map MAY be empty.
+   */
+  scopes: {
+    [k: string]: string;
+  };
+}
+/**
+ * Base interface for any JSON-RPC 2.0 request or response.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "JSONRPCMessage".
+ */
+export interface JSONRPCMessage {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id?: string | number | null;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+}
+/**
+ * Represents a JSON-RPC 2.0 Request object.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "JSONRPCRequest".
+ */
+export interface JSONRPCRequest {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id?: string | number | null;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+  /**
+   * A String containing the name of the method to be invoked.
+   */
+  method: string;
+  /**
+   * A Structured value that holds the parameter values to be used during the invocation of the method.
+   */
+  params?: {
+    [k: string]: unknown;
+  };
+}
+/**
+ * JSON-RPC success response model for the 'message/send' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "SendMessageSuccessResponse".
+ */
+export interface SendMessageSuccessResponse {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id: string | number | null;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+  /**
+   * The result object on success
+   */
+  result: Task2 | Message1;
+}
+/**
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "Task".
+ */
+export interface Task2 {
+  /**
+   * Collection of artifacts created by the agent.
+   */
+  artifacts?: Artifact[];
+  /**
+   * Server-generated id for contextual alignment across interactions
+   */
+  contextId: string;
+  history?: Message1[];
+  /**
+   * Unique identifier for the task
+   */
+  id: string;
+  /**
+   * Event type
+   */
+  kind: "task";
+  /**
+   * Extension metadata.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+  status: TaskStatus;
+}
+/**
+ * JSON-RPC success response model for the 'message/stream' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "SendStreamingMessageSuccessResponse".
+ */
+export interface SendStreamingMessageSuccessResponse {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id: string | number | null;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+  /**
+   * The result object on success
+   */
+  result: Task2 | Message1 | TaskStatusUpdateEvent | TaskArtifactUpdateEvent;
+}
+/**
+ * Sent by server during sendStream or subscribe requests
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "TaskStatusUpdateEvent".
+ */
+export interface TaskStatusUpdateEvent {
+  /**
+   * The context the task is associated with
+   */
+  contextId: string;
+  /**
+   * Indicates the end of the event stream
+   */
+  final: boolean;
+  /**
+   * Event type
+   */
+  kind: "status-update";
+  /**
+   * Extension metadata.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+  status: TaskStatus1;
+  /**
+   * Task id
+   */
+  taskId: string;
+}
+/**
+ * Current status of the task
+ */
+export interface TaskStatus1 {
+  message?: Message2;
+  state: TaskState;
+  /**
+   * ISO 8601 datetime string when the status was recorded.
+   */
+  timestamp?: string;
+}
+/**
+ * Sent by server during sendStream or subscribe requests
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "TaskArtifactUpdateEvent".
+ */
+export interface TaskArtifactUpdateEvent {
+  /**
+   * Indicates if this artifact appends to a previous one
+   */
+  append?: boolean;
+  artifact: Artifact1;
+  /**
+   * The context the task is associated with
+   */
+  contextId: string;
+  /**
+   * Event type
+   */
+  kind: "artifact-update";
+  /**
+   * Indicates if this is the last chunk of the artifact
+   */
+  lastChunk?: boolean;
+  /**
+   * Extension metadata.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+  /**
+   * Task id
+   */
+  taskId: string;
+}
+/**
+ * Represents an artifact generated for a task.
+ */
+export interface Artifact1 {
+  /**
+   * Unique identifier for the artifact.
+   */
+  artifactId: string;
+  /**
+   * Optional description for the artifact.
+   */
+  description?: string;
+  /**
+   * The URIs of extensions that are present or contributed to this Artifact.
+   */
+  extensions?: string[];
+  /**
+   * Extension metadata.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+  /**
+   * Optional name for the artifact.
+   */
+  name?: string;
+  /**
+   * Artifact parts.
+   */
+  parts: Part[];
+}
+/**
+ * JSON-RPC success response model for the 'tasks/pushNotificationConfig/set' method.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "SetTaskPushNotificationConfigSuccessResponse".
+ */
+export interface SetTaskPushNotificationConfigSuccessResponse {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id: string | number | null;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+  result: TaskPushNotificationConfig2;
+}
+/**
+ * The result object on success.
+ */
+export interface TaskPushNotificationConfig2 {
+  pushNotificationConfig: PushNotificationConfig1;
+  /**
+   * Task id.
+   */
+  taskId: string;
+}
+/**
+ * Represents a JSON-RPC 2.0 Success Response object.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "JSONRPCSuccessResponse".
+ */
+export interface JSONRPCSuccessResponse {
+  /**
+   * An identifier established by the Client that MUST contain a String, Number.
+   * Numbers SHOULD NOT contain fractional parts.
+   */
+  id: string | number | null;
+  /**
+   * Specifies the version of the JSON-RPC protocol. MUST be exactly "2.0".
+   */
+  jsonrpc: "2.0";
+  /**
+   * The result object on success
+   */
+  result: {
+    [k: string]: unknown;
+  };
+}
+/**
+ * Configuration for the send message request.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "MessageSendConfiguration".
+ */
+export interface MessageSendConfiguration1 {
+  /**
+   * Accepted output modalities by the client.
+   */
+  acceptedOutputModes: string[];
+  /**
+   * If the server should treat the client as a blocking request.
+   */
+  blocking?: boolean;
+  /**
+   * Number of recent messages to be retrieved.
+   */
+  historyLength?: number;
+  pushNotificationConfig?: PushNotificationConfig;
+}
+/**
+ * Sent by the client to the agent as a request. May create, continue or restart a task.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "MessageSendParams".
+ */
+export interface MessageSendParams2 {
+  configuration?: MessageSendConfiguration;
+  message: Message;
+  /**
+   * Extension metadata.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+}
+/**
+ * Allows configuration of the supported OAuth Flows
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "OAuthFlows".
+ */
+export interface OAuthFlows1 {
+  authorizationCode?: AuthorizationCodeOAuthFlow;
+  clientCredentials?: ClientCredentialsOAuthFlow;
+  implicit?: ImplicitOAuthFlow;
+  password?: PasswordOAuthFlow;
+}
+/**
+ * Base properties common to all message parts.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "PartBase".
+ */
+export interface PartBase {
+  /**
+   * Optional metadata associated with the part.
+   */
+  metadata?: {
+    [k: string]: unknown;
+  };
+}
+/**
+ * Configuration details for a supported OAuth Flow
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "PasswordOAuthFlow".
+ */
+export interface PasswordOAuthFlow1 {
+  /**
+   * The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2
+   * standard requires the use of TLS.
+   */
+  refreshUrl?: string;
+  /**
+   * The available scopes for the OAuth2 security scheme. A map between the scope name and a short
+   * description for it. The map MAY be empty.
+   */
+  scopes: {
+    [k: string]: string;
+  };
+  /**
+   * The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard
+   * requires the use of TLS.
+   */
+  tokenUrl: string;
+}
+/**
+ * Configuration for setting up push notifications for task updates.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "PushNotificationConfig".
+ */
+export interface PushNotificationConfig2 {
+  authentication?: PushNotificationAuthenticationInfo;
+  /**
+   * Push Notification ID - created by server to support multiple callbacks
+   */
+  id?: string;
+  /**
+   * Token unique to this task/session.
+   */
+  token?: string;
+  /**
+   * URL for sending the push notifications.
+   */
+  url: string;
+}
+/**
+ * Base properties shared by all security schemes.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "SecuritySchemeBase".
+ */
+export interface SecuritySchemeBase {
+  /**
+   * Description of this security scheme.
+   */
+  description?: string;
+}
+/**
+ * Parameters containing only a task ID, used for simple task operations.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "TaskIdParams".
+ */
+export interface TaskIdParams3 {
+  /**
+   * Task id.
+   */
+  id: string;
+  metadata?: {
+    [k: string]: unknown;
+  };
+}
+/**
+ * Parameters for setting or getting push notification configuration for a task
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "TaskPushNotificationConfig".
+ */
+export interface TaskPushNotificationConfig3 {
+  pushNotificationConfig: PushNotificationConfig1;
+  /**
+   * Task id.
+   */
+  taskId: string;
+}
+/**
+ * Parameters for querying a task, including optional history length.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "TaskQueryParams".
+ */
+export interface TaskQueryParams1 {
+  /**
+   * Number of recent messages to be retrieved.
+   */
+  historyLength?: number;
+  /**
+   * Task id.
+   */
+  id: string;
+  metadata?: {
+    [k: string]: unknown;
+  };
+}
+/**
+ * TaskState and accompanying message.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "TaskStatus".
+ */
+export interface TaskStatus2 {
+  message?: Message2;
+  state: TaskState;
+  /**
+   * ISO 8601 datetime string when the status was recorded.
+   */
+  timestamp?: string;
+}
+
+/**
+ * Represents the possible states of a Task.
+ *
+ * This interface was referenced by `MySchema`'s JSON-Schema
+ * via the `definition` "TaskState".
+ */
+export enum TaskState {
+  Submitted = "submitted",
+  Working = "working",
+  InputRequired = "input-required",
+  Completed = "completed",
+  Canceled = "canceled",
+  Failed = "failed",
+  Rejected = "rejected",
+  AuthRequired = "auth-required",
+  Unknown = "unknown",
+}
diff --git a/src/types/schemas/a2a/rpc.ts b/src/types/schemas/a2a/rpc.ts
new file mode 100644
index 0000000..bffc841
--- /dev/null
+++ b/src/types/schemas/a2a/rpc.ts
@@ -0,0 +1,119 @@
+/**
+ * @description Base interface for all JSON-RPC messages (Requests and Responses).
+ * @required jsonrpc
+ * @optional id
+ */
+export interface JSONRPCMessage {
+  /**
+   * @required Specifies the JSON-RPC version. Must be "2.0".
+   * @default "2.0"
+   * @const "2.0"
+   */
+  readonly jsonrpc: "2.0";
+
+  /**
+   * @optional An identifier established by the Client that MUST contain a String, Number.
+   * @description Can be a string, number. Responses must have the same ID as the request they relate to.
+   * Notifications (requests without an expected response) should omit the ID.
+   */
+  id?: number | string;
+}
+
+/**
+ * @description Represents a JSON-RPC request object base structure.
+ * @required method
+ * @optional params
+ */
+export interface JSONRPCRequest<Method = string, Params = unknown>
+  extends JSONRPCMessage {
+  /**
+   * @required Request identifier.
+   */
+  id: number | string;
+
+  /**
+   * @required The name of the method to be invoked.
+   */
+  method: Method;
+
+  /**
+   * @optional Parameters for the method. Can be a structured object, an array, or omitted.
+   * @description A Structured value that holds the parameter values to be used during the invocation of the method.
+   */
+  params?: Params;
+}
+
+/**
+ * @description Represents a JSON-RPC request object with parameters.
+ * @required params
+ */
+export interface JSONRPCRequestWithParams<Method = string, Params = unknown>
+  extends JSONRPCRequest<Method, Params> {
+  params: Params;
+}
+
+/**
+ * @description Represents a JSON-RPC error object.
+ * @required code
+ * @required message
+ * @optional data
+ */
+export interface JSONRPCError<Code = number, Data = unknown> {
+  /**
+   * @required A number indicating the error type that occurred.
+   */
+  code: Code;
+
+  /**
+   * @required A string providing a short description of the error.
+   */
+  message: string;
+
+  /**
+   * @optional A Primitive or Structured value that contains additional information about the error.
+   */
+  data?: Data;
+}
+
+/**
+ * @description Represents a JSON-RPC 2.0 Success Response object.
+ * @required result
+ * @never error
+ */
+export interface JSONRPCSuccessResponse<R = unknown> extends JSONRPCMessage {
+  /**
+   * @required The result object on success
+   */
+  result: R;
+
+  /**
+   * @optional The error object on failure
+   * @description Optional 'never' helps enforce exclusivity
+   */
+  error?: never;
+}
+
+/**
+ * @description Represents a JSON-RPC 2.0 Error Response object.
+ * @never result
+ * @required error
+ */
+export interface JSONRPCErrorResponse<E = unknown> extends JSONRPCMessage {
+  /**
+   * @optional The result object on success
+   * @description Optional 'never' helps enforce exclusivity
+   */
+  result?: never;
+  /**
+   * @required The result object on failure
+   */
+  error: E;
+}
+
+/**
+ * @description Represents a JSON-RPC response object.
+ * @oneOf JSONRPCSuccessResponse | JSONRPCErrorResponse
+ */
+export type JSONRPCResponse<R = unknown, E = unknown> =
+  | JSONRPCSuccessResponse<R>
+  | JSONRPCErrorResponse<E>;
diff --git a/src/types/schemas/a2a/task.ts b/src/types/schemas/a2a/task.ts
new file mode 100644
index 0000000..afbbfe8
--- /dev/null
+++ b/src/types/schemas/a2a/task.ts
@@ -0,0 +1,303 @@
+import { Message, Artifact } from "./parameters.js";
+import {
+  JSONRPCErrorResponse,
+  JSONRPCRequestWithParams,
+  JSONRPCSuccessResponse,
+} from "./rpc.js";
+
+/**
+ * @description Represents the state of a task within the A2A protocol.
+ */
+export enum TaskState {
+  Submitted = "submitted",
+  Working = "working",
+  InputRequired = "input-required",
+  Completed = "completed",
+  Canceled = "canceled",
+  Failed = "failed",
+  Rejected = "rejected",
+  AuthRequired = "auth-required",
+  Unknown = "unknown",
+}
+
+/**
+ * Basic parameters used for task ID operations.
+ * Used by: `tasks/cancel`, `tasks/pushNotificationConfig/get`.
+ */
+export interface TaskIdParams {
+  /**
+   * The unique identifier of the task.
+   */
+  id: string;
+
+  /**
+   * Optional metadata to include with the operation.
+   */
+  metadata?: Record<string, unknown>;
+}
+
+/**
+ * Parameters used for querying task-related information by ID.
+ * Used by: `tasks/get`, `tasks/getHistory`, `tasks/subscribe`, `tasks/resubscribe`.
+ */
+export interface TaskQueryParams extends TaskIdParams {
+  /**
+   * Optional history length to retrieve for the task.
+   */
+  historyLength?: number;
+}
+
+/**
+ * Basic parameters used for task ID operations.
+ * Used by: `tasks/cancel`, `tasks/pushNotificationConfig/get`.
+ * @description Basic parameters used for task ID operations.
+ * @required id
+ * @optional metadata
+ */
+export interface TaskIdParams {
+  /**
+   * @required The unique identifier of the task.
+   */
+  id: string;
+
+  /**
+   * @optional metadata to include with the operation.
+   */
+  metadata?: Record<string, unknown>;
+}
+
+/**
+ * Parameters used for querying task-related information by ID.
+ * @description Parameters used for querying task-related information by ID.
+ * @required id
+ * @optional historyLength
+ */
+export interface TaskQueryParams extends TaskIdParams {
+  /**
+   * @optional Number of recent messages to be retrieved.
+   */
+  historyLength?: number;
+}
+
+/**
+ * Represents the status of a task at a specific point in time.
+ * @description A task status is a snapshot of the task at a specific point in time.
+ * @required state
+ * @optional message
+ * @optional timestamp
+ */
+export interface TaskStatus {
+  /**
+   * @required The current state of the task.
+   */
+  state: TaskState;
+
+  /**
+   * @optional An optional message associated with the current status (e.g., progress update, final response).
+   */
+  message?: Message;
+
+  /**
+   * @optional The timestamp when this status was recorded (ISO 8601 format).
+   * @format date-time
+   */
+  timestamp?: string;
+}
+
+/**
+ * Represents a task being processed by an agent.
+ * @description A task is a unit of work that an agent can perform.
+ * @required id
+ * @optional contextId
+ * @required status
+ * @optional history
+ * @optional artifacts
+ * @optional metadata
+ * @required kind
+ */
+export interface Task {
+  /**
+   * @required Unique identifier for the task.
+   */
+  id: string;
+
+  /**
+   * @optional identifier for the session this task belongs to.
+   */
+  contextId?: string;
+
+  /**
+   * @required The current status of the task.
+   */
+  status: TaskStatus;
+
+  /**
+   * @optional list of historical messages associated with the task.
+   */
+  history?: Message[];
+
+  /**
+   * @optional list of artifacts associated with the task (e.g., outputs, intermediate files).
+   */
+  artifacts?: Artifact[];
+
+  /**
+   * @optional metadata associated with the task.
+   */
+  metadata?: Record<string, unknown>;
+
+  /**
+   * @required Event type
+   */
+  kind: "task";
+}
+
+/**
+ * Represents a status update event for a task, typically used in streaming scenarios.
+ * @description A status update event is a snapshot of the task at a specific point in time.
+ * @required taskId
+ * @required contextId
+ * @required kind
+ * @required status
+ * @optional metadata
+ */
+export interface TaskStatusUpdateEvent {
+  /**
+   * @required The ID of the task being updated.
+   */
+  taskId: string;
+
+  /**
+   * @required The context the task is associated with
+   */
+  contextId: string;
+
+  /**
+   * @required Event type
+   */
+  kind: "status-update";
+
+  /**
+   * @required The current status of the task.
+   */
+  status: TaskStatus;
+
+  /**
+   * @required Flag indicating if this is the final update for the task.
+   */
+  final: boolean;
+
+  /**
+   * @optional metadata associated with this update event.
+   */
+  metadata?: Record<string, unknown>;
+}
+
+/**
+ * Represents an artifact update event for a task, typically used in streaming scenarios.
+ * @description An artifact update event is a snapshot of the task at a specific point in time.
+ * @required taskId
+ * @required contextId
+ * @required kind
+ * @required artifact
+ * @optional append
+ * @optional lastChunk
+ * @optional metadata
+ */
+export interface TaskArtifactUpdateEvent {
+  /**
+   * @required The ID of the task being updated.
+   */
+  taskId: string;
+
+  /**
+   * @required The context the task is associated with
+   */
+  contextId: string;
+
+  /**
+   * @required Event type
+   */
+  kind: "artifact-update";
+
+  /**
+   * @required The new or updated artifact for the task.
+   */
+  artifact: Artifact;
+
+  /**
+   * @optional Indicates if this artifact appends to a previous one
+   */
+  append?: boolean;
+
+  /**
+   * @optional Indicates if this is the last chunk of the artifact
+   */
+  lastChunk?: boolean;
+
+  /**
+   * @optional metadata associated with this update event.
+   */
+  metadata?: Record<string, unknown>;
+}
+
+/**
+ * @description Request to retrieve the current state of a task.
+ * @required id
+ * @required method
+ * @required params
+ */
+export type GetTaskRequest = JSONRPCRequestWithParams<
+  "tasks/get",
+  TaskQueryParams
+>;
+
+/**
+ * @description JSON-RPC success response model for the 'tasks/get' method.
+ * @required result
+ * @never error
+ */
+export type GetTaskSuccessResponse = JSONRPCSuccessResponse<Task>;
+
+/**
+ * @description Response to a `tasks/get` request. Contains the Task object or an error.
+ * @oneOf GetTaskSuccessResponse | JSONRPCErrorResponse
+ */
+export type GetTaskResponse = GetTaskSuccessResponse | JSONRPCErrorResponse;
+
+/**
+ * @description Request to resubscribe to updates for a task after a connection interruption.
+ * @required id
+ * @required method
+ * @required params
+ */
+export type TaskResubscriptionRequest = JSONRPCRequestWithParams<
+  "tasks/resubscribe",
+  TaskQueryParams
+>;
+
+/**
+ * @description Request to cancel a currently running task.
+ * @required id
+ * @required method
+ * @required params
+ */
+export type CancelTaskRequest = JSONRPCRequestWithParams<
+  "tasks/cancel",
+  TaskIdParams
+>;
+
+/**
+ * @description JSON-RPC success response model for the 'tasks/cancel' method.
+ * @required result
+ * @never error
+ */
+export type CancelTaskSuccessResponse = JSONRPCSuccessResponse<Task>;
+
+/**
+ * @description Response to a `tasks/cancel` request. Contains the updated Task object (usually with 'canceled' state) or an error.
+ * @oneOf CancelTaskSuccessResponse | JSONRPCErrorResponse
+ */
+export type CancelTaskResponse =
+  | CancelTaskSuccessResponse
+  | JSONRPCErrorResponse;
diff --git a/src/types/schemas/index.ts b/src/types/schemas/index.ts
new file mode 100644
index 0000000..a4d779e
--- /dev/null
+++ b/src/types/schemas/index.ts
@@ -0,0 +1 @@
+export * from "./a2a/index.js";
diff --git a/src/types/services/a2a/repository.ts b/src/types/services/a2a/repository.ts
new file mode 100644
index 0000000..d7aafea
--- /dev/null
+++ b/src/types/services/a2a/repository.ts
@@ -0,0 +1,90 @@
+import { TaskAndHistory, TaskStore } from "../../../server/interfaces/store.js";
+import { AgentCard } from "../../schemas/index.js";
+import { TaskContext } from "../../index.js";
+import express, { Response } from "express";
+
+/**
+ * @description The A2ARepository interface.
+ */
+export interface A2ARepositoryInterface {
+  /**
+   * @description Gets the agent card.
+   * @returns {AgentCard} The agent card.
+   */
+  getCard: () => AgentCard;
+  /**
+   * @description Gets the active cancellations.
+   * @returns {Set<string>} The active cancellations.
+   */
+  getActiveCancellations: () => Set<string>;
+  /**
+   * @description Gets the task store.
+   * @returns {TaskStore} The task store.
+   */
+  getTaskStore: () => TaskStore;
+  /**
+   * @description Closes the streams for a task.
+   * @param {string} taskId The ID of the task.
+   */
+  closeStreamsForTask: (taskId: string) => void;
+  /**
+   * @description Creates a task context.
+   * @param {Task} task The task.
+   * @param {Message} userMessage The user message.
+   * @param {Message[]} history The history.
+   * @param {MessageSendConfiguration} configuration The configuration.
+   * @returns {TaskContext} The task context.
+   */
+  onCancel: (
+    context: TaskContext,
+    data: TaskAndHistory,
+    res: Response
+  ) => Promise<void>;
+  /**
+   * @description Ends a task.
+   * @param {string} taskId The ID of the task.
+   * @param {Response} res The response.
+   */
+  onEnd: (taskId: string, res: Response) => Promise<void>;
+}
+
+/**
+ * @description The A2ARepository parameters.
+ */
+export interface A2ARepositoryParams {
+  /**
+   * @description The task store.
+   * @type {TaskStore}
+   */
+  taskStore?: TaskStore;
+  /**
+   * @description The base path.
+   * @type {string}
+   */
+  basePath?: string;
+  /**
+   * @description The fallback path.
+   * @type {string}
+   */
+  fallbackPath?: string;
+  /**
+   * @description The port.
+   * @type {number}
+   */
+  port?: number;
+  /**
+   * @description The app.
+   * @type {express.Express}
+   */
+  app?: express.Express;
+  /**
+   * @description The register.
+   * @type {boolean}
+   */
+  register?: boolean;
+  /**
+   * @description The card.
+   * @type {AgentCard}
+   */
+  card: AgentCard;
+}
diff --git a/src/types/services/a2a/service.ts b/src/types/services/a2a/service.ts
new file mode 100644
index 0000000..0594570
--- /dev/null
+++ b/src/types/services/a2a/service.ts
@@ -0,0 +1,31 @@
+import {
+  TaskResubscriptionRequest,
+  SendStreamingMessageRequest,
+} from "../../schemas/index.js";
+import { A2AExecutionContext } from "../context.js";
+import { Service } from "../service.js";
+import { Response } from "express";
+
+/**
+ * @description The A2AService interface.
+ */
+export interface A2AServiceInterface extends Service<A2AExecutionContext> {
+  /**
+   * @description Handles the message/stream method.
+   * @param req The SendStreamingMessageRequest object
+   * @param res The Express Response object
+   */
+  handleTaskSendSubscribe(
+    req: SendStreamingMessageRequest,
+    res: Response
+  ): Promise<void>;
+  /**
+   * @description Handles the tasks/resubscribe method.
+   * @param req The TaskResubscriptionRequest object
+   * @param res The Express Response object
+   */
+  handleTaskResubscribe(
+    req: TaskResubscriptionRequest,
+    res: Response
+  ): Promise<void>;
+}
diff --git a/src/types/services/context.ts b/src/types/services/context.ts
new file mode 100644
index 0000000..728eb9e
--- /dev/null
+++ b/src/types/services/context.ts
@@ -0,0 +1,212 @@
+import type { Task, A2AContext, AgentSkill } from "../extended-schema.js";
+import { Protocol } from "./protocol.js";
+
+/**
+ * @description The base context.
+ */
+export interface BaseContext {
+  /**
+   * @description The id.
+   * @type {string}
+   */
+  id: string;
+  /**
+   * @description The protocol.
+   * @type {Protocol}
+   */
+  protocol: Protocol;
+}
+
+/**
+ * @description The MCP context.
+ */
+export interface MCPContext {
+  /**
+   * @description The message.
+   * @type {string}
+   */
+  message: string;
+}
+
+/**
+ * @description The context params.
+ * @type {A2AContext["params"] | MCPContext}
+ */
+export type ContextParams = A2AContext["params"] | MCPContext;
+
+/**
+ * @description The base execution context.
+ */
+export interface BaseExecutionContext<T extends ContextParams = ContextParams>
+  extends BaseContext {
+  /**
+   * @description The method.
+   * @type {string}
+   */
+  method: string;
+  /**
+   * @description The params.
+   * @type {T}
+   */
+  params: T;
+}
+
+/**
+ * Represents a request specific to the A2A (Agent-to-Agent) protocol.
+ * The `protocol` field is narrowed to `Protocol.A2A`.
+ */
+export interface A2AExecutionContext<
+  RequestType extends A2AContext = A2AContext,
+> extends BaseExecutionContext<RequestType["params"]> {
+  protocol: Protocol.A2A;
+  /**
+   * @description The task.
+   * @type {Task}
+   */
+  task: Task;
+  /**
+   * @description The request.
+   * @type {any}
+   */
+  request: any;
+  /**
+   * @description The response.
+   * @type {any}
+   */
+  response: any;
+}
+
+/**
+ * @description Represents a request specific to the MCP (Model Context Protocol) protocol.
+ * The `protocol` field is narrowed to `Protocol.MCP`.
+ */
+export interface MCPExecutionContext extends BaseExecutionContext<MCPContext> {
+  protocol: Protocol.MCP;
+  /**
+   * @description The request.
+   * @type {any}
+   */
+  request: any;
+  /**
+   * @description The response.
+   * @type {any}
+   */
+  response: any;
+  /**
+   * @description The transport.
+   * @type {any}
+   */
+  transport: any;
+  /**
+   * @description The skills.
+   * @type {AgentSkill[]}
+   */
+  skills?: AgentSkill[];
+}
+
+/**
+ * @description Represents a request specific to the NLWeb protocol.
+ * The `protocol` field is narrowed to `Protocol.NLWEB`.
+ */
+export interface NLWebExecutionContext
+  extends Omit<MCPExecutionContext, "protocol"> {
+  protocol: Protocol.NLWEB;
+}
+
+/**
+ * @description Represents a request specific to the ACP (Agent Communication Protocol).
+ * The `protocol` field is narrowed to `Protocol.ACP`.
+ */
+export interface ACPExecutionContext extends BaseExecutionContext {
+  protocol: Protocol.ACP;
+}
+
+/**
+ * @description Represents a request specific to the CHAT protocol.
+ * The `protocol` field is narrowed to `Protocol.CHAT`.
+ */
+export interface ChatExecutionContext extends BaseExecutionContext {
+  protocol: Protocol.CHAT;
+}
+
+/**
+ * @description A discriminated union of all protocol-specific request types.
+ * This allows functions to accept any request and use the `protocol`
+ * field to determine the specific type of request, enabling type-safe
+ * handling based on the protocol.
+ */
+export type SupportedContext =
+  | A2AExecutionContext
+  | MCPExecutionContext
+  | ACPExecutionContext
+  | ChatExecutionContext;
+
+/**
+ * @description The execution context.
+ */
+export interface ExecutionContext<
+  ContextType extends BaseExecutionContext = SupportedContext,
+> {
+  /**
+   * @description The id.
+   * @type {string}
+   */
+  id: string;
+  /**
+   * @description The protocol.
+   */
+  protocol: Protocol;
+  /**
+   * @description The get request params.
+   * @type {() => ContextType["params"] | undefined}
+   */
+  getRequestParams: () => ContextType["params"] | undefined;
+  /**
+   * @description The is cancelled.
+   * @type {() => boolean}
+   */
+  isCancelled: () => boolean;
+  /**
+   * @description The request context.
+   * @type {ContextType}
+   */
+  requestContext?: ContextType;
+}
+
+/**
+ * @description The agent engine.
+ * @type {AgentEngine}
+ */
+export type AgentEngine<Context extends ExecutionContext = ExecutionContext> = (
+  context: Context
+) => AsyncGenerator<any, void, undefined>;
+
+/**
+ * @description The execution context config.
+ * @type {const}
+ */
+export const executionContextConfig = {
+  id: "contextId",
+  message: "userMessage",
+} as const;
+
+//todo move to utils
+export function getParams(context: ExecutionContext) {
+  console.log("getParams", context);
+  switch (context.protocol) {
+    case Protocol.A2A:
+      const a2aRequestParams = context.getRequestParams();
+      if (!a2aRequestParams) {
+        throw new Error("No request params provided");
+      }
+      return a2aRequestParams;
+    case Protocol.MCP:
+      const mcpRequestParams = context.getRequestParams();
+      if (!mcpRequestParams) {
+        throw new Error("No request params provided");
+      }
+      return mcpRequestParams;
+    default:
+      throw new Error("Invalid protocol");
+  }
+}
diff --git a/src/types/services/dispatcher.ts b/src/types/services/dispatcher.ts
new file mode 100644
index 0000000..60a3e16
--- /dev/null
+++ b/src/types/services/dispatcher.ts
@@ -0,0 +1,59 @@
+import {
+  AgentEngine,
+  BaseExecutionContext,
+  ExecutionContext,
+} from "./context.js";
+import { Protocol } from "./protocol.js";
+import { Service } from "./service.js";
+import { v4 as uuidv4 } from "uuid";
+
+export interface DispatchOptions {
+  services: Partial<Record<Protocol, Service>>; //string should be by protocol
+  engine: AgentEngine;
+}
+
+export interface Dispatcher {
+  addService(service: Service): void;
+  onRequest<Req extends BaseExecutionContext>(req: Req): Promise<void>;
+}
+
+export class ServiceDispatcher implements Dispatcher {
+  protected services: Partial<Record<Protocol, Service>>;
+  protected engine: AgentEngine;
+
+  constructor(options: DispatchOptions) {
+    this.engine = options.engine;
+    this.services = options.services;
+  }
+
+  static createExecutionContext<Req extends BaseExecutionContext>(
+    req: Req
+  ): ExecutionContext<Req> {
+    return {
+      id: req.id ?? uuidv4(),
+      protocol: req.protocol,
+      getRequestParams: () => req.params,
+      isCancelled: () => false,
+      requestContext: req,
+    };
+  }
+
+  async onRequest<Req extends BaseExecutionContext>(req: Req): Promise<void> {
+    const service = this.services[req.protocol];
+    if (!service) {
+      throw new Error(`Unknown service: ${req.protocol}`);
+    }
+
+    const executionContext: ExecutionContext<Req> =
+      ServiceDispatcher.createExecutionContext(req);
+
+    await service.execute({
+      executionContext,
+      engine: this.engine,
+    });
+  }
+
+  addService(service: Service): void {
+    this.services[service.protocol] = service;
+  }
+}
diff --git a/src/types/services/index.ts b/src/types/services/index.ts
new file mode 100644
index 0000000..f1b8576
--- /dev/null
+++ b/src/types/services/index.ts
@@ -0,0 +1,8 @@
+export * from "./a2a/repository.js";
+export * from "./a2a/service.js";
+export * from "./mcp/service.js";
+export * from "./context.js";
+export * from "./dispatcher.js";
+export * from "./manager.js";
+export * from "./protocol.js";
+export * from "./service.js";
diff --git a/src/types/services/manager.ts b/src/types/services/manager.ts
new file mode 100644
index 0000000..104c5d0
--- /dev/null
+++ b/src/types/services/manager.ts
@@ -0,0 +1,39 @@
+import { BaseExecutionContext } from "./context.js";
+import { TaskStore } from "../../server/interfaces/store.js";
+import { AgentCard } from "../schemas/index.js";
+import { DispatchOptions } from "./dispatcher.js";
+
+/**
+ * @description The service manager params.
+ */
+export interface ManagerOptions extends DispatchOptions {
+  /**
+   * @description The task store.
+   * @type {TaskStore}
+   */
+  taskStore: TaskStore;
+  /**
+   * @description The agent card.
+   * @note will be removed in the future
+   * @type {AgentCard}
+   */
+  card: AgentCard;
+}
+
+/**
+ * @description The service manager interface.
+ */
+export interface ManagerInterface {
+  /**
+   * @description Creates a request context.
+   * @param {T} req The request.
+   * @returns {T} The request context.
+   */
+  createRequestContext<T extends BaseExecutionContext>(req: T): T;
+  /**
+   * @description Gets the agent card.
+   * @param {string} serviceName The service name.
+   * @returns {string} The description.
+   */
+  // getDescription(serviceName?: string): string;
+}
diff --git a/src/types/services/mcp/service.ts b/src/types/services/mcp/service.ts
new file mode 100644
index 0000000..70fa861
--- /dev/null
+++ b/src/types/services/mcp/service.ts
@@ -0,0 +1,60 @@
+import { ToolCallback } from "@modelcontextprotocol/sdk/server/mcp.js";
+import {
+  CallToolResult,
+  ToolAnnotations,
+} from "@modelcontextprotocol/sdk/types.js";
+import z, { ZodRawShape } from "zod";
+import { Service } from "../service.js";
+import { AgentSkill } from "../../schemas/index.js";
+import { MCPExecutionContext } from "../context.js";
+
+/**
+ * @description The MCPRequestParamsSchema.
+ */
+export const MCPRequestParamsSchema = z.object({
+  message: z.string(),
+});
+
+/**
+ * @description The zodCallBack type.
+ */
+type zodCallBack<Args extends ZodRawShape = ZodRawShape> = (
+  ...args: Parameters<ToolCallback<Args>>
+) => Promise<CallToolResult>;
+
+/**
+ * @description The MCPTool interface.
+ */
+export interface MCPTool<Args extends ZodRawShape = ZodRawShape> {
+  /**
+   * @description The name of the tool.
+   * @type {string}
+   */
+  name: string;
+  /**
+   * @description The description of the tool.
+   * @type {string}
+   */
+  description?: string;
+  /**
+   * @description The params schema or annotations of the tool.
+   * @type {Args | ToolAnnotations}
+   */
+  paramsSchemaOrAnnotations: Args | ToolAnnotations;
+  /**
+   * @description The callback of the tool.
+   * @type {zodCallBack<Args>}
+   */
+  cb: zodCallBack<Args>;
+}
+
+/**
+ * @description The MCPServiceInterface interface.
+ */
+export interface MCPServiceInterface extends Service<MCPExecutionContext> {
+  /**
+   * @description Initializes the service.
+   * @param {AgentSkill[]} skills The skills.
+   */
+  initialize(skills: AgentSkill[]): void;
+}
diff --git a/src/types/services/protocol.ts b/src/types/services/protocol.ts
new file mode 100644
index 0000000..2b19532
--- /dev/null
+++ b/src/types/services/protocol.ts
@@ -0,0 +1,29 @@
+/**
+ * @description The protocol enum.
+ */
+export enum Protocol {
+  /**
+   * @description The A2A protocol.
+   */
+  A2A = "a2a",
+  /**
+   * @description The MCP protocol.
+   */
+  MCP = "mcp",
+  /**
+   * @description The ACP protocol.
+   */
+  ACP = "acp",
+  /**
+   * @description The CHAT protocol.
+   */
+  CHAT = "chat",
+  /**
+   * @description The NLWeb protocol.
+   */
+  NLWEB = "nlweb",
+  /**
+   * @description The custom protocol for user-defined services.
+   */
+  CUSTOM = "custom",
+}
diff --git a/src/types/services/service.ts b/src/types/services/service.ts
new file mode 100644
index 0000000..bdd696b
--- /dev/null
+++ b/src/types/services/service.ts
@@ -0,0 +1,57 @@
+import { Protocol } from "./protocol.js";
+import { BaseExecutionContext, ExecutionContext } from "./context.js";
+import { AgentEngine } from "./context.js";
+
+/**
+ * @description The service interface.
+ * @template ContextType The context type.
+ */
+export interface Service<
+  ContextType extends BaseExecutionContext = BaseExecutionContext,
+> {
+  /**
+   * @description The name.
+   * @type {string}
+   */
+  readonly name: string;
+  /**
+   * @description The protocol.
+   * @type {Protocol}
+   */
+  readonly protocol: Protocol;
+
+  /**
+   * @description The execute method.
+   * @param {ExecutionContext<ContextType>} executionContext The execution context.
+   * @param {AgentEngine} engine The engine.
+   * @returns {Promise<void>} The promise.
+   */
+  execute({
+    executionContext,
+    engine,
+  }: {
+    executionContext: ExecutionContext<ContextType>;
+    engine: AgentEngine;
+  }): Promise<void>;
+
+  /**
+   * @description The description.
+   * @type {Promise<string>}
+   */
+  // description: Promise<string>;
+  /**
+   * @description The request.
+   * @type {Promise<string>}
+   */
+  // request: Promise<string>;
+  /**
+   * @description The response.
+   * @type {Promise<string>}
+   */
+  // response: Promise<string>;
+  /**
+   * @description The fault.
+   * @type {Promise<string>}
+   */
+  // fault: Promise<string>;
+}
diff --git a/src/types/transform.ts b/src/types/transform.ts
new file mode 100644
index 0000000..44d75c8
--- /dev/null
+++ b/src/types/transform.ts
@@ -0,0 +1,115 @@
+/**
+ * Type-safe object key transformation utilities using built-in TypeScript utility types
+ */
+
+/**
+ * Forces TypeScript to evaluate and flatten intersection types into a single object type
+ * This makes IDE tooltips and type displays much cleaner
+ */
+type Simplify<T> = { [K in keyof T]: T[K] } & {};
+
+/**
+ * Configuration for renaming keys - maps old key names to new key names
+ * For best results, use `as const` to preserve literal string types
+ */
+export type RenameConfig<T extends object> = {
+  readonly [K in keyof T]?: string;
+};
+
+/**
+ * Transform object type by renaming specified keys using built-in utility types
+ * This combines Pick/Omit patterns with Record to achieve key renaming
+ * Uses Simplify to flatten the final type for cleaner IDE display
+ */
+export type TransformKeys<
+  T extends object,
+  Config extends RenameConfig<T>,
+> = Simplify<
+  // Keep all properties that are NOT being renamed
+  Omit<T, keyof Config> & {
+    // Create new properties with renamed keys
+    [OriginalKey in keyof Config & keyof T as Config[OriginalKey] extends string
+      ? Config[OriginalKey]
+      : OriginalKey]: T[OriginalKey];
+  }
+>;
+
+/**
+ * Runtime function to transform object keys based on configuration
+ * Uses the TransformKeys utility type for return type inference
+ */
+export function transformKeys<T extends object, Config extends RenameConfig<T>>(
+  obj: T,
+  config: Config
+): TransformKeys<T, Config> {
+  const result: any = {};
+
+  // Process each property in the original object
+  for (const key in obj) {
+    if (Object.prototype.hasOwnProperty.call(obj, key)) {
+      const newKeyName = config[key as keyof Config];
+
+      if (typeof newKeyName === "string") {
+        // Rename the key
+        result[newKeyName] = obj[key];
+      } else {
+        // Keep original key
+        result[key] = obj[key];
+      }
+    }
+  }
+
+  return result as TransformKeys<T, Config>;
+}
+
+/**
+ * Helper type to extract the transformed type for a given object and config
+ * Useful for declaring variables with the expected transformed type
+ * Uses Simplify to show clean, flattened types in IDE
+ */
+export type Transformed<
+  T extends object,
+  Config extends RenameConfig<T>,
+> = Simplify<TransformKeys<T, Config>>;
+
+/**
+ * Utility to create a type-safe rename configuration with better intellisense
+ * The returned function preserves literal string types
+ */
+export function createRenameConfig<T extends object>() {
+  return function <Config extends RenameConfig<T>>(config: Config): Config {
+    return config;
+  };
+}
+
+/**
+ * Common transformation patterns using built-in utility types
+ */
+export namespace TransformPatterns {
+  /**
+   * Convert snake_case keys to camelCase
+   * This is a type-level template but would need runtime implementation
+   */
+  export type SnakeToCamel<T extends string> =
+    T extends `${infer First}_${infer Rest}`
+      ? `${First}${Capitalize<SnakeToCamel<Rest>>}`
+      : T;
+
+  /**
+   * Pick specific keys and optionally rename them
+   */
+  export type PickAndRename<
+    T extends object,
+    Keys extends keyof T,
+    Config extends Partial<Record<Keys, string>>,
+  > = Simplify<TransformKeys<Pick<T, Keys>, Config>>;
+
+  /**
+   * Omit specific keys and optionally rename remaining ones
+   */
+  export type OmitAndRename<
+    T extends object,
+    OmitKeys extends keyof T,
+    Config extends RenameConfig<Omit<T, OmitKeys>>,
+  > = Simplify<TransformKeys<Omit<T, OmitKeys>, Config>>;
+}
diff --git a/src/utils/api/register.ts b/src/utils/api/register.ts
index 281662b..344f410 100644
--- a/src/utils/api/register.ts
+++ b/src/utils/api/register.ts
@@ -38,9 +38,7 @@ export function convert(card: AgentCard): IRegistration {
   const capabilities = skillNames.slice(0, 5) as IRegistration["capabilities"]; // Type assertion based on slice limit
 
   // Determine if authentication is required based on the agent card, ensuring type is boolean | undefined
-  const requiresAuth = card.authentication
-    ? card.authentication.schemes.length > 0
-    : undefined;
+  const requiresAuth: boolean = !!card.security?.length;
 
   const registration: IRegistration = {
     schemaVersion: "1.0.0",
diff --git a/src/utils/common/constants.ts b/src/utils/common/constants.ts
index cabf023..1adcb68 100644
--- a/src/utils/common/constants.ts
+++ b/src/utils/common/constants.ts
@@ -1,32 +1,56 @@
-import { TaskState, TaskYieldUpdate } from "../../types/extended-schema.js";
+import {
+  TaskState,
+  TaskStatusUpdateEvent,
+} from "../../types/schemas/a2a/index.js";
 
-export const WORKING_UPDATE: TaskYieldUpdate = {
-  state: "working",
-  message: {
-    role: "agent" as const,
-    parts: [{ type: "text" as const, text: "Processing..." }],
-  },
+export const WORKING_UPDATE = (
+  taskId: string,
+  contextId: string
+): TaskStatusUpdateEvent => {
+  return {
+    taskId: taskId,
+    contextId: contextId,
+    kind: "status-update",
+    status: {
+      state: TaskState.Working,
+    },
+    final: false,
+  };
 };
 
-export const CANCEL_UPDATE: TaskYieldUpdate = {
-  state: "canceled",
-  message: {
-    role: "agent" as const,
-    parts: [
-      {
-        type: "text" as const,
-        text: "Task was canceled during execution.",
-      },
-    ],
-  },
+export const CANCEL_UPDATE = (
+  taskId: string,
+  contextId: string
+): TaskStatusUpdateEvent => {
+  return {
+    taskId: taskId,
+    contextId: contextId,
+    kind: "status-update",
+    status: {
+      state: TaskState.Canceled,
+    },
+    final: true,
+  };
 };
 
-export const SUBMITTED_UPDATE: TaskYieldUpdate = {
-  state: "submitted",
-  message: {
-    role: "agent" as const,
-    parts: [{ type: "text" as const, text: "Task was submitted." }],
-  },
+export const SUBMITTED_UPDATE = (
+  taskId: string,
+  contextId: string
+): TaskStatusUpdateEvent => {
+  return {
+    taskId: taskId,
+    contextId: contextId,
+    kind: "status-update",
+    status: {
+      state: TaskState.Submitted,
+    },
+    final: false,
+  };
 };
 
-export const FINAL_STATES: TaskState[] = ["completed", "failed", "canceled"];
+export const FINAL_STATES: TaskState[] = [
+  TaskState.Completed,
+  TaskState.Failed,
+  TaskState.Canceled,
+  TaskState.Rejected,
+];
diff --git a/src/utils/common/errors.ts b/src/utils/common/errors.ts
index 8ad554c..db1e7e8 100644
--- a/src/utils/common/errors.ts
+++ b/src/utils/common/errors.ts
@@ -1,28 +1,39 @@
 import { NextFunction, Request, Response } from "express";
+import { JSONParseError } from "../../types/extended-schema.js";
+import { logError } from "../../utils/logging/log.js";
 import {
-  A2AErrorType,
-  ErrorCodeInvalidParams,
-  ErrorCodeInvalidRequest,
-  ErrorCodeParseError,
+  A2AError,
   ErrorCodeInternalError,
+  ErrorCodeInvalidRequest,
   ErrorCodeMethodNotFound,
+  ErrorCodeParseError,
+  ErrorCodeInvalidParams,
   ErrorCodeTaskNotFound,
-  ErrorCodeUnsupportedOperation,
   ErrorCodeTaskNotCancelable,
+  ErrorCodeUnsupportedOperation,
   ErrorCodePushNotificationNotSupported,
-  TaskYieldUpdate,
-} from "../../types/extended-schema.js";
-import { logError } from "../../utils/logging/log.js";
-import { JSONRPCError } from "../../types/schema.js";
-
-export class SystemError<ErrorData = unknown, C extends number = number>
-  extends Error
-  implements A2AErrorType
-{
-  code: C;
-  data: ErrorData;
-
-  constructor(message: string, code: C, data: ErrorData) {
+  InvalidParamsError,
+  InvalidRequestError,
+  JSONRPCError,
+  MethodNotFoundError,
+  InternalError,
+  TaskNotFoundError,
+  TaskNotCancelableError,
+  ErrorCodeContentTypeNotSupported,
+  ContentTypeNotSupportedError,
+  InvalidAgentResponseError,
+  ErrorCodeInvalidAgentResponse,
+  TaskState,
+  TaskStatusUpdateEvent,
+} from "../../types/schemas/a2a/index.js";
+
+export class SystemError<
+  T extends JSONRPCError<number, unknown>,
+> extends Error {
+  code: T["code"];
+  data: T["data"];
+
+  constructor(message: string, code: T["code"], data: T["data"]) {
     super(message);
     this.name = "RpcError";
     this.message = message;
@@ -31,76 +42,94 @@ export class SystemError<ErrorData = unknown, C extends number = number>
   }
 }
 // Factory methods for common errors
-export const PARSE_ERROR = <ErrorData = unknown>(data: ErrorData) =>
-  new SystemError<ErrorData, ErrorCodeParseError>(
-    "Invalid JSON payload",
-    ErrorCodeParseError,
-    data
-  );
+export const PARSE_ERROR = <T extends JSONParseError>(data: T["data"]) =>
+  new SystemError<T>("Invalid JSON payload", ErrorCodeParseError, data);
 
-export const METHOD_NOT_FOUND = <ErrorData = unknown>(data: ErrorData) =>
-  new SystemError<ErrorData, ErrorCodeMethodNotFound>(
-    "Method not found",
-    ErrorCodeMethodNotFound,
-    data
-  );
-
-export const INVALID_REQUEST = <ErrorData = unknown>(data: ErrorData) =>
-  new SystemError<ErrorData, ErrorCodeInvalidRequest>(
+export const INVALID_REQUEST = <T extends InvalidRequestError>(
+  data: T["data"]
+) =>
+  new SystemError<T>(
     "Request payload validation error",
     ErrorCodeInvalidRequest,
     data
   );
 
-export const INVALID_PARAMS = <ErrorData = unknown>(data: ErrorData) =>
-  new SystemError<ErrorData, ErrorCodeInvalidParams>(
-    "Invalid parameters",
-    ErrorCodeInvalidParams,
-    data
-  );
+export const METHOD_NOT_FOUND = <T extends MethodNotFoundError>(
+  data: T["data"]
+) => new SystemError<T>("Method not found", ErrorCodeMethodNotFound, data);
 
-export const INTERNAL_ERROR = <ErrorData = unknown>(data: ErrorData) =>
-  new SystemError<ErrorData, ErrorCodeInternalError>(
-    "Internal error",
-    ErrorCodeInternalError,
-    data
-  );
+export const INVALID_PARAMS = <T extends InvalidParamsError>(data: T["data"]) =>
+  new SystemError<T>("Invalid parameters", ErrorCodeInvalidParams, data);
 
-export const TASK_NOT_FOUND = <ErrorData = unknown>(data: ErrorData) =>
-  new SystemError<ErrorData, ErrorCodeTaskNotFound>(
-    "Task not found",
-    ErrorCodeTaskNotFound,
-    data
-  );
+export const INTERNAL_ERROR = <T extends InternalError>(data: T["data"]) =>
+  new SystemError<T>("Internal error", ErrorCodeInternalError, data);
 
-export const TASK_NOT_CANCELABLE = <ErrorData = unknown>(data: ErrorData) =>
-  new SystemError<ErrorData, ErrorCodeTaskNotCancelable>(
+export const TASK_NOT_FOUND = <T extends TaskNotFoundError>(data: T["data"]) =>
+  new SystemError<T>("Task not found", ErrorCodeTaskNotFound, data);
+
+export const TASK_NOT_CANCELABLE = <T extends TaskNotCancelableError>(
+  data: T["data"]
+) =>
+  new SystemError<T>(
     "Task cannot be canceled",
     ErrorCodeTaskNotCancelable,
     data
   );
 
-export const UNSUPPORTED_OPERATION = <ErrorData = unknown>(data: ErrorData) =>
-  new SystemError<ErrorData, ErrorCodeUnsupportedOperation>(
+export const PUSH_NOTIFICATION_NOT_SUPPORTED = <T extends A2AError>(
+  data: T["data"]
+) =>
+  new SystemError<T>(
+    "Push Notification is not supported",
+    ErrorCodePushNotificationNotSupported,
+    data
+  );
+
+export const UNSUPPORTED_OPERATION = <T extends A2AError>(data: T["data"]) =>
+  new SystemError<T>(
     "This operation is not supported",
     ErrorCodeUnsupportedOperation,
     data
   );
 
-export const PUSH_NOTIFICATION_NOT_SUPPORTED = <ErrorData = unknown>(
-  data: ErrorData
+export const CONTENT_TYPE_NOT_SUPPORTED = <
+  T extends ContentTypeNotSupportedError,
+>(
+  data: T["data"]
 ) =>
-  new SystemError<ErrorData, ErrorCodePushNotificationNotSupported>(
-    "Push Notification is not supported",
-    ErrorCodePushNotificationNotSupported,
+  new SystemError<T>(
+    "Content type not supported",
+    ErrorCodeContentTypeNotSupported,
+    data
+  );
+
+export const INVALID_AGENT_RESPONSE = <T extends InvalidAgentResponseError>(
+  data: T["data"]
+) =>
+  new SystemError<T>(
+    "Invalid agent response",
+    ErrorCodeInvalidAgentResponse,
     data
   );
 
-export const FAILED_UPDATE = (message: string): TaskYieldUpdate => ({
-  state: "failed",
-  message: {
-    role: "agent" as const,
-    parts: [{ type: "text" as const, text: message }],
+export const FAILED_UPDATE = (
+  taskId: string,
+  contextId: string,
+  messageId: string = "failed-update",
+  errMessage: string
+): TaskStatusUpdateEvent => ({
+  taskId,
+  contextId,
+  kind: "status-update",
+  final: true,
+  status: {
+    state: TaskState.Failed,
+    message: {
+      messageId,
+      role: "agent",
+      parts: [{ kind: "text", text: errMessage }],
+      kind: "message",
+    },
   },
 });
 
@@ -136,7 +165,7 @@ export function errorHandler(
     logError("A2AServer", "Error extracting request ID", e);
   }
 
-  let jsonRpcError: JSONRPCError<unknown | null, number>;
+  let jsonRpcError: JSONRPCError<number, unknown>;
   if (err instanceof SystemError) {
     jsonRpcError = { code: err.code, message: err.message, data: err.data };
   } else {
diff --git a/src/utils/common/utils.ts b/src/utils/common/utils.ts
index 4d8ab0f..db20bb7 100644
--- a/src/utils/common/utils.ts
+++ b/src/utils/common/utils.ts
@@ -1,11 +1,4 @@
-import {
-  Artifact,
-  ExtendedTaskStatusUpdate,
-  TaskYieldUpdate,
-  TaskSendParams,
-  TaskQueryParams,
-} from "../../types/extended-schema.js";
-
+import { MessageSendParams, Part } from "../../types/extended-schema.js";
 import { INVALID_PARAMS } from "./errors.js";
 
 /**
@@ -25,59 +18,26 @@ export function isObject(value: unknown): value is Record<string, any> {
   return typeof value === "object" && value !== null && !Array.isArray(value);
 }
 
-/**
- * Type guard to check if an object is a TaskStatus update (lacks 'parts').
- * Used to differentiate yielded updates from the handler.
- */
-export function isTaskStatusUpdate(
-  update: TaskYieldUpdate
-): update is ExtendedTaskStatusUpdate {
-  return isObject(update) && "state" in update && !("parts" in update);
-}
-
-/**
- * Type guard to check if an object is an Artifact update (has 'parts').
- * Used to differentiate yielded updates from the handler.
- */
-export function isArtifactUpdate(update: TaskYieldUpdate): update is Artifact {
-  return isObject(update) && "parts" in update && !("state" in update);
-}
-
-export function validateTaskResubscribeParams(
-  params: any
-): asserts params is TaskQueryParams {
-  // Structure validation
-  if (!params || typeof params !== "object") {
-    throw INVALID_PARAMS<string>("Invalid parameters");
-  }
-  if (typeof params.id !== "string" || params.id === "") {
-    throw INVALID_PARAMS<string>("Invalid task ID");
-  }
-}
 /**
  * Validates a task send parameters object.
  * @param params The parameters to validate
  * @throws INVALID_PARAMS if the parameters are invalid
  */
-export function validateTaskSendParams(
+export function validateSendMessageParams(
   params: any
-): asserts params is TaskSendParams {
+): asserts params is MessageSendParams {
   // Structure validation
   if (!params || typeof params !== "object") {
-    throw INVALID_PARAMS<string>("Invalid parameters");
+    throw INVALID_PARAMS("Invalid parameters");
   }
-  if (typeof params.id !== "string" || params.id === "") {
-    throw INVALID_PARAMS<string>("Invalid task ID");
-  }
-
   // Message validation
   if (!params.message || typeof params.message !== "object") {
-    throw INVALID_PARAMS<string>("Invalid message");
+    throw INVALID_PARAMS("Invalid message");
   }
 
   // Role validation
   if (params.message.role !== "user") {
-    throw INVALID_PARAMS<string>("Invalid message role");
+    throw INVALID_PARAMS("Invalid message role");
   }
 
   // Parts validation
@@ -85,13 +45,22 @@ export function validateTaskSendParams(
     !Array.isArray(params.message.parts) ||
     params.message.parts.length === 0
   ) {
-    throw INVALID_PARAMS<string>("Invalid message parts");
+    throw INVALID_PARAMS("Invalid message parts");
+  }
+  if (
+    params.message.parts.some(
+      (part: Part) =>
+        !part.kind ||
+        (part.kind !== "text" && part.kind !== "data" && part.kind !== "file")
+    )
+  ) {
+    throw INVALID_PARAMS("Message parts must be text, data, or file");
   }
 }
 
 export function extractTaskId(id: number | string | null | undefined): string {
   if (!id) {
-    throw INVALID_PARAMS<string>("Missing task ID");
+    throw INVALID_PARAMS("Missing task ID");
   }
   if (typeof id === "number") {
     return id.toString();
diff --git a/src/utils/deployment/agents.ts b/src/utils/deployment/agents.ts
index 99cb012..687c734 100644
--- a/src/utils/deployment/agents.ts
+++ b/src/utils/deployment/agents.ts
@@ -8,7 +8,7 @@ import {
   TaskManagerProps,
   TaskProxy,
 } from "../../types/proxy.js";
-import { TaskContext } from "../../types/context.js";
+import { ExecutionContext } from "../../types/index.js";
 
 const env = process.env;
 
@@ -43,7 +43,7 @@ export namespace artinet {
         return;
       }
 
-      const context = env.context as unknown as TaskContext;
+      const context = env.context as unknown as ExecutionContext;
       const taskManagerProxy = env.taskManagerStub as unknown as TaskProxy;
 
       if (!taskManagerProxy || !context) {
diff --git a/src/utils/deployment/full-deployment.ts b/src/utils/deployment/full-deployment.ts
index 815b9c4..5d0f05e 100644
--- a/src/utils/deployment/full-deployment.ts
+++ b/src/utils/deployment/full-deployment.ts
@@ -1,7 +1,7 @@
 import {
   ServerDeploymentRequestParams,
   ServerDeploymentResponse,
-  A2ARequest,
+  A2AExecutionContext,
   ServerDeploymentRequest,
 } from "../../types/index.js";
 import { executeJsonRpcRequest } from "../../transport/index.js";
@@ -19,7 +19,7 @@ const API_KEY = process.env.ARTINET_API_KEY;
 /**
  * @description The type of the full deployment request.
  */
-type FullDeploymentRequest = A2ARequest | ServerDeploymentRequest;
+type FullDeploymentRequest = A2AExecutionContext | ServerDeploymentRequest;
 
 /**
  * Sends a full deployment request to the server.
diff --git a/src/utils/deployment/task-wrapper.ts b/src/utils/deployment/task-wrapper.ts
index 5a57462..5423854 100644
--- a/src/utils/deployment/task-wrapper.ts
+++ b/src/utils/deployment/task-wrapper.ts
@@ -1,5 +1,4 @@
-import { Task, TaskYieldUpdate } from "../../types/index.js";
-import { TaskContext } from "../../types/context.js";
+import { UpdateEvent, ExecutionContext } from "../../types/index.js";
 import { artinet } from "./agents.js";
 
 /**
@@ -16,17 +15,17 @@ import { artinet } from "./agents.js";
  * and iterates over its yielded updates, passing them to a `hostOnYield` function
  * made available in the `env` by the host environment.
  *
- * The `Context` (TaskContext) is also expected to be provided by the host environment via `env`.
+ * The `Context` (ExecutionContext) is also expected to be provided by the host environment via `env`.
  * @deprecated This function is deprecated and will be removed in a future version. Use the `Artinet.v0.taskManager` function instead.
- * @param taskHandler - An asynchronous generator function that takes a `TaskContext`
- *                      and yields `TaskYieldUpdate` objects, eventually returning a `Task` or void.
+ * @param taskHandler - An asynchronous generator function that takes a `ExecutionContext`
+ *                      and yields `UpdateEvent` objects, eventually returning a `Task` or void.
  * @throws An error if the required `env.hostOnYield` or `env.Context` are not found,
  *         indicating an invalid runtime environment.
  */
 export const taskHandlerProxy = async (
   taskHandler: (
-    context: TaskContext
-  ) => AsyncGenerator<TaskYieldUpdate, Task | void, unknown>
+    context: ExecutionContext
+  ) => AsyncGenerator<UpdateEvent, void, unknown>
 ) => {
   return await artinet.v0.taskManager({ taskHandler });
 };
diff --git a/src/utils/deployment/test-deployment.ts b/src/utils/deployment/test-deployment.ts
index fcfc300..2de90ec 100644
--- a/src/utils/deployment/test-deployment.ts
+++ b/src/utils/deployment/test-deployment.ts
@@ -2,10 +2,11 @@ import {
   ServerDeploymentRequestParams,
   ServerDeploymentResponse,
   TestServerDeploymentRequest,
-  A2ARequest,
+  A2AExecutionContext,
   JSONRPCResponse,
   Task,
-  SendTaskRequest,
+  SendMessageRequest,
+  Message,
 } from "../../types/index.js";
 import { A2AClient } from "../../client/a2a-client.js";
 import { executeStreamEvents } from "../../transport/index.js";
@@ -18,7 +19,7 @@ import { logDebug } from "../../index.js";
  */
 
 const testExecuteStreamEvents = executeStreamEvents as <
-  Req extends A2ARequest | TestServerDeploymentRequest,
+  Req extends A2AExecutionContext | TestServerDeploymentRequest,
   StreamRes extends JSONRPCResponse | ServerDeploymentResponse,
 >(
   baseUrl: URL,
@@ -49,8 +50,8 @@ const testExecuteStreamEvents = executeStreamEvents as <
  */
 export async function* testDeployment(
   params: ServerDeploymentRequestParams,
-  requests: SendTaskRequest[]
-): AsyncIterable<Task | ServerDeploymentResponse | null> {
+  requests: SendMessageRequest[]
+): AsyncIterable<Message | Task | ServerDeploymentResponse | null> {
   const generator = await testExecuteStreamEvents(
     new URL("https://agents.artinet.io/test/deploy"),
     "/test/deploy" as any,
@@ -63,7 +64,6 @@ export async function* testDeployment(
       const testClient = new A2AClient(url);
       for (const request of requests) {
         const task = await testClient.sendTask({
-          id: request.params.id,
           message: request.params.message,
         });
         logDebug("testDeployment", "task: ", task);
@@ -81,13 +81,13 @@ export async function* testDeployment(
       deploymentEvent.result.url
     ) {
       logDebug("testDeployment", "deployment-event: ", deploymentEvent);
-      yield event;
+      yield deploymentEvent;
       const innerGenerator = await requestExecutor(deploymentEvent.result.url);
-      for await (const task of innerGenerator()) {
-        yield task;
+      for await (const updateEvent of innerGenerator()) {
+        yield updateEvent;
       }
     } else {
-      yield event;
+      yield event as any;
       logDebug("testDeployment", "event-received: ", event);
     }
   }
diff --git a/src/utils/logging/log.ts b/src/utils/logging/log.ts
index eb82d8e..356e3b1 100644
--- a/src/utils/logging/log.ts
+++ b/src/utils/logging/log.ts
@@ -40,6 +40,7 @@ export function logError(
   }
   logger.error(logData, message);
 }
+
 /**
  * Logger utility for server warnings
  * @param context The context of the log (e.g., "A2AServer", "TaskStore")
diff --git a/tests/a2a-mcp.test.ts b/tests/a2a-mcp.test.ts
new file mode 100644
index 0000000..174994e
--- /dev/null
+++ b/tests/a2a-mcp.test.ts
@@ -0,0 +1,566 @@
+import { describe, beforeEach, test, expect, afterEach } from "@jest/globals";
+import express from "express";
+import http from "http";
+import {
+  A2AClient,
+  TaskState,
+  logInfo,
+  configureLogger,
+  ExecutionContext,
+  MCPExecutionContext,
+  MessageSendParams,
+  SendMessageRequest,
+  InMemoryTaskStore,
+} from "../src/index.js";
+import {
+  A2AExecutionContext,
+  AgentEngine,
+  MCPContext,
+} from "../src/types/services/context.js";
+import { Protocol } from "../src/types/services/protocol.js";
+import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
+import { ServiceDispatcher } from "../src/types/services/dispatcher.js";
+import { MCPService } from "../src/services/mcp/index.js";
+import { A2AService } from "../src/services/a2a/index.js";
+import { z } from "zod";
+import { ExpressServer } from "../src/server/lib/express-server.js";
+import expressListRoutes from "express-list-routes";
+import request from "supertest";
+// todo: change based on agent engine emissions
+
+// jest.setTimeout(10000);
+configureLogger({ level: "trace" });
+
+/**
+ * Simple echo task handler for testing
+ */
+const echoAgent: AgentEngine = async function* (context: ExecutionContext) {
+  const userMessage =
+    context.protocol === Protocol.MCP
+      ? (context.getRequestParams() as MCPContext).message
+      : (context.getRequestParams() as MessageSendParams).message;
+  // Extract user text
+  const userText = userMessage;
+  // Send working status
+  yield {
+    taskId:
+      (context.getRequestParams() as MessageSendParams).message?.taskId ??
+      context.id,
+    contextId: context.id,
+    kind: "status-update",
+    status: {
+      state: TaskState.Working,
+      message: {
+        messageId: "test-message-id",
+        kind: "message",
+        role: "agent",
+        parts: [{ kind: "text", text: "Processing..." }],
+      },
+    },
+    final: false,
+  };
+  await new Promise((resolve) => setTimeout(resolve, 100));
+  // Check cancellation
+  if (context.isCancelled()) {
+    yield {
+      taskId: context.id,
+      contextId: context.id,
+      kind: "status-update",
+      status: {
+        state: TaskState.Canceled,
+        message: {
+          messageId: "test-message-id",
+          kind: "message",
+          role: "agent",
+          parts: [{ kind: "text", text: "Task was canceled." }],
+        },
+      },
+      final: true,
+    };
+    return;
+  }
+
+  // Create a response
+  const response = `You said: "${userText}"`;
+
+  // Create an artifact
+  yield {
+    taskId: context.id,
+    contextId: context.id,
+    kind: "artifact-update",
+    artifact: {
+      artifactId: "test-artifact-id",
+      name: "echo.txt",
+      parts: [{ kind: "text", text: response }],
+    },
+  };
+
+  // Complete the task
+  yield {
+    id: context.id,
+    contextId: context.id,
+    kind: "task",
+    status: {
+      state: TaskState.Completed,
+      message: {
+        messageId: "test-message-id",
+        kind: "message",
+        role: "agent",
+        parts: [{ kind: "text", text: response }],
+      },
+    },
+  };
+};
+
+const mockReq = (
+  method: string,
+  headers: Record<string, string> = {
+    "mcp-session-id": "test-session-id",
+    accept: "application/json, text/event-stream",
+    "content-type": "application/json",
+  },
+  body: any = {
+    jsonrpc: "2.0",
+    id: "test-session-id",
+    method: "tools/call",
+    params: {
+      name: "test-skill",
+      arguments: {
+        message: "hello world",
+      },
+    },
+  }
+) => {
+  return {
+    method: method,
+    headers: headers,
+    body: body,
+    on: (event: string, callback: (...args: any[]) => void) => {
+      logInfo("mockRequest", event);
+    },
+    status: (code: number) => {
+      logInfo("mock request", code.toString());
+    },
+    write: (payload: any) => {
+      logInfo("mock request", payload);
+    },
+    writeHead: (code: number, headers: Record<string, string>) => {
+      logInfo("mock request", code.toString(), headers);
+    },
+    send: (payload: any) => {
+      logInfo("mock request", payload);
+    },
+    end: (payload: any) => {
+      logInfo("mock request", payload);
+    },
+  };
+};
+
+const mockRes = (
+  resolve: (value?: any) => void,
+  reject: (reason?: any) => void
+) => {
+  return {
+    on: (event: string, callback: (...args: any[]) => void) => {
+      logInfo("mockResponse", "on", event);
+    },
+    onclose: () => {
+      logInfo("mockResponse", "onclose");
+    },
+    onerror: (error: any) => {
+      logInfo("mockResponse", "onerror", error);
+      reject(error);
+    },
+    onend: () => {
+      logInfo("mockResponse", "onend");
+    },
+    ondata: (data: any) => {
+      logInfo("mockResponse", "ondata", data);
+    },
+    ondrain: () => {
+      logInfo("mockResponse", "ondrain");
+    },
+    onfinish: () => {
+      logInfo("mockResponse", "onfinish");
+    },
+    write: (payload: any) => {
+      logInfo("mockResponse", "write", payload);
+    },
+    writeHead: (code: number, headers: Record<string, string>) => {
+      logInfo("mockResponseWriteHead", code.toString(), headers);
+      if (code !== 200 && code !== 201 && code !== 204 && code !== 202) {
+        reject(new Error(`Mock response error: ${code}`));
+      }
+      return {
+        end: (arg: any) => {
+          logInfo("writeHead:mockResponseEnd", arg);
+          resolve();
+        },
+        send: (payload: any) => {
+          logInfo("writeHead:mockResponseSend", payload);
+        },
+      };
+    },
+    send: (payload: any) => {
+      logInfo("mockResponseSend", payload);
+    },
+    end: (payload: any) => {
+      logInfo("mockResponseEnd", payload);
+      resolve(payload);
+    },
+    status: (code: number) => {
+      logInfo("mockResponseStatus", code.toString());
+    },
+  };
+};
+
+describe("Client-Server Integration Tests", () => {
+  let dispatcher: ServiceDispatcher;
+  let mcpService: MCPService;
+  let a2aService: A2AService;
+  let client: A2AClient;
+
+  beforeEach(async () => {
+    // Create a simple server
+    a2aService = new A2AService({
+      engine: echoAgent,
+      card: {
+        name: "test-agent",
+        description: "test-description",
+        url: "test-url",
+        version: "1.0.0",
+        capabilities: {
+          streaming: false,
+          pushNotifications: false,
+          stateTransitionHistory: false,
+        },
+        defaultInputModes: ["text"],
+        defaultOutputModes: ["text"],
+        skills: [
+          {
+            id: "test-skill-id",
+            name: "test-skill",
+            description: "test-description",
+            tags: ["test-tag"],
+          },
+        ],
+      },
+    });
+    mcpService = new MCPService({
+      serverInfo: {
+        name: "test-mcp-server",
+        version: "1.0.0",
+      },
+      engine: echoAgent,
+      skills: [...a2aService.state.getCard().skills],
+    });
+    mcpService.tool(
+      "echo-skill",
+      {
+        message: z.string(),
+      },
+      async ({ message }) => {
+        return {
+          content: [{ type: "text", text: message }],
+        };
+      }
+    );
+    dispatcher = new ServiceDispatcher({
+      services: {
+        [Protocol.A2A]: a2aService,
+        [Protocol.MCP]: mcpService,
+      },
+      engine: echoAgent,
+    });
+  });
+
+  test("dispatcher setup", async () => {
+    expect(dispatcher).toBeDefined();
+  });
+
+  test("mcp service setup", async () => {
+    expect(mcpService).toBeDefined();
+  });
+
+  test("a2a service setup", async () => {
+    expect(a2aService).toBeDefined();
+  });
+
+  test("mcp execute", async () => {
+    const transport = new StreamableHTTPServerTransport({
+      sessionIdGenerator: () => "test-session-id",
+    });
+    transport.sessionId = "test-session-id";
+    // @ts-ignore
+    transport._initialized = true;
+    return new Promise<void>((resolve, reject) => {
+      const executionContext: ExecutionContext<MCPExecutionContext> = {
+        id: "test-session-id",
+        protocol: Protocol.MCP,
+        getRequestParams: () => ({
+          message: "Hello, world!",
+        }),
+        isCancelled: () => false,
+        requestContext: {
+          protocol: Protocol.MCP,
+          id: "test-session-id",
+          method: "tools/call",
+          params: {
+            message: "Hello, world!",
+          },
+          request: mockReq("POST"),
+          transport: transport,
+          response: mockRes(resolve, reject),
+        },
+      };
+      mcpService
+        .execute({
+          executionContext: executionContext,
+          engine: echoAgent,
+        })
+        .catch((error) => {
+          console.error("mcpService execute error", error);
+          reject(error);
+        });
+    });
+  });
+
+  test("a2a execute", async () => {
+    return new Promise<void>((resolve, reject) => {
+      const mockA2AReq = mockReq(
+        "POST",
+        {},
+        {
+          message: "Hello, world!",
+        }
+      );
+      const mockA2ARes = mockRes(resolve, reject);
+      const messageSendContext: A2AExecutionContext<SendMessageRequest> = {
+        id: "test-message-id",
+        protocol: Protocol.A2A,
+        method: "message/send",
+        params: {
+          message: {
+            messageId: "test-message-id",
+            kind: "message",
+            role: "user",
+            parts: [{ kind: "text", text: "Hello, world!" }],
+          },
+        },
+        request: mockA2AReq,
+        response: mockA2ARes,
+        task: {
+          id: "test-message-id",
+          contextId: "test-message-id",
+          status: {
+            state: TaskState.Working,
+            message: {
+              messageId: "test-message-id",
+              kind: "message",
+              role: "user",
+              parts: [{ kind: "text", text: "Hello, world!" }],
+            },
+          },
+          kind: "task",
+          metadata: {},
+        },
+      };
+      a2aService
+        .execute({
+          executionContext: {
+            id: "test-message-id",
+            protocol: Protocol.A2A,
+            getRequestParams: () => messageSendContext.params,
+            isCancelled: () => false,
+            requestContext: messageSendContext,
+          },
+          engine: echoAgent,
+        })
+        .catch((error) => {
+          console.error("a2a execute error", error);
+          reject(error);
+        });
+    });
+  });
+
+  test("mcp onRequest", async () => {
+    const transport = new StreamableHTTPServerTransport({
+      sessionIdGenerator: () => "test-session-id",
+    });
+    transport.sessionId = "test-session-id";
+    // @ts-ignore
+    transport._initialized = true;
+    logInfo("transport", transport.sessionId);
+    return new Promise<void>((resolve, reject) => {
+      const mockRequest = mockReq("POST");
+      const mockResponse = mockRes(resolve, reject);
+      dispatcher
+        .onRequest({
+          protocol: Protocol.MCP,
+          id: "test-session-id",
+          method: "tools/call",
+          params: {
+            message: "Hello, world!",
+          },
+          request: mockRequest,
+          response: mockResponse,
+          transport: transport,
+        })
+        .catch((error) => {
+          console.error("mcp onRequest error", error);
+          reject(error);
+        });
+    });
+  });
+  test("a2a onRequest", async () => {
+    return new Promise<void>((resolve, reject) => {
+      const mockA2AReq = mockReq("POST");
+      const mockA2ARes = mockRes(resolve, reject);
+      dispatcher
+        .onRequest({
+          protocol: Protocol.A2A,
+          id: "test-message-id",
+          method: "message/send",
+          params: {
+            message: {
+              messageId: "test-message-id",
+              kind: "message",
+              role: "user",
+              parts: [{ kind: "text", text: "Hello, world!" }],
+            },
+          },
+          request: mockA2AReq,
+          response: mockA2ARes,
+        })
+        .catch((error) => {
+          console.error("a2a onRequest error", error);
+          reject(error);
+        });
+    });
+  });
+
+  test("mcp tool", async () => {
+    const transport = new StreamableHTTPServerTransport({
+      sessionIdGenerator: () => "test-session-id",
+    });
+    transport.sessionId = "test-session-id";
+    // @ts-ignore
+    transport._initialized = true;
+    return new Promise<void>((resolve, reject) => {
+      const mockRequest = mockReq("POST");
+      const mockResponse = mockRes(resolve, reject);
+      dispatcher
+        .onRequest({
+          protocol: Protocol.MCP,
+          id: "test-session-id",
+          method: "tools/call",
+          params: {
+            message: "Echo This!",
+          },
+          request: mockReq("POST", undefined, {
+            jsonrpc: "2.0",
+            id: "test-session-id",
+            method: "tools/call",
+            params: {
+              name: "echo-skill",
+              arguments: {
+                message: "Echo This!",
+              },
+            },
+          }),
+          response: mockResponse,
+          transport: transport,
+        })
+        .catch((error) => {
+          console.error("mcp tool error", error);
+          reject(error);
+        });
+    });
+  });
+
+  describe("express broker", () => {
+    let app: express.Express;
+    let server: http.Server;
+    let broker: ExpressServer;
+    // Track any pending requests for cleanup
+    let pendingRequests: request.Test[] = [];
+
+    beforeEach(async () => {
+      broker = new ExpressServer({
+        taskStore: new InMemoryTaskStore(),
+        card: a2aService.state.getCard(),
+        engine: echoAgent,
+        services: {
+          [Protocol.MCP]: mcpService,
+          [Protocol.A2A]: a2aService,
+        },
+      });
+      broker.registerRoutes();
+      app = broker.getApp();
+      server = await broker.start();
+      pendingRequests = [];
+    });
+
+    afterEach(async () => {
+      // Ensure all pending requests are completed
+      await Promise.all(
+        pendingRequests.map((req) => {
+          try {
+            return req;
+          } catch (e) {
+            // Ignore errors during cleanup
+            return null;
+          }
+        })
+      );
+
+      await broker.stop();
+      // Add a small delay to allow any open connections to close
+      await new Promise((resolve) => setTimeout(resolve, 100));
+    });
+
+    // Helper function to track supertest requests
+    const trackRequest = (req: request.Test): request.Test => {
+      pendingRequests.push(req);
+      return req;
+    };
+
+    test("express broker setup", async () => {
+      const routes = expressListRoutes(app);
+      logInfo("express broker routes", JSON.stringify(routes, null, 2));
+    });
+    test("express broker receive message", async () => {
+      const response = await trackRequest(
+        request(server)
+          .post("/a2a")
+          .send({
+            jsonrpc: "2.0",
+            id: "test-session-id",
+            method: "message/send",
+            params: {
+              message: {
+                messageId: "test-message-id",
+                kind: "message",
+                role: "user",
+                parts: [{ kind: "text", text: "Hello, world!" }],
+              },
+            },
+          })
+      );
+      await request(server).get("/");
+      console.log("response", response.body);
+      expect(response.status).toBe(200);
+      expect(response.body.result).toBeDefined();
+      expect(response.body.result.kind).toBe("task");
+      expect(response.body.result.status.state).toBe(TaskState.Completed);
+      expect(response.body.result.status.message).toBeDefined();
+      expect(response.body.result.status.message.kind).toBe("message");
+      expect(response.body.result.status.message.role).toBe("agent");
+      expect(response.body.result.status.message.parts).toBeDefined();
+      expect(response.body.result.status.message.parts[0].kind).toBe("text");
+      expect(response.body.result.status.message.parts[0].text).toContain(
+        "You said:"
+      );
+    });
+  });
+});
diff --git a/tests/a2a-protocol.test.ts b/tests/a2a-protocol.test.ts
index 686a428..453ffba 100644
--- a/tests/a2a-protocol.test.ts
+++ b/tests/a2a-protocol.test.ts
@@ -1,12 +1,25 @@
-import { jest } from "@jest/globals";
+import {
+  jest,
+  describe,
+  it,
+  beforeEach,
+  afterEach,
+  expect,
+} from "@jest/globals";
 import express from "express";
 import request from "supertest";
 import {
   A2AServer,
+  ExecutionContext,
   InMemoryTaskStore,
-  TaskContext,
+  A2AExecutionContext,
+  TaskState,
+  TaskStatusUpdateEvent,
   TaskYieldUpdate,
+  TextPart,
+  UpdateEvent,
   configureLogger,
+  MessageSendParams,
 } from "../src/index.js";
 
 configureLogger({ level: "silent" });
@@ -16,11 +29,14 @@ jest.setTimeout(10000);
 
 // Define a comprehensive task handler for A2A protocol testing
 async function* a2aProtocolTestHandler(
-  context: TaskContext
-): AsyncGenerator<TaskYieldUpdate, void, unknown> {
-  const text = context.userMessage.parts
-    .filter((part) => part.type === "text")
-    .map((part) => (part as any).text)
+  context: ExecutionContext<A2AExecutionContext>
+): AsyncGenerator<UpdateEvent, void, unknown> {
+  const params = context.getRequestParams() as MessageSendParams;
+  const taskId = params.message.taskId ?? context.id;
+  const contextId = context.id;
+  const text = params.message.parts
+    .filter((part) => part.kind === "text")
+    .map((part) => (part as TextPart).text)
     .join(" ");
 
   // Test for all possible states in A2A protocol
@@ -29,145 +45,168 @@ async function* a2aProtocolTestHandler(
   }
 
   if (text.includes("fail")) {
-    yield {
-      state: "failed",
-      message: {
-        role: "agent",
-        parts: [{ type: "text", text: "Task failed intentionally." }],
+    const yieldable: TaskStatusUpdateEvent = {
+      taskId: taskId,
+      kind: "status-update",
+      contextId: contextId,
+      final: true,
+      status: {
+        state: TaskState.Failed,
+        message: {
+          messageId: "test-message-id",
+          kind: "message",
+          role: "agent",
+          parts: [{ kind: "text", text: "Task failed intentionally." }],
+        },
       },
     };
+    yield yieldable;
     return;
   }
 
   if (text.includes("input-required")) {
-    yield {
-      state: "working",
-      message: {
-        role: "agent",
-        parts: [{ type: "text", text: "Processing request..." }],
+    const yieldable: TaskStatusUpdateEvent = {
+      taskId: taskId,
+      kind: "status-update",
+      contextId: contextId,
+      final: true,
+      status: {
+        state: TaskState.InputRequired,
+        message: {
+          messageId: "test-message-id",
+          kind: "message",
+          role: "agent",
+          parts: [{ kind: "text", text: "need more information" }],
+        },
       },
     };
 
-    yield {
-      state: "input-required",
-      message: {
-        role: "agent",
-        parts: [
-          {
-            type: "text",
-            text: "I need more information. Please provide details.",
-          },
-        ],
-      },
-    };
+    yield yieldable;
     return;
   }
 
   if (text.includes("working-only")) {
-    yield {
-      state: "working",
-      message: {
-        role: "agent",
-        parts: [{ type: "text", text: "Still working..." }],
+    const yieldable: TaskStatusUpdateEvent = {
+      taskId: taskId,
+      kind: "status-update",
+      contextId: contextId,
+      final: false,
+      status: {
+        state: TaskState.Working,
+        message: {
+          messageId: "test-message-id-working-only",
+          kind: "message",
+          role: "agent",
+          parts: [{ kind: "text", text: "Still working..." }],
+        },
       },
     };
+
+    yield yieldable;
     return;
   }
-
   if (text.includes("multi-part")) {
     yield {
-      state: "working",
-      message: {
-        role: "agent",
-        parts: [
-          { type: "text", text: "First part" },
-          { type: "data", data: { key: "value" } },
-        ],
+      taskId: taskId,
+      kind: "status-update",
+      contextId: contextId,
+      final: true,
+      status: {
+        state: TaskState.Working,
+        message: {
+          messageId: "test-message-id-multi-part",
+          kind: "message",
+          role: "agent",
+          parts: [
+            { kind: "text", text: "First part" },
+            { kind: "data", data: { key: "value" } },
+          ],
+        },
       },
     };
 
     yield {
-      state: "completed",
-      message: {
-        role: "agent",
-        parts: [
-          { type: "text", text: "Task completed with multiple part types." },
-          {
-            type: "file",
-            file: {
-              name: "test.txt",
-              mimeType: "text/plain",
-              bytes: Buffer.from("test content").toString("base64"),
+      taskId: taskId,
+      kind: "status-update",
+      contextId: contextId,
+      final: true,
+      status: {
+        state: TaskState.Completed,
+        message: {
+          messageId: "test-message-id-multi-part",
+          kind: "message",
+          role: "agent",
+          parts: [
+            { kind: "text", text: "Task completed with multiple part types." },
+            {
+              kind: "file",
+              file: {
+                name: "test.txt",
+                mimeType: "text/plain",
+                bytes: Buffer.from("test content").toString("base64"),
+              },
             },
-          },
-        ],
-      },
-      // Using 'as any' to bypass the type checking for testing purposes
-      artifacts: [
-        {
-          name: "test-artifact",
-          description: "Test artifact description",
-          parts: [{ type: "text", text: "Artifact content" }],
-          index: 0,
-          metadata: {
-            testKey: "testValue",
-          },
+          ],
         },
-      ] as any,
+      },
     };
     return;
   }
 
   if (text.includes("streaming")) {
     yield {
-      state: "working",
-      message: {
-        role: "agent",
-        parts: [{ type: "text", text: "Working..." }],
+      taskId: taskId,
+      kind: "status-update",
+      contextId: contextId,
+      final: false,
+      status: {
+        state: TaskState.Working,
+        message: {
+          messageId: "test-message-id-streaming",
+          kind: "message",
+          role: "agent",
+          parts: [{ kind: "text", text: "Working..." }],
+        },
       },
     };
 
     yield {
-      state: "working",
-      message: {
-        role: "agent",
-        parts: [{ type: "text", text: "Still working..." }],
+      taskId: taskId,
+      kind: "artifact-update",
+      contextId: contextId,
+      artifact: {
+        artifactId: "test-artifact-id",
+        name: "partial-artifact",
+        parts: [{ kind: "text", text: "Partial " }],
       },
-      // Using 'as any' to bypass the type checking for testing purposes
-      artifacts: [
-        {
-          name: "partial-artifact",
-          parts: [{ type: "text", text: "Partial " }],
-          index: 0,
-          append: false,
-          lastChunk: false,
-        },
-      ] as any,
     };
 
     yield {
-      state: "working",
-      message: {
-        role: "agent",
-        parts: [{ type: "text", text: "Almost done..." }],
+      taskId: taskId,
+      kind: "artifact-update",
+      contextId: contextId,
+      artifact: {
+        artifactId: "test-artifact-id",
+        name: "partial-artifact",
+        parts: [{ kind: "text", text: "Partial " }],
       },
-      // Using 'as any' to bypass the type checking for testing purposes
-      artifacts: [
-        {
-          name: "partial-artifact",
-          parts: [{ type: "text", text: "artifact content" }],
-          index: 0,
-          append: true,
-          lastChunk: true,
-        },
-      ] as any,
+      append: true,
+      lastChunk: true,
     };
 
     yield {
-      state: "completed",
-      message: {
-        role: "agent",
-        parts: [{ type: "text", text: "Streaming completed!" }],
+      taskId: taskId,
+      kind: "status-update",
+      contextId: contextId,
+      final: true,
+      status: {
+        state: TaskState.Completed,
+        message: {
+          messageId: "test-message-id-streaming-completed",
+          kind: "message",
+          role: "agent",
+          parts: [{ kind: "text", text: "Streaming completed!" }],
+        },
       },
     };
     return;
@@ -175,18 +214,34 @@ async function* a2aProtocolTestHandler(
 
   // Default case - normal processing
   yield {
-    state: "working",
-    message: {
-      role: "agent",
-      parts: [{ type: "text", text: "Working..." }],
+    taskId: taskId,
+    kind: "status-update",
+    contextId: contextId,
+    final: false,
+    status: {
+      state: TaskState.Working,
+      message: {
+        messageId: "test-message-id-working",
+        kind: "message",
+        role: "agent",
+        parts: [{ kind: "text", text: "Working..." }],
+      },
     },
   };
 
   yield {
-    state: "completed",
-    message: {
-      role: "agent",
-      parts: [{ type: "text", text: "Task completed successfully." }],
+    taskId: taskId,
+    kind: "status-update",
+    contextId: contextId,
+    final: true,
+    status: {
+      state: TaskState.Completed,
+      message: {
+        messageId: "test-message-id-completed",
+        kind: "message",
+        role: "agent",
+        parts: [{ kind: "text", text: "Task completed successfully." }],
+      },
     },
   };
 }
@@ -205,6 +260,9 @@ describe("A2A Protocol Specification Tests", () => {
         name: "A2A Protocol Test Agent",
         url: "http://localhost:41241",
         version: "1.0.0",
+        description: "A2A Protocol Test Agent",
+        defaultInputModes: ["text"],
+        defaultOutputModes: ["text"],
         capabilities: {
           streaming: true,
           pushNotifications: true,
@@ -213,7 +271,9 @@ describe("A2A Protocol Specification Tests", () => {
         skills: [
           {
             id: "test",
-            name: "Test Skill",
+            name: "test",
+            description: "Test Skill Description",
+            tags: ["test", "skill"],
           },
         ],
       },
@@ -273,12 +333,13 @@ describe("A2A Protocol Specification Tests", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "test-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
           id: "test-task-1",
           message: {
+            taskId: "test-task-1",
             role: "user",
-            parts: [{ type: "text", text: "Basic test" }],
+            parts: [{ kind: "text", text: "Basic test" }],
           },
         },
       };
@@ -300,12 +361,13 @@ describe("A2A Protocol Specification Tests", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "fail-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
           id: "fail-task-1",
           message: {
+            taskId: "fail-task-1",
             role: "user",
-            parts: [{ type: "text", text: "This will fail" }],
+            parts: [{ kind: "text", text: "This will fail" }],
           },
         },
       };
@@ -327,12 +389,12 @@ describe("A2A Protocol Specification Tests", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "input-required-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "input-required-task-1",
           message: {
+            taskId: "input-required-task-1",
             role: "user",
-            parts: [{ type: "text", text: "This needs input-required" }],
+            parts: [{ kind: "text", text: "This needs input-required" }],
           },
         },
       };
@@ -354,12 +416,13 @@ describe("A2A Protocol Specification Tests", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "working-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
           id: "working-task-1",
           message: {
+            taskId: "working-task-1",
             role: "user",
-            parts: [{ type: "text", text: "This is working-only" }],
+            parts: [{ kind: "text", text: "This is working-only" }],
           },
         },
       };
@@ -383,12 +446,13 @@ describe("A2A Protocol Specification Tests", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "multi-part-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
           id: "multi-part-task-1",
           message: {
+            taskId: "multi-part-task-1",
             role: "user",
-            parts: [{ type: "text", text: "This is multi-part" }],
+            parts: [{ kind: "text", text: "This is multi-part" }],
           },
         },
       };
@@ -396,7 +460,6 @@ describe("A2A Protocol Specification Tests", () => {
       const response = await trackRequest(
         request(app).post("/").send(requestBody)
       );
-
       expect(response.status).toBe(200);
       expect(response.body.result).toBeDefined();
       expect(response.body.result.id).toBe("multi-part-task-1");
@@ -404,8 +467,8 @@ describe("A2A Protocol Specification Tests", () => {
 
       // Check multiple parts in message
       expect(response.body.result.status.message.parts).toHaveLength(2);
-      expect(response.body.result.status.message.parts[0].type).toBe("text");
-      expect(response.body.result.status.message.parts[1].type).toBe("file");
+      expect(response.body.result.status.message.parts[0].kind).toBe("text");
+      expect(response.body.result.status.message.parts[1].kind).toBe("file");
       expect(response.body.result.status.message.parts[1].file.name).toBe(
         "test.txt"
       );
@@ -433,12 +496,13 @@ describe("A2A Protocol Specification Tests", () => {
       const createBody = {
         jsonrpc: "2.0",
         id: "create-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
           id: "retrieve-task-1",
           message: {
+            taskId: "retrieve-task-1",
             role: "user",
-            parts: [{ type: "text", text: "Task to be retrieved" }],
+            parts: [{ kind: "text", text: "Task to be retrieved" }],
           },
         },
       };
@@ -458,7 +522,6 @@ describe("A2A Protocol Specification Tests", () => {
       const response = await trackRequest(
         request(app).post("/").send(retrieveBody)
       );
-
       expect(response.status).toBe(200);
       expect(response.body.result).toBeDefined();
       expect(response.body.result.id).toBe("retrieve-task-1");
@@ -490,12 +553,12 @@ describe("A2A Protocol Specification Tests", () => {
       const createBody = {
         jsonrpc: "2.0",
         id: "cancel-create-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "cancel-task-1",
           message: {
+            taskId: "cancel-task-1",
             role: "user",
-            parts: [{ type: "text", text: "This is working-only" }],
+            parts: [{ kind: "text", text: "This is working-only" }],
           },
         },
       };
@@ -515,7 +578,6 @@ describe("A2A Protocol Specification Tests", () => {
       const response = await trackRequest(
         request(app).post("/").send(cancelBody)
       );
-
       expect(response.status).toBe(200);
       expect(response.body.result).toBeDefined();
       expect(response.body.result.id).toBe("cancel-task-1");
@@ -547,18 +609,17 @@ describe("A2A Protocol Specification Tests", () => {
       const createBody = {
         jsonrpc: "2.0",
         id: "completed-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "completed-task-1",
           message: {
+            taskId: "completed-task-1",
             role: "user",
-            parts: [{ type: "text", text: "Task to be completed" }],
+            parts: [{ kind: "text", text: "Task to be completed" }],
           },
         },
       };
 
       await trackRequest(request(app).post("/").send(createBody));
-
       // Now try to cancel it
       const cancelBody = {
         jsonrpc: "2.0",
@@ -586,12 +647,12 @@ describe("A2A Protocol Specification Tests", () => {
       const createBody = {
         jsonrpc: "2.0",
         id: "push-create-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
           id: "push-task-1",
           message: {
             role: "user",
-            parts: [{ type: "text", text: "Task for push notifications" }],
+            parts: [{ kind: "text", text: "Task for push notifications" }],
           },
         },
       };
@@ -602,9 +663,9 @@ describe("A2A Protocol Specification Tests", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "push-request-1",
-        method: "tasks/pushNotification/set",
+        method: "tasks/pushNotificationConfig/set",
         params: {
-          id: "push-task-1",
+          taskId: "push-task-1",
           pushNotificationConfig: {
             url: "https://example.com/webhook",
             token: "test-token",
@@ -617,30 +678,17 @@ describe("A2A Protocol Specification Tests", () => {
       );
 
       expect(response.status).toBe(200);
-
-      // The implementation might return either a result with the config or a method not found error
-      if (response.body.result) {
-        expect(response.body.result.id).toBe("push-task-1");
-        if (response.body.result.pushNotificationConfig) {
-          expect(response.body.result.pushNotificationConfig.url).toBe(
-            "https://example.com/webhook"
-          );
-          expect(response.body.result.pushNotificationConfig.token).toBe(
-            "test-token"
-          );
-        }
-      } else if (response.body.error) {
-        // The server might return method not found error if push notifications aren't implemented
-        expect([-32601, -32003]).toContain(response.body.error.code);
-      }
+      expect(response.body.error).toBeDefined();
+      expect(response.body.error.code).toBe(-32001);
+      expect(response.body.error.message).toBe("Task not found");
     });
 
-    it("gets push notification configuration", async () => {
+    it("does not get push notification configuration", async () => {
       // First create a task
       const createBody = {
         jsonrpc: "2.0",
         id: "push-create-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
           id: "push-get-task-1",
           message: {
@@ -656,34 +704,30 @@ describe("A2A Protocol Specification Tests", () => {
       const getBody = {
         jsonrpc: "2.0",
         id: "push-get-request-1",
-        method: "tasks/pushNotification/get",
+        method: "tasks/pushNotificationConfig/get",
         params: {
           id: "push-get-task-1",
+          config: {
+            url: "https://example.com/webhook",
+            token: "test-token",
+          },
         },
       };
 
       const response = await trackRequest(request(app).post("/").send(getBody));
 
       expect(response.status).toBe(200);
-
-      // Since we didn't set a push notification, we might get null result
-      // or a method not found error if not implemented
-      if (response.body.result !== undefined) {
-        // Result might be null or an actual config object
-        // Test passes in either case since we're just checking the response structure
-      } else if (response.body.error) {
-        // The server might return method not found error if push notifications aren't implemented
-        expect([-32601, -32003]).toContain(response.body.error.code);
-      }
+      expect(response.body.error).toBeDefined();
+      expect(response.body.error.code).toBe(-32001);
     });
 
     it("returns error when setting push notification for non-existent task", async () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "nonexistent-push-request-1",
-        method: "tasks/pushNotification/set",
+        method: "tasks/pushNotificationConfig/set",
         params: {
-          id: "nonexistent-task-1",
+          taskId: "nonexistent-task-1",
           pushNotificationConfig: {
             url: "https://example.com/webhook",
           },
@@ -728,14 +772,8 @@ describe("A2A Protocol Specification Tests", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "invalid-params-request-1",
-        method: "tasks/send",
-        params: {
-          // Missing required id field
-          message: {
-            role: "user",
-            parts: [{ type: "text", text: "Invalid params" }],
-          },
-        },
+        method: "message/send",
+        params: {},
       };
 
       const response = await trackRequest(
diff --git a/tests/client.test.ts b/tests/client.test.ts
index c05119d..30cbf9b 100644
--- a/tests/client.test.ts
+++ b/tests/client.test.ts
@@ -5,7 +5,7 @@ import {
   Message,
   Task,
   TaskState,
-  TaskSendParams,
+  MessageSendParams,
   TaskStatusUpdateEvent,
   TaskArtifactUpdateEvent,
   TaskPushNotificationConfig,
@@ -34,19 +34,25 @@ const MOCK_AGENT_CARD: AgentCard = {
       id: "test-skill",
       name: "Test Skill",
       description: "A test skill for unit tests",
+      tags: ["test", "skill"],
     },
   ],
+  defaultInputModes: ["text"],
+  defaultOutputModes: ["text"],
 };
 
 const MOCK_TASK: Task = {
   id: "test-task-123",
+  kind: "task",
   status: {
     state: "completed" as TaskState,
     message: {
+      messageId: "test-message-id",
+      kind: "message",
       role: "agent",
       parts: [
         {
-          type: "text",
+          kind: "text",
           text: "This is a test response",
         },
       ],
@@ -55,10 +61,11 @@ const MOCK_TASK: Task = {
   },
   artifacts: [
     {
+      artifactId: "test-artifact-id",
       name: "test-artifact",
       parts: [
         {
-          type: "text",
+          kind: "text",
           text: "Artifact content",
         },
       ],
@@ -68,20 +75,26 @@ const MOCK_TASK: Task = {
 
 // Task update events for streaming
 const STATUS_UPDATE_EVENT: TaskStatusUpdateEvent = {
-  id: "test-task-123",
+  taskId: "test-task-123",
+  contextId: "test-context-id",
+  kind: "status-update",
+  final: false,
   status: {
-    state: "in_progress" as TaskState,
+    state: "working" as TaskState,
     timestamp: new Date().toISOString(),
   },
 };
 
 const ARTIFACT_UPDATE_EVENT: TaskArtifactUpdateEvent = {
-  id: "test-task-123",
+  taskId: "test-task-123",
+  contextId: "test-context-id",
+  kind: "artifact-update",
   artifact: {
+    artifactId: "test-artifact-id",
     name: "new-artifact",
     parts: [
       {
-        type: "text",
+        kind: "text",
         text: "New artifact content",
       },
     ],
@@ -94,7 +107,7 @@ const MOCK_NOTIFICATION_CONFIG: PushNotificationConfig = {
 };
 
 const MOCK_PUSH_NOTIFICATION_CONFIG: TaskPushNotificationConfig = {
-  id: "test-task-123",
+  taskId: "test-task-123",
   pushNotificationConfig: MOCK_NOTIFICATION_CONFIG,
 };
 
@@ -110,7 +123,7 @@ const server = setupServer(
     return HttpResponse.json(MOCK_AGENT_CARD);
   }),
 
-  // Mock tasks/send endpoint
+  // Mock message/send endpoint
   http.post("https://test-agent.example.com", async ({ request }) => {
     const body = (await request.json()) as {
       method: string;
@@ -118,7 +131,7 @@ const server = setupServer(
       params?: Record<string, any>;
     };
 
-    if (body.method === "tasks/send") {
+    if (body.method === "message/send") {
       return HttpResponse.json({
         jsonrpc: "2.0",
         id: body.id,
@@ -149,7 +162,7 @@ const server = setupServer(
       });
     }
 
-    if (body.method === "tasks/pushNotification/set") {
+    if (body.method === "tasks/pushNotificationConfig/set") {
       return HttpResponse.json({
         jsonrpc: "2.0",
         id: body.id,
@@ -157,7 +170,7 @@ const server = setupServer(
       });
     }
 
-    if (body.method === "tasks/pushNotification/get") {
+    if (body.method === "tasks/pushNotificationConfig/get") {
       return HttpResponse.json({
         jsonrpc: "2.0",
         id: body.id,
@@ -166,7 +179,7 @@ const server = setupServer(
     }
 
     if (
-      body.method === "tasks/sendSubscribe" ||
+      body.method === "message/stream" ||
       body.method === "tasks/resubscribe"
     ) {
       // For streaming endpoints, create a mock SSE response
@@ -319,17 +332,18 @@ describe("A2AClient", () => {
   // Test sending a task
   test("should send a task and receive a response", async () => {
     const message: Message = {
+      messageId: "test-message-id",
+      kind: "message",
       role: "user",
       parts: [
         {
-          type: "text",
+          kind: "text",
           text: "Hello, this is a test message",
         },
       ],
     };
 
-    const params: TaskSendParams = {
-      id: "test-task-123",
+    const params: MessageSendParams = {
       message,
     };
 
@@ -357,7 +371,7 @@ describe("A2AClient", () => {
   // Test push notification config setting
   test("should set task push notification config", async () => {
     const config: TaskPushNotificationConfig = {
-      id: "test-task-123",
+      taskId: "test-task-123",
       pushNotificationConfig: {
         url: "https://notification-endpoint.example.com",
         token: "test-notification-token",
@@ -381,21 +395,27 @@ describe("A2AClient", () => {
   // Test streaming task updates
   test("should stream task updates", async () => {
     const message: Message = {
+      messageId: "test-message-id",
+      kind: "message",
       role: "user",
       parts: [
         {
-          type: "text",
+          kind: "text",
           text: "Hello, this is a test message",
         },
       ],
     };
 
-    const params: TaskSendParams = {
-      id: "test-task-123",
+    const params: MessageSendParams = {
       message,
     };
 
-    const events: (TaskStatusUpdateEvent | TaskArtifactUpdateEvent)[] = [];
+    const events: (
+      | Task
+      | TaskStatusUpdateEvent
+      | TaskArtifactUpdateEvent
+      | Message
+    )[] = [];
     const stream = client.sendTaskSubscribe(params);
     for await (const event of stream) {
       events.push(event);
@@ -413,7 +433,12 @@ describe("A2AClient", () => {
       id: "test-task-123",
     };
 
-    const events: (TaskStatusUpdateEvent | TaskArtifactUpdateEvent)[] = [];
+    const events: (
+      | Task
+      | TaskStatusUpdateEvent
+      | TaskArtifactUpdateEvent
+      | Message
+    )[] = [];
 
     for await (const event of client.resubscribeTask(params)) {
       events.push(event);
@@ -508,8 +533,12 @@ describe("A2AClient", () => {
     );
 
     const stream = client.sendTaskSubscribe({
-      id: "test-task-123",
-      message: { role: "user", parts: [{ type: "text", text: "Test" }] },
+      message: {
+        messageId: "test-message-id",
+        kind: "message",
+        role: "user",
+        parts: [{ kind: "text", text: "Test" }],
+      },
     });
 
     await expect(async () => {
diff --git a/tests/common-errors.test.ts b/tests/common-errors.test.ts
index e48d890..0ee7147 100644
--- a/tests/common-errors.test.ts
+++ b/tests/common-errors.test.ts
@@ -27,7 +27,9 @@ configureLogger({ level: "silent" });
 describe("Error Handling Utilities", () => {
   describe("SystemError", () => {
     it("should create a SystemError with proper attributes", () => {
-      const error = new SystemError("System operation failed", -12345);
+      const error = new SystemError("System operation failed", -12345, {
+        detail: "Additional error information",
+      });
       expect(error.name).toBe("RpcError");
       expect(error.message).toBe("System operation failed");
       expect(error.code).toBe(-12345);
@@ -44,63 +46,65 @@ describe("Error Handling Utilities", () => {
 
   describe("Error Factories", () => {
     it("should create Parse Error", () => {
-      const error = PARSE_ERROR();
+      const error = PARSE_ERROR("Invalid JSON payload");
       expect(error).toBeInstanceOf(SystemError);
       expect(error.code).toBe(ErrorCodeParseError);
       expect(error.message).toBe("Invalid JSON payload");
     });
 
     it("should create Invalid Request Error", () => {
-      const error = INVALID_REQUEST();
+      const error = INVALID_REQUEST("Invalid request");
       expect(error).toBeInstanceOf(SystemError);
       expect(error.code).toBe(ErrorCodeInvalidRequest);
       expect(error.message).toBe("Request payload validation error");
     });
 
     it("should create Method Not Found Error", () => {
-      const error = METHOD_NOT_FOUND();
+      const error = METHOD_NOT_FOUND("Method not found");
       expect(error).toBeInstanceOf(SystemError);
       expect(error.code).toBe(ErrorCodeMethodNotFound);
       expect(error.message).toBe("Method not found");
     });
 
     it("should create Invalid Params Error", () => {
-      const error = INVALID_PARAMS();
+      const error = INVALID_PARAMS("Invalid parameters");
       expect(error).toBeInstanceOf(SystemError);
       expect(error.code).toBe(ErrorCodeInvalidParams);
       expect(error.message).toBe("Invalid parameters");
     });
 
     it("should create Internal Error", () => {
-      const error = INTERNAL_ERROR();
+      const error = INTERNAL_ERROR("Internal error");
       expect(error).toBeInstanceOf(SystemError);
       expect(error.code).toBe(ErrorCodeInternalError);
       expect(error.message).toBe("Internal error");
     });
 
     it("should create Task Not Found Error", () => {
-      const error = TASK_NOT_FOUND();
+      const error = TASK_NOT_FOUND("Task not found");
       expect(error).toBeInstanceOf(SystemError);
       expect(error.code).toBe(ErrorCodeTaskNotFound);
       expect(error.message).toBe("Task not found");
     });
 
     it("should create Task Not Cancelable Error", () => {
-      const error = TASK_NOT_CANCELABLE();
+      const error = TASK_NOT_CANCELABLE("Task cannot be canceled");
       expect(error).toBeInstanceOf(SystemError);
       expect(error.code).toBe(ErrorCodeTaskNotCancelable);
       expect(error.message).toBe("Task cannot be canceled");
     });
 
     it("should create Unsupported Operation Error", () => {
-      const error = UNSUPPORTED_OPERATION();
+      const error = UNSUPPORTED_OPERATION("This operation is not supported");
       expect(error).toBeInstanceOf(SystemError);
       expect(error.code).toBe(ErrorCodeUnsupportedOperation);
       expect(error.message).toBe("This operation is not supported");
     });
 
     it("should create Push Notification Not Supported Error", () => {
-      const error = PUSH_NOTIFICATION_NOT_SUPPORTED();
+      const error = PUSH_NOTIFICATION_NOT_SUPPORTED(
+        "Push Notification is not supported"
+      );
       expect(error).toBeInstanceOf(SystemError);
       expect(error.code).toBe(ErrorCodePushNotificationNotSupported);
       expect(error.message).toBe("Push Notification is not supported");
@@ -116,17 +120,17 @@ describe("Error Handling Utilities", () => {
   describe("FAILED_UPDATE", () => {
     it("should create a failed task update", () => {
       const message = "Task execution failed";
-      const update = FAILED_UPDATE(message);
+      const update = FAILED_UPDATE("taskId", "contextId", "agent", message);
 
       // Test the structure without relying on specific type
       const failedUpdate = update as any;
-      expect(failedUpdate.state).toBe("failed");
-      expect(failedUpdate.message).toBeDefined();
-      expect(failedUpdate.message.role).toBe("agent");
-      expect(Array.isArray(failedUpdate.message.parts)).toBe(true);
-      expect(failedUpdate.message.parts).toHaveLength(1);
-      expect(failedUpdate.message.parts[0].type).toBe("text");
-      expect(failedUpdate.message.parts[0].text).toBe(message);
+      expect(failedUpdate.status.state).toBe("failed");
+      expect(failedUpdate.status.message).toBeDefined();
+      expect(failedUpdate.status.message.role).toBe("agent");
+      expect(Array.isArray(failedUpdate.status.message.parts)).toBe(true);
+      expect(failedUpdate.status.message.parts).toHaveLength(1);
+      expect(failedUpdate.status.message.parts[0].kind).toBe("text");
+      expect(failedUpdate.status.message.parts[0].text).toBe(message);
     });
   });
 
diff --git a/tests/deployment.test.ts b/tests/deployment.xx.ts
similarity index 83%
rename from tests/deployment.test.ts
rename to tests/deployment.xx.ts
index 2387d80..d5318ce 100644
--- a/tests/deployment.test.ts
+++ b/tests/deployment.xx.ts
@@ -2,7 +2,7 @@ import { jest } from "@jest/globals";
 import {
   testDeployment,
   configureLogger,
-  SendTaskRequest,
+  SendMessageRequest,
   Message,
   AgentCard,
   ServerDeploymentRequestParams,
@@ -10,7 +10,7 @@ import {
   Task,
   bundle,
   fullDeployment,
-  TaskSendParams,
+  MessageSendParams,
 } from "../src/index.js";
 import { logDebug } from "../src/utils/logging/log.js";
 import { A2AClient } from "../src/index.js";
@@ -47,8 +47,11 @@ const MOCK_AGENT_CARD: AgentCard = {
       id: "test-skill",
       name: "Test Skill",
       description: "A test skill for unit tests",
+      tags: ["test", "skill"],
     },
   ],
+  defaultInputModes: ["text"],
+  defaultOutputModes: ["text"],
 };
 
 const MOCK_AGENT_CARD_NESTED: AgentCard = {
@@ -66,8 +69,11 @@ const MOCK_AGENT_CARD_NESTED: AgentCard = {
       id: "test-skill",
       name: "Test Skill",
       description: "A test skill for unit tests",
+      tags: ["test", "skill"],
     },
   ],
+  defaultInputModes: ["text"],
+  defaultOutputModes: ["text"],
 };
 
 const testParams: ServerDeploymentRequestParams = {
@@ -101,46 +107,52 @@ const fullTestParams: ServerDeploymentRequestParams = {
 };
 
 const message: Message = {
+  messageId: "test-message-id",
+  kind: "message",
   role: "user",
   parts: [
     {
-      type: "text",
+      kind: "text",
       text: "Write a python function to share files remotely. Please be concise and respond with code only. Please use the following format: def share_files(files: list[str]) -> str: ...",
     },
   ],
 };
 const message2: Message = {
+  messageId: "test-message-id-2",
+  kind: "message",
   role: "user",
   parts: [
     {
-      type: "text",
+      kind: "text",
       text: "Write a javascript function to share files remotely. Please be concise and respond with code only. Please use the following format: function share_files(files: string[]) { ... }",
     },
   ],
 };
 
-const sendTaskRequest: SendTaskRequest = {
-  method: "tasks/send",
+const sendTaskRequest: SendMessageRequest = {
+  jsonrpc: "2.0",
+  id: "test-request-1",
+  method: "message/send",
   params: {
-    id: `task-${Date.now()}`,
     message: message,
   },
 };
 
 describe("TestDeployment", () => {
   it("should deploy test logic", async () => {
-    const requests: SendTaskRequest[] = [
+    const requests: SendMessageRequest[] = [
       sendTaskRequest,
       {
-        method: "tasks/send",
+        jsonrpc: "2.0",
+        id: "test-request-2",
+        method: "message/send",
         params: {
-          id: `task-${Date.now()}-2`,
           message: message2,
         },
       },
     ];
     logDebug("testDeployment", "Starting testDeployment test...");
-    const results: (Task | ServerDeploymentResponse)[] = [];
+    const results: (Message | Task | ServerDeploymentResponse)[] = [];
     for await (const result of testDeployment(testParams, requests)) {
       if (result) {
         results.push(result);
@@ -155,18 +167,19 @@ describe("TestDeployment", () => {
   });
 
   it("should bundle and deploy test logic", async () => {
-    const requests: SendTaskRequest[] = [
+    const requests: SendMessageRequest[] = [
       sendTaskRequest,
       {
-        method: "tasks/send",
+        jsonrpc: "2.0",
+        id: "test-request-2",
+        method: "message/send",
         params: {
-          id: `task-${Date.now()}-2`,
           message: message2,
         },
       },
     ];
     logDebug("testDeployment", "Starting testDeployment test...");
-    const results: (Task | ServerDeploymentResponse)[] = [];
+    const results: (Message | Task | ServerDeploymentResponse)[] = [];
     for await (const result of testDeployment(coderTestParams, requests)) {
       logDebug("testDeployment", "Received result:", JSON.stringify(result));
       if (result) {
@@ -181,18 +194,19 @@ describe("TestDeployment", () => {
   }, 90000);
 
   it("should bundle and deploy typescript test logic", async () => {
-    const requests: SendTaskRequest[] = [
+    const requests: SendMessageRequest[] = [
       sendTaskRequest,
       {
-        method: "tasks/send",
+        jsonrpc: "2.0",
+        id: "test-request-2",
+        method: "message/send",
         params: {
-          id: `task-${Date.now()}-2`,
           message: message2,
         },
       },
     ];
     logDebug("testDeployment", "Starting testDeployment test...");
-    const results: (Task | ServerDeploymentResponse)[] = [];
+    const results: (Message | Task | ServerDeploymentResponse)[] = [];
     for await (const result of testDeployment(ts_coderTestParams, requests)) {
       logDebug("testDeployment", "Received result:", JSON.stringify(result));
       if (result) {
@@ -207,18 +221,19 @@ describe("TestDeployment", () => {
   }, 90000);
 
   it("should test nested deployment", async () => {
-    const requests: SendTaskRequest[] = [
+    const requests: SendMessageRequest[] = [
       sendTaskRequest,
       {
-        method: "tasks/send",
+        jsonrpc: "2.0",
+        id: "test-request-2",
+        method: "message/send",
         params: {
-          id: `task-${Date.now()}-2`,
           message: message2,
         },
       },
     ];
     logDebug("testDeployment", "Starting testDeployment test...");
-    const results: (Task | ServerDeploymentResponse)[] = [];
+    const results: (Message | Task | ServerDeploymentResponse)[] = [];
     for await (const result of testDeployment(nestedTestParams, requests)) {
       logDebug("testDeployment", "Received result:", JSON.stringify(result));
       if (result) {
@@ -274,16 +289,16 @@ describe("FullDeployment", () => {
       {},
       "/agentId=0x88a03f820c633d580f37e9dae1487a32ae2f59b42eafe0f8396c5a902507f349/.well-known/agent.json"
     );
-    const params: TaskSendParams = {
+    const params: MessageSendParams = {
       message: message,
-      id: `task-${Date.now()}`,
     };
     const task = await client.sendTask(params);
     logDebug("testDeployment", "task:", JSON.stringify(task));
     expect(task).toBeDefined();
-    expect(task?.status.state).toBe("completed");
+    expect(task?.kind).toBe("task");
+    expect((task as Task).status.state).toBe("completed");
     console.log(task);
-    console.log(task?.status.message);
+    console.log((task as Task).status.message);
     logDebug("testDeployment", "fullDeployment test finished.");
   }, 90000);
 
@@ -294,16 +309,16 @@ describe("FullDeployment", () => {
       {},
       "/0x350dd68abd99508c3acc5c61d889fe2f83e4cb5dc8740af0cf7444be9ca686af/agent-card"
     );
-    const params: TaskSendParams = {
+    const params: MessageSendParams = {
       message: message,
-      id: `task-${Date.now()}`,
     };
     const task = await client.sendTask(params);
     logDebug("testDeployment", "task:", JSON.stringify(task));
     expect(task).toBeDefined();
-    expect(task?.status.state).toBe("completed");
+    expect(task?.kind).toBe("task");
+    expect((task as Task).status.state).toBe("completed");
     console.log(task);
-    console.log(task?.status.message);
+    console.log((task as Task).status.message);
     logDebug("testDeployment", "fullDeployment test finished.");
   }, 90000);
 });
diff --git a/tests/file-storage.test.ts b/tests/file-storage.test.ts
index c7bf2ca..c1a9b1f 100644
--- a/tests/file-storage.test.ts
+++ b/tests/file-storage.test.ts
@@ -31,6 +31,7 @@ describe("FileStore", () => {
     const taskId = "test-task-1";
     const task: Task = {
       id: taskId,
+      kind: "task",
       status: {
         state: "working" as TaskState,
         timestamp: new Date().toISOString(),
@@ -52,6 +53,7 @@ describe("FileStore", () => {
     const taskId = "test-task-2";
     const task: Task = {
       id: taskId,
+      kind: "task",
       status: {
         state: "submitted" as TaskState,
         timestamp: new Date().toISOString(),
@@ -64,16 +66,18 @@ describe("FileStore", () => {
     // Update the task
     const updatedTask: Task = {
       id: taskId,
+      kind: "task",
       status: {
         state: "completed" as TaskState,
         timestamp: new Date().toISOString(),
       },
       artifacts: [
         {
+          artifactId: "test-artifact-id",
           name: "result.txt",
           parts: [
             {
-              type: "text",
+              kind: "text",
               text: "Task completed successfully",
             },
           ],
@@ -108,16 +112,18 @@ describe("FileStore", () => {
 
     const task: Task = {
       id: taskId,
+      kind: "task",
       status: {
         state: "completed" as TaskState,
         timestamp: new Date().toISOString(),
       },
       artifacts: [
         {
+          artifactId: "test-artifact-id",
           name: "example.txt",
           parts: [
             {
-              type: "file",
+              kind: "file",
               file: {
                 name: "example.txt",
                 mimeType: "text/plain",
@@ -140,7 +146,7 @@ describe("FileStore", () => {
     expect(result?.task.artifacts?.length).toBe(1);
 
     const filePart = result?.task.artifacts?.[0].parts[0];
-    expect(filePart?.type).toBe("file");
+    expect(filePart?.kind).toBe("file");
     expect((filePart as any).file.name).toBe("example.txt");
     expect((filePart as any).file.bytes).toBe(fileContent);
   });
@@ -150,25 +156,28 @@ describe("FileStore", () => {
 
     const task: Task = {
       id: taskId,
+      kind: "task",
       status: {
         state: "completed" as TaskState,
         timestamp: new Date().toISOString(),
       },
       artifacts: [
         {
+          artifactId: "test-artifact-id",
           name: "result1.txt",
           parts: [
             {
-              type: "text",
+              kind: "text",
               text: "First result",
             },
           ],
         },
         {
+          artifactId: "test-artifact-id-2",
           name: "result2.txt",
           parts: [
             {
-              type: "text",
+              kind: "text",
               text: "Second result",
             },
           ],
@@ -194,6 +203,7 @@ describe("FileStore", () => {
 
     const task: Task = {
       id: taskId,
+      kind: "task",
       status: {
         state: "completed" as TaskState,
         timestamp: new Date().toISOString(),
@@ -202,19 +212,23 @@ describe("FileStore", () => {
 
     const history: Message[] = [
       {
+        messageId: "test-message-id-1",
+        kind: "message",
         role: "user",
         parts: [
           {
-            type: "text",
+            kind: "text",
             text: "Initial request",
           },
         ],
       },
       {
+        messageId: "test-message-id-2",
+        kind: "message",
         role: "agent",
         parts: [
           {
-            type: "text",
+            kind: "text",
             text: "Agent response",
           },
         ],
diff --git a/tests/http-utils.test.ts b/tests/http-utils.test.ts
index 907161f..e18d622 100644
--- a/tests/http-utils.test.ts
+++ b/tests/http-utils.test.ts
@@ -383,7 +383,7 @@ describe("HTTP Utils", () => {
       } catch (error) {
         // Verify it's an A2AError with the right code
         expect(error instanceof SystemError).toBe(true);
-        expect((error as SystemError).code).toBe(ErrorCodeParseError);
+        expect((error as SystemError<any>).code).toBe(ErrorCodeParseError);
       }
     });
   });
@@ -781,7 +781,7 @@ describe("HTTP Utils", () => {
         parseResponse("invalid json");
       } catch (error) {
         expect(error).toBeInstanceOf(SystemError);
-        expect((error as SystemError).code).toBe(ErrorCodeParseError);
+        expect((error as SystemError<any>).code).toBe(ErrorCodeParseError);
       }
     });
   });
diff --git a/tests/integration.test.ts b/tests/integration.test.ts
index fe28bd4..eaab3a8 100644
--- a/tests/integration.test.ts
+++ b/tests/integration.test.ts
@@ -1,12 +1,24 @@
-import { jest } from "@jest/globals";
+import {
+  jest,
+  describe,
+  beforeEach,
+  afterEach,
+  test,
+  expect,
+} from "@jest/globals";
 import express from "express";
 import {
   A2AClient,
   A2AServer,
   InMemoryTaskStore,
+  Message,
+  Task,
   TaskContext,
-  TaskYieldUpdate,
+  TaskState,
+  UpdateEvent,
   configureLogger,
+  ExecutionContext,
+  MessageSendParams,
 } from "../src/index.js";
 
 // Set a reasonable timeout for all tests
@@ -17,31 +29,50 @@ configureLogger({ level: "silent" });
  * Simple echo task handler for testing
  */
 async function* echoHandler(
-  context: TaskContext
-): AsyncGenerator<TaskYieldUpdate, void, unknown> {
+  context: ExecutionContext
+): AsyncGenerator<UpdateEvent, void, unknown> {
   // Extract user text
-  const userText = context.userMessage.parts
-    .filter((part) => part.type === "text")
+  const params = context.getRequestParams() as MessageSendParams;
+  const taskId = params.message.taskId ?? context.id;
+  const contextId = context.id;
+  const userText = params.message.parts
+    .filter((part) => part.kind === "text")
     .map((part) => (part as any).text)
     .join(" ");
 
   // Send working status
   yield {
-    state: "working",
-    message: {
-      role: "agent",
-      parts: [{ type: "text", text: "Processing..." }],
+    taskId,
+    contextId,
+    kind: "status-update",
+    status: {
+      state: TaskState.Working,
+      message: {
+        messageId: "test-message-id",
+        kind: "message",
+        role: "agent",
+        parts: [{ kind: "text", text: "Processing..." }],
+      },
     },
+    final: false,
   };
-
+  await new Promise((resolve) => setTimeout(resolve, 300));
   // Check cancellation
   if (context.isCancelled()) {
     yield {
-      state: "canceled",
-      message: {
-        role: "agent",
-        parts: [{ type: "text", text: "Task was canceled." }],
+      taskId,
+      contextId,
+      kind: "status-update",
+      status: {
+        state: TaskState.Canceled,
+        message: {
+          messageId: "test-message-id",
+          kind: "message",
+          role: "agent",
+          parts: [{ kind: "text", text: "Task was canceled." }],
+        },
       },
+      final: true,
     };
     return;
   }
@@ -51,16 +82,29 @@ async function* echoHandler(
 
   // Create an artifact
   yield {
-    name: "echo.txt",
-    parts: [{ type: "text", text: response }],
+    taskId,
+    contextId,
+    kind: "artifact-update",
+    artifact: {
+      artifactId: "test-artifact-id",
+      name: "echo.txt",
+      parts: [{ kind: "text", text: response }],
+    },
   };
 
   // Complete the task
   yield {
-    state: "completed",
-    message: {
-      role: "agent",
-      parts: [{ type: "text", text: response }],
+    id: taskId,
+    contextId,
+    kind: "task",
+    status: {
+      state: TaskState.Completed,
+      message: {
+        messageId: "test-message-id",
+        kind: "message",
+        role: "agent",
+        parts: [{ kind: "text", text: response }],
+      },
     },
   };
 }
@@ -114,38 +158,41 @@ describe("Client-Server Integration Tests", () => {
   test("client can send task and get response", async () => {
     const testMessage = "Hello, A2A!";
     const task = await client.sendTask({
-      id: "test-task-1",
       message: {
+        messageId: "test-message-id",
+        kind: "message",
         role: "user",
-        parts: [{ type: "text", text: testMessage }],
+        parts: [{ kind: "text", text: testMessage }],
       },
     });
 
     expect(task).toBeDefined();
-    expect(task!.id).toBe("test-task-1");
-    expect(task!.status.state).toBe("completed");
+    expect(task?.kind).toBe("task");
+    expect((task as Task).status.state).toBe("completed");
 
     // Check if the response message contains our echo
-    const responseText = task!.status.message?.parts
-      .filter((part) => part.type === "text")
+    const responseText = (task as Task).status.message?.parts
+      .filter((part) => part.kind === "text")
       .map((part) => (part as any).text)
       .join(" ");
 
     expect(responseText).toContain(testMessage);
 
     // Check if artifact was created
-    expect(task!.artifacts).toBeDefined();
-    expect(task!.artifacts!.length).toBe(1);
-    expect(task!.artifacts![0].name).toBe("echo.txt");
+    expect((task as Task).artifacts).toBeDefined();
+    expect((task as Task).artifacts!.length).toBe(1);
+    expect((task as Task).artifacts![0].name).toBe("echo.txt");
   });
 
   test("client can stream task updates", async () => {
     const testMessage = "Test streaming";
     const stream = client.sendTaskSubscribe({
-      id: "test-stream-task",
       message: {
+        taskId: "stream-task-test",
+        messageId: "test-message-id",
+        kind: "message",
         role: "user",
-        parts: [{ type: "text", text: testMessage }],
+        parts: [{ kind: "text", text: testMessage }],
       },
     });
 
@@ -180,7 +227,7 @@ describe("Client-Server Integration Tests", () => {
 
     // Verify response text contains our message
     const responseText = lastUpdate.status.message?.parts
-      .filter((part: any) => part.type === "text")
+      .filter((part: any) => part.kind === "text")
       .map((part: any) => part.text)
       .join(" ");
 
@@ -189,41 +236,32 @@ describe("Client-Server Integration Tests", () => {
 
   test("client can cancel a task", async () => {
     // First send a task to create it
-    const task = await client.sendTask({
-      id: "cancel-task-test",
+    const task = client.sendTask({
       message: {
+        taskId: "cancel-task-test",
+        messageId: "test-message-id",
+        kind: "message",
         role: "user",
-        parts: [{ type: "text", text: "Task to be canceled" }],
+        parts: [{ kind: "text", text: "Task to be canceled" }],
       },
     });
 
-    try {
-      // Now try to cancel it (note: in a real scenario this would need to be a long-running task)
-      const canceledTask = await client.cancelTask({
-        id: "cancel-task-test",
-      });
-      console.log("canceledTask", canceledTask);
-      expect(canceledTask).toBeDefined();
-      // Should be in canceled state
-      expect(canceledTask!.status.state).toBe("canceled");
-    } catch (error: any) {
-      // The task might complete too quickly to be canceled, resulting in a "cannot be canceled" error
-      // This is also a valid test scenario
-
-      // The error message should contain the task cannot be canceled text
-      // Not checking the exact error code because it may be wrapped in an internal error
-      expect(error.code).toBe(-32002);
-      expect(error.message).toContain("Task cannot be canceled");
-    }
+    const canceledTask = await client.cancelTask({
+      id: "cancel-task-test",
+    });
+    expect(canceledTask).toBeDefined();
+    expect(canceledTask!.status.state).toBe("canceled");
+    expect(((await task) as Task)?.status.state).toBe("canceled");
   });
 
   test("client can get task by ID", async () => {
-    // First create a task
     await client.sendTask({
-      id: "get-task-test",
       message: {
+        taskId: "get-task-test",
+        messageId: "test-message-id",
+        kind: "message",
         role: "user",
-        parts: [{ type: "text", text: "Task to be retrieved" }],
+        parts: [{ kind: "text", text: "Task to be retrieved" }],
       },
     });
 
diff --git a/tests/register.test.ts b/tests/register.test.ts
index d582f61..4d416ba 100644
--- a/tests/register.test.ts
+++ b/tests/register.test.ts
@@ -38,12 +38,21 @@ describe("register Function", () => {
         stateTransitionHistory: false,
       },
       skills: [
-        { id: "skill1", name: "Skill One", description: "Does one thing" },
-        { id: "skill2", name: "Skill Two", description: "Does another thing" },
+        {
+          id: "skill1",
+          name: "Skill One",
+          description: "Does one thing",
+          tags: [],
+        },
+        {
+          id: "skill2",
+          name: "Skill Two",
+          description: "Does another thing",
+          tags: [],
+        },
       ],
       defaultInputModes: ["text"],
-      defaultOutputModes: ["text"],
-      authentication: undefined, // Explicitly no auth for default test card
+      defaultOutputModes: ["text"], // Explicitly no auth for default test card
       provider: { organization: "Test Org", url: "http://test.org" },
       documentationUrl: "http://docs.test.org",
     };
@@ -122,10 +131,12 @@ describe("register Function", () => {
   });
 
   test("should set endpoint authentication to true if AgentCard has auth schemes", async () => {
-    sampleAgentCard.authentication = {
-      schemes: ["bearer"],
-      credentials: "test-token",
-    };
+    sampleAgentCard.security = [
+      {
+        scheme: ["bearer"],
+        credentials: ["test-token"],
+      },
+    ];
     mockFetch.mockResolvedValueOnce({
       ok: true,
       json: async () => ({
diff --git a/tests/rpc-client.test.ts b/tests/rpc-client.test.ts
index 4e5a5ec..7338aa5 100644
--- a/tests/rpc-client.test.ts
+++ b/tests/rpc-client.test.ts
@@ -242,9 +242,9 @@ describe("RPC Client", () => {
         );
       } catch (error) {
         expect(error).toBeInstanceOf(SystemError);
-        expect((error as SystemError).code).toBe(-32603);
-        expect((error as SystemError).message).toBe("Test error");
-        expect((error as SystemError).data).toEqual({
+        expect((error as SystemError<any>).code).toBe(-32603);
+        expect((error as SystemError<any>).message).toBe("Test error");
+        expect((error as SystemError<any>).data).toEqual({
           detail: "This is a test error",
         });
       }
@@ -328,8 +328,8 @@ describe("RPC Client", () => {
         parseResponseTest(responseText);
       } catch (error) {
         expect(error).toBeInstanceOf(SystemError);
-        expect((error as SystemError).code).toBe(-32000);
-        expect((error as SystemError).message).toBe("Error message");
+        expect((error as SystemError<any>).code).toBe(-32000);
+        expect((error as SystemError<any>).message).toBe("Error message");
       }
     });
   });
diff --git a/tests/server-error-handling.test.ts b/tests/server-error-handling.test.ts
index 8fd6157..a7cceba 100644
--- a/tests/server-error-handling.test.ts
+++ b/tests/server-error-handling.test.ts
@@ -1,11 +1,22 @@
-import { jest } from "@jest/globals";
+import {
+  jest,
+  describe,
+  it,
+  beforeEach,
+  afterEach,
+  expect,
+} from "@jest/globals";
 import express from "express";
 import request from "supertest";
 import {
   A2AServer,
+  ExecutionContext,
   InMemoryTaskStore,
+  Message,
+  MessageSendParams,
   TaskContext,
-  TaskYieldUpdate,
+  TaskState,
+  UpdateEvent,
   configureLogger,
 } from "../src/index.js";
 
@@ -15,10 +26,13 @@ configureLogger({ level: "silent" });
 
 // Define an error-prone task handler for testing
 async function* errorProneTaskHandler(
-  context: TaskContext
-): AsyncGenerator<TaskYieldUpdate, void, unknown> {
-  const text = context.userMessage.parts
-    .filter((part) => part.type === "text")
+  context: ExecutionContext
+): AsyncGenerator<UpdateEvent, void, unknown> {
+  const params = context.getRequestParams() as MessageSendParams;
+  const taskId = params.message.taskId ?? context.id;
+  const contextId = context.id;
+  const text = params.message.parts
+    .filter((part) => part.kind === "text")
     .map((part) => (part as any).text)
     .join(" ");
 
@@ -30,30 +44,54 @@ async function* errorProneTaskHandler(
   // If the message contains "fail", we'll yield a failed state
   if (text.includes("fail")) {
     yield {
-      state: "failed",
-      message: {
-        role: "agent",
-        parts: [{ type: "text", text: "Task failed intentionally." }],
+      taskId: taskId,
+      contextId: contextId,
+      kind: "status-update",
+      status: {
+        state: TaskState.Failed,
+        message: {
+          messageId: "test-message-id",
+          kind: "message",
+          role: "agent",
+          parts: [{ kind: "text", text: "Task failed intentionally." }],
+        } as Message,
       },
+      final: true,
     };
     return;
   }
 
   // Otherwise, normal processing
   yield {
-    state: "working",
-    message: {
-      role: "agent",
-      parts: [{ type: "text", text: "Working..." }],
+    taskId: taskId,
+    contextId: contextId,
+    kind: "status-update",
+    status: {
+      state: TaskState.Working,
+      message: {
+        messageId: "test-message-id",
+        kind: "message",
+        role: "agent",
+        parts: [{ kind: "text", text: "Working..." }],
+      },
     },
+    final: false,
   };
 
   yield {
-    state: "completed",
-    message: {
-      role: "agent",
-      parts: [{ type: "text", text: "Task completed successfully." }],
+    taskId: taskId,
+    contextId: contextId,
+    kind: "status-update",
+    status: {
+      state: TaskState.Completed,
+      message: {
+        messageId: "test-message-id",
+        kind: "message",
+        role: "agent",
+        parts: [{ kind: "text", text: "Task completed successfully." }],
+      },
     },
+    final: true,
   };
 }
 
@@ -101,12 +139,12 @@ describe("A2AServer Error Handling", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "error-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "error-task-1",
           message: {
+            taskId: "error-task-1",
             role: "user",
-            parts: [{ type: "text", text: "This will throw an error" }],
+            parts: [{ kind: "text", text: "This will throw an error" }],
           },
         },
       };
@@ -134,12 +172,12 @@ describe("A2AServer Error Handling", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "fail-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "fail-task-1",
           message: {
+            taskId: "fail-task-1",
             role: "user",
-            parts: [{ type: "text", text: "This will fail" }],
+            parts: [{ kind: "text", text: "This will fail" }],
           },
         },
       };
@@ -202,12 +240,12 @@ describe("A2AServer Error Handling", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "content-type-test",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "content-type-task-1",
           message: {
+            taskId: "content-type-task-1",
             role: "user",
-            parts: [{ type: "text", text: "Testing content type" }],
+            parts: [{ kind: "text", text: "Testing content type" }],
           },
         },
       };
@@ -228,12 +266,12 @@ describe("A2AServer Error Handling", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "charset-test",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "charset-task-1",
           message: {
+            taskId: "charset-task-1",
             role: "user",
-            parts: [{ type: "text", text: "Testing charset" }],
+            parts: [{ kind: "text", text: "Testing charset" }],
           },
         },
       };
diff --git a/tests/server-impl.test.ts b/tests/server-impl.test.ts
index 6cdae3f..1dc065c 100644
--- a/tests/server-impl.test.ts
+++ b/tests/server-impl.test.ts
@@ -1,14 +1,25 @@
-import { jest } from "@jest/globals";
+import {
+  jest,
+  describe,
+  it,
+  beforeEach,
+  afterEach,
+  expect,
+} from "@jest/globals";
 import express from "express";
 import request from "supertest";
 import {
   A2AServer,
   InMemoryTaskStore,
-  TaskContext,
-  TaskYieldUpdate,
+  ExecutionContext,
+  UpdateEvent,
   INTERNAL_ERROR,
   AgentCard,
   configureLogger,
+  TaskYieldUpdate,
+  TaskState,
+  Message,
+  MessageSendParams,
 } from "../src/index.js";
 
 // Set a reasonable timeout for all tests
@@ -17,10 +28,13 @@ configureLogger({ level: "silent" });
 
 // Create a specialized task handler for more coverage testing
 async function* serverImplTestHandler(
-  context: TaskContext
-): AsyncGenerator<TaskYieldUpdate, void, unknown> {
-  const text = context.userMessage.parts
-    .filter((part) => part.type === "text")
+  context: ExecutionContext
+): AsyncGenerator<UpdateEvent, void, unknown> {
+  const params = context.getRequestParams() as MessageSendParams;
+  const taskId = params.message.taskId ?? context.id;
+  const contextId = context.id;
+  const text = params.message.parts
+    .filter((part) => part.kind === "text")
     .map((part) => (part as any).text)
     .join(" ");
 
@@ -32,29 +46,53 @@ async function* serverImplTestHandler(
   // Test for different state transitions in detail
   if (text.includes("streaming")) {
     yield {
-      state: "submitted",
-      message: {
-        role: "agent",
-        parts: [{ type: "text", text: "Task submitted..." }],
+      taskId: taskId,
+      contextId: contextId,
+      kind: "status-update",
+      status: {
+        state: TaskState.Submitted,
+        message: {
+          messageId: "test-message-id",
+          kind: "message",
+          role: "agent",
+          parts: [{ kind: "text", text: "Task submitted..." }],
+        },
       },
+      final: false,
     };
 
     yield {
-      state: "working",
-      message: {
-        role: "agent",
-        parts: [{ type: "text", text: "Working..." }],
+      taskId: taskId,
+      contextId: contextId,
+      kind: "status-update",
+      status: {
+        state: TaskState.Working,
+        message: {
+          messageId: "test-message-id",
+          kind: "message",
+          role: "agent",
+          parts: [{ kind: "text", text: "Working..." }],
+        },
       },
+      final: false,
     };
 
     // Simulate a few more updates
     for (let i = 1; i <= 3; i++) {
       yield {
-        state: "working",
-        message: {
-          role: "agent",
-          parts: [{ type: "text", text: `Still working (${i}/3)...` }],
+        taskId: taskId,
+        contextId: contextId,
+        kind: "status-update",
+        status: {
+          state: TaskState.Working,
+          message: {
+            messageId: "test-message-id",
+            kind: "message",
+            role: "agent",
+            parts: [{ kind: "text", text: `Still working (${i}/3)...` }],
+          },
         },
+        final: false,
       };
 
       // Small delay to simulate processing
@@ -62,30 +100,54 @@ async function* serverImplTestHandler(
     }
 
     yield {
-      state: "completed",
-      message: {
-        role: "agent",
-        parts: [{ type: "text", text: "Task completed successfully!" }],
+      taskId: taskId,
+      contextId: contextId,
+      kind: "status-update",
+      status: {
+        state: TaskState.Completed,
+        message: {
+          messageId: "test-message-id",
+          kind: "message",
+          role: "agent",
+          parts: [{ kind: "text", text: "Task completed successfully!" }],
+        },
       },
+      final: true,
     };
     return;
   }
 
   // Default case
   yield {
-    state: "working",
-    message: {
-      role: "agent",
-      parts: [{ type: "text", text: "Working on it..." }],
+    taskId: taskId,
+    contextId: contextId,
+    kind: "status-update",
+    status: {
+      state: TaskState.Working,
+      message: {
+        messageId: "test-message-id",
+        kind: "message",
+        role: "agent",
+        parts: [{ kind: "text", text: "Working on it..." }],
+      },
     },
+    final: false,
   };
 
   yield {
-    state: "completed",
-    message: {
-      role: "agent",
-      parts: [{ type: "text", text: "Completed!" }],
+    taskId: taskId,
+    contextId: contextId,
+    kind: "status-update",
+    status: {
+      state: TaskState.Completed,
+      message: {
+        messageId: "test-message-id",
+        kind: "message",
+        role: "agent",
+        parts: [{ kind: "text", text: "Completed!" }],
+      },
     },
+    final: true,
   };
 }
 
@@ -109,8 +171,13 @@ describe("Server Implementation Tests", () => {
         {
           id: "test-skill",
           name: "Test Skill",
+          description: "Test skill description",
+          tags: ["test", "skill"],
         },
       ],
+      defaultInputModes: ["text"],
+      defaultOutputModes: ["text"],
+      description: "Test agent description",
     };
 
     server = new A2AServer({
@@ -161,12 +228,12 @@ describe("Server Implementation Tests", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "test-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "test-task-1",
           message: {
+            taskId: "test-task-1",
             role: "user",
-            parts: [{ type: "text", text: "Basic test" }],
+            parts: [{ kind: "text", text: "Basic test" }],
           },
         },
       };
@@ -214,12 +281,12 @@ describe("Server Implementation Tests", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "internal-error-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "internal-error-task-1",
           message: {
+            taskId: "internal-error-task-1",
             role: "user",
-            parts: [{ type: "text", text: "This will throw-internal error" }],
+            parts: [{ kind: "text", text: "This will throw-internal error" }],
           },
         },
       };
@@ -277,7 +344,7 @@ describe("Server Implementation Tests", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "invalid-params-request-1",
-        method: "tasks/send",
+        method: "message/send",
         // Missing params
       };
 
@@ -318,12 +385,12 @@ describe("Server Implementation Tests", () => {
       const createBody = {
         jsonrpc: "2.0",
         id: "history-create-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "history-task-1",
           message: {
+            taskId: "history-task-1",
             role: "user",
-            parts: [{ type: "text", text: "Task for history test" }],
+            parts: [{ kind: "text", text: "Task for history test" }],
           },
         },
       };
@@ -355,13 +422,13 @@ describe("Server Implementation Tests", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "session-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "session-task-1",
-          sessionId: "test-session-123",
           message: {
+            taskId: "session-task-1",
+            contextId: "test-session-123",
             role: "user",
-            parts: [{ type: "text", text: "Task with session ID" }],
+            parts: [{ kind: "text", text: "Task with session ID" }],
           },
         },
       };
@@ -373,19 +440,19 @@ describe("Server Implementation Tests", () => {
       expect(response.status).toBe(200);
       expect(response.body.result).toBeDefined();
       expect(response.body.result.id).toBe("session-task-1");
-      expect(response.body.result.sessionId).toBe("test-session-123");
+      expect(response.body.result.contextId).toBe("test-session-123");
     });
 
     it("includes metadata when provided", async () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "metadata-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "metadata-task-1",
           message: {
+            taskId: "metadata-task-1",
             role: "user",
-            parts: [{ type: "text", text: "Task with metadata" }],
+            parts: [{ kind: "text", text: "Task with metadata" }],
           },
           metadata: {
             testKey: "testValue",
@@ -410,12 +477,12 @@ describe("Server Implementation Tests", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "timestamp-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "timestamp-task-1",
           message: {
+            taskId: "timestamp-task-1",
             role: "user",
-            parts: [{ type: "text", text: "Task for timestamp test" }],
+            parts: [{ kind: "text", text: "Task for timestamp test" }],
           },
         },
       };
diff --git a/tests/server.test.ts b/tests/server.test.ts
index 517e25d..84ccf1d 100644
--- a/tests/server.test.ts
+++ b/tests/server.test.ts
@@ -1,13 +1,23 @@
-import { jest } from "@jest/globals";
+import {
+  describe,
+  beforeEach,
+  afterEach,
+  it,
+  expect,
+  jest,
+} from "@jest/globals";
 import express from "express";
 import request from "supertest";
 import {
   A2AServer,
   InMemoryTaskStore,
-  TaskContext,
-  TaskYieldUpdate,
   TaskStore,
   configureLogger,
+  TaskState,
+  ExecutionContext,
+  AgentEngine,
+  MessageSendParams,
+  logInfo,
 } from "../src/index.js";
 
 // Set a reasonable timeout for all tests
@@ -15,16 +25,27 @@ jest.setTimeout(10000);
 configureLogger({ level: "silent" });
 
 // Define test task handler
-async function* basicTaskHandler(
-  context: TaskContext
-): AsyncGenerator<TaskYieldUpdate, void, unknown> {
+const basicTaskHandler: AgentEngine = async function* (
+  context: ExecutionContext
+) {
+  const params = context.getRequestParams() as MessageSendParams;
+  const taskId = params.message.taskId ?? context.id;
+  const contextId = context.id;
   // Check if task already has status, if not, use "working"
   yield {
-    state: "working",
-    message: {
-      role: "agent",
-      parts: [{ type: "text", text: "Working on it..." }],
+    taskId: taskId,
+    contextId: contextId,
+    kind: "status-update",
+    status: {
+      state: TaskState.Working,
+      message: {
+        messageId: "test-message-id",
+        kind: "message",
+        role: "agent",
+        parts: [{ kind: "text", text: "Working on it..." }],
+      },
     },
+    final: false,
   };
 
   // Simulate some work
@@ -32,27 +53,49 @@ async function* basicTaskHandler(
 
   // Check for cancellation
   if (context.isCancelled()) {
-    yield { state: "canceled" };
+    yield {
+      taskId: taskId,
+      contextId: contextId,
+      kind: "status-update",
+      status: { state: TaskState.Canceled },
+      final: true,
+    };
     return;
   }
-
   // Generate a result artifact
   yield {
-    name: "result.txt",
-    parts: [
-      { type: "text", text: `Task ${context.task.id} completed successfully.` },
-    ],
+    taskId: taskId,
+    contextId: contextId,
+    kind: "artifact-update",
+    artifact: {
+      artifactId: "test-artifact-id",
+      name: "result.txt",
+      parts: [
+        {
+          kind: "text",
+          text: `Task ${contextId} completed successfully.`,
+        },
+      ],
+    },
+    lastChunk: true,
   };
-
   // Final completion status
   yield {
-    state: "completed",
-    message: {
-      role: "agent",
-      parts: [{ type: "text", text: "Task completed successfully!" }],
+    taskId: taskId,
+    contextId: contextId,
+    kind: "status-update",
+    status: {
+      state: TaskState.Completed,
+      message: {
+        messageId: "test-message-id",
+        kind: "message",
+        role: "agent",
+        parts: [{ kind: "text", text: "Task completed successfully!" }],
+      },
     },
+    final: true,
   };
-}
+};
 
 describe("A2AServer", () => {
   let server: A2AServer;
@@ -114,17 +157,17 @@ describe("A2AServer", () => {
     });
   });
 
-  describe("tasks/send", () => {
+  describe("message/send", () => {
     it("handles a valid task send request", async () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "test-request-1",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "test-task-1",
           message: {
+            taskId: "test-task-1",
             role: "user",
-            parts: [{ type: "text", text: "Hello, world!" }],
+            parts: [{ kind: "text", text: "Hello, world!" }],
           },
         },
       };
@@ -147,12 +190,12 @@ describe("A2AServer", () => {
       const invalidRequest = {
         // Missing required jsonrpc field
         id: "invalid-req",
-        method: "tasks/send",
+        method: "message/send",
         params: {
           id: "task-id",
           message: {
             role: "user",
-            parts: [{ type: "text", text: "Test" }],
+            parts: [{ kind: "text", text: "Test" }],
           },
         },
       };
@@ -171,12 +214,12 @@ describe("A2AServer", () => {
       const requestWithoutId = {
         jsonrpc: "2.0",
         id: "missing-id-req",
-        method: "tasks/send",
+        method: "message/send",
         params: {
           // Missing id field
           message: {
-            role: "user",
-            parts: [{ type: "text", text: "Test" }],
+            // role: "user",
+            parts: [{ kind: "text", text: "Test" }],
           },
         },
       };
@@ -198,17 +241,20 @@ describe("A2AServer", () => {
       const createRequest = {
         jsonrpc: "2.0",
         id: "create-req",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "retrieve-task",
           message: {
+            taskId: "retrieve-task",
             role: "user",
-            parts: [{ type: "text", text: "Task to retrieve" }],
+            parts: [{ kind: "text", text: "Task to retrieve" }],
           },
         },
       };
 
-      await trackRequest(request(app).post("/").send(createRequest));
+      const createResponse = await trackRequest(
+        request(app).post("/").send(createRequest)
+      );
+      logInfo("createResponse", createResponse.body);
 
       // Now try to retrieve it
       const getRequest = {
@@ -257,12 +303,12 @@ describe("A2AServer", () => {
       const createRequest = {
         jsonrpc: "2.0",
         id: "create-cancel-req",
-        method: "tasks/send",
+        method: "message/send",
         params: {
-          id: "cancel-task",
           message: {
+            taskId: "cancel-task",
             role: "user",
-            parts: [{ type: "text", text: "Task to cancel" }],
+            parts: [{ kind: "text", text: "Task to cancel" }],
           },
         },
       };
diff --git a/tests/streaming.test.ts b/tests/streaming.test.ts
index f5d2534..8d31c3b 100644
--- a/tests/streaming.test.ts
+++ b/tests/streaming.test.ts
@@ -1,11 +1,21 @@
-import { jest } from "@jest/globals";
+import {
+  jest,
+  describe,
+  it,
+  beforeEach,
+  afterEach,
+  expect,
+} from "@jest/globals";
 import express from "express";
 import request from "supertest";
 import {
   A2AServer,
+  ExecutionContext,
   InMemoryTaskStore,
+  MessageSendParams,
   TaskContext,
-  TaskYieldUpdate,
+  TaskState,
+  UpdateEvent,
   configureLogger,
 } from "../src/index.js";
 
@@ -15,21 +25,32 @@ configureLogger({ level: "silent" });
 
 // Specialized task handler for streaming tests
 async function* streamingTestHandler(
-  context: TaskContext
-): AsyncGenerator<TaskYieldUpdate, void, unknown> {
-  const text = context.userMessage.parts
-    .filter((part) => part.type === "text")
+  context: ExecutionContext
+): AsyncGenerator<UpdateEvent, void, unknown> {
+  const params = context.getRequestParams() as MessageSendParams;
+  const taskId = params.message.taskId ?? context.id;
+  const contextId = context.id;
+  const text = params.message.parts
+    .filter((part) => part.kind === "text")
     .map((part) => (part as any).text)
     .join(" ");
 
   // Quick completion without streaming for non-streaming tests
   if (text.includes("quick")) {
     yield {
-      state: "completed",
-      message: {
-        role: "agent",
-        parts: [{ type: "text", text: "Quick completion" }],
+      taskId: taskId,
+      contextId: contextId,
+      kind: "status-update",
+      status: {
+        state: TaskState.Completed,
+        message: {
+          messageId: "test-message-id",
+          kind: "message",
+          role: "agent",
+          parts: [{ kind: "text", text: "Quick completion" }],
+        },
       },
+      final: true,
     };
     return;
   }
@@ -37,45 +58,79 @@ async function* streamingTestHandler(
   // Test for resubscription
   if (text.includes("resubscribe")) {
     yield {
-      state: "working",
-      message: {
-        role: "agent",
-        parts: [
-          { type: "text", text: "Starting work for resubscribe test..." },
-        ],
+      taskId: taskId,
+      contextId: contextId,
+      kind: "status-update",
+      status: {
+        state: TaskState.Working,
+        message: {
+          messageId: "test-message-id",
+          kind: "message",
+          role: "agent",
+          parts: [
+            { kind: "text", text: "Starting work for resubscribe test..." },
+          ],
+        },
       },
+      final: false,
     };
 
     // Add a small delay to allow for resubscription test
     await new Promise((resolve) => setTimeout(resolve, 100));
 
     yield {
-      state: "completed",
-      message: {
-        role: "agent",
-        parts: [{ type: "text", text: "Completed task for resubscribe test" }],
+      taskId: taskId,
+      contextId: contextId,
+      kind: "status-update",
+      status: {
+        state: TaskState.Completed,
+        message: {
+          messageId: "test-message-id",
+          kind: "message",
+          role: "agent",
+          parts: [
+            { kind: "text", text: "Completed task for resubscribe test" },
+          ],
+        },
       },
+      final: true,
     };
     return;
   }
 
   // Long running task with multiple updates
   yield {
-    state: "submitted",
-    message: {
-      role: "agent",
-      parts: [{ type: "text", text: "Task submitted" }],
+    taskId: taskId,
+    contextId: contextId,
+    kind: "status-update",
+    status: {
+      state: TaskState.Submitted,
+      message: {
+        messageId: "test-message-id",
+        kind: "message",
+        role: "agent",
+        parts: [{ kind: "text", text: "Task submitted" }],
+      },
     },
+    final: false,
   };
 
   // Progress updates
   for (let i = 1; i <= 3; i++) {
     yield {
-      state: "working",
-      message: {
-        role: "agent",
-        parts: [{ type: "text", text: `Progress update ${i}/3` }],
+      taskId: taskId,
+      contextId: contextId,
+      kind: "status-update",
+      status: {
+        state: TaskState.Working,
+        message: {
+          messageId: "test-message-id",
+          kind: "message",
+          role: "agent",
+          parts: [{ kind: "text", text: `Progress update ${i}/3` }],
+        },
       },
+      final: false,
     };
 
     // Small delay to simulate processing
@@ -84,11 +139,19 @@ async function* streamingTestHandler(
 
   // Final completion
   yield {
-    state: "completed",
-    message: {
-      role: "agent",
-      parts: [{ type: "text", text: "Task completed successfully" }],
+    taskId: taskId,
+    contextId: contextId,
+    kind: "status-update",
+    status: {
+      state: TaskState.Completed,
+      message: {
+        messageId: "test-message-id",
+        kind: "message",
+        role: "agent",
+        parts: [{ kind: "text", text: "Task completed successfully" }],
+      },
     },
+    final: true,
   };
 }
 
@@ -115,8 +178,13 @@ describe("Streaming API Tests", () => {
           {
             id: "streaming-test",
             name: "Streaming Test Skill",
+            description: "Streaming Test Skill",
+            tags: ["streaming", "test"],
           },
         ],
+        description: "Streaming Test Agent",
+        defaultInputModes: ["text"],
+        defaultOutputModes: ["text"],
       },
     });
     app = server.start();
@@ -196,17 +264,17 @@ describe("Streaming API Tests", () => {
     });
   };
 
-  describe("tasks/sendSubscribe", () => {
+  describe("message/stream", () => {
     it("establishes a stream and sends events until completion", async () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "stream-request-1",
-        method: "tasks/sendSubscribe",
+        method: "message/stream",
         params: {
-          id: "stream-task-1",
           message: {
+            taskId: "stream-task-1",
             role: "user",
-            parts: [{ type: "text", text: "Test streaming updates" }],
+            parts: [{ kind: "text", text: "Test streaming updates" }],
           },
         },
       };
@@ -260,7 +328,7 @@ describe("Streaming API Tests", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "invalid-stream-1",
-        method: "tasks/sendSubscribe",
+        method: "message/stream",
         params: {
           // Missing id
           message: {
@@ -288,12 +356,12 @@ describe("Streaming API Tests", () => {
       const createBody = {
         jsonrpc: "2.0",
         id: "resubscribe-request-1",
-        method: "tasks/sendSubscribe",
+        method: "message/stream",
         params: {
-          id: "resubscribe-task-1",
           message: {
+            taskId: "resubscribe-task-1",
             role: "user",
-            parts: [{ type: "text", text: "Test for resubscribe" }],
+            parts: [{ kind: "text", text: "Test for resubscribe" }],
           },
         },
       };
@@ -383,7 +451,7 @@ describe("Streaming API Tests", () => {
       const requestBody = {
         jsonrpc: "2.0",
         id: "close-stream-request-1",
-        method: "tasks/sendSubscribe",
+        method: "message/stream",
         params: {
           id: "close-stream-task-1",
           message: {
