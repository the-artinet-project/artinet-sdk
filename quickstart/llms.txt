# Detailed Report: A2A and MCP Integration Proof-of-Concept

## 1. Overall Objective

The primary goal of this proof-of-concept (PoC) as implemented in `quickstart/a2a-mcp.ts` is to demonstrate the integration of Agent-to-Agent (A2A) communication with the Model Context Protocol (MCP). The aim is to create a multi-agent system where:
- Agents can be exposed as A2A services using the `@artinet/sdk`.
- Agents can expose specific functionalities or "skills" as discrete tools via MCP, using `fastmcp` as the MCP server framework.
- Agents can consume MCP tools (provided by themselves or other agents/services) using an MCP client library like `@modelcontextprotocol/sdk`.
- A pattern for integrating Large Language Models (LLMs), such as those accessible via `artinet.v0.connect`, to make intelligent decisions about when and how to use available MCP tools or engage in A2A communication to fulfill user requests.

This creates a flexible architecture where agents can collaborate at a high level (A2A) and also leverage fine-grained, standardized toolsets (MCP).

## 2. Core Technologies & Libraries

-   **`@artinet/sdk`**: The foundational SDK for building and running A2A agents. It provides `A2AServer` for hosting agents, `TaskHandler` for defining agent logic, and types like `AgentCard`, `UpdateEvent`, etc.
-   **`fastmcp`**: A TypeScript framework used to create MCP servers. In this PoC, it's used by `MathAgent` to expose its mathematical functions as MCP tools. (Note: Assumed to be installed via `npm install fastmcp`).
-   **`@modelcontextprotocol/sdk`**: The official TypeScript SDK for MCP. It's used by `OrchestratorAgent` to act as an MCP client, allowing it to connect to and call tools on MCP servers (like the one hosted by `MathAgent`). (Note: Assumed to be installed via `npm install @modelcontextprotocol/sdk`).
-   **`zod`**: A TypeScript-first schema declaration and validation library. Used by `fastmcp` to define the expected parameters for MCP tools. (Note: Assumed to be installed as a dependency of `fastmcp` or separately).
-   **`Node.js http module`**: Used by `fastmcp` under the hood to run its HTTP-based MCP server.

## 3. Agent Architecture

A two-agent system is implemented:

### 3.1. `MathAgent`

-   **Purpose**: A simple agent that provides basic mathematical operations.
-   **A2A Interface (`A2AServer` on port 4001):**
    -   Handles simple A2A text messages.
    -   Can respond to a query like "what is your mcp endpoint?" by providing the URL to its MCP server.
    -   Its `AgentCard` advertises its A2A capabilities and includes custom metadata pointing to its MCP endpoint and available tools.
-   **MCP Provider (`fastmcp` server on port 7071):**
    -   Exposes two tools:
        -   `add`: Takes two numbers (`a`, `b`) and returns their sum.
        -   `subtract`: Takes two numbers (`a`, `b`) and returns `a - b`.
    -   Tool parameters are defined using `zod` schemas.

### 3.2. `OrchestratorAgent`

-   **Purpose**: A more complex agent designed to understand user queries, potentially delegate tasks to other agents (via A2A or MCP), and synthesize responses.
-   **A2A Interface (`A2AServer` on port 4002):**
    -   Accepts natural language queries from a user.
    -   Its `TaskHandler` implements the core orchestration logic.
-   **LLM Integration (Conceptual Design - Currently Simulated):**
    -   The `decideToolCallWithLLM` function outlines how an LLM (like `artinet.v0.connect`) would be used.
    -   The LLM would receive the user query and a list of available tools (including their descriptions and parameters, derived from MCP tool discovery or A2A agent cards).
    -   The LLM's task is to determine:
        1.  If a query can be answered directly.
        2.  If an MCP tool should be called (and if so, which tool and with what arguments).
        3.  If an A2A message should be sent to another agent.
    -   The PoC currently *simulates* the LLM's JSON output for tool calls or direct responses due to the complexities of implementing robust LLM-based tool calling (parsing, error handling, multi-turn reasoning) within this single file.
-   **MCP Consumer (`@modelcontextprotocol/sdk` client):**
    -   An `MCPClient` instance is configured to connect to `MathAgent`'s MCP server URL (`http://localhost:7071`).
    -   The `executeMcpTool` function uses this client to make `callTool` requests to the `MathAgent`.
-   **A2A Communicator (Conceptual/Simulated):**
    -   The `sendA2AMessageToMathAgent` function simulates sending a message to the `MathAgent` via A2A. A full A2A client implementation for this inter-agent communication is not present but would be needed in a production system.

## 4. Key Functionalities Demonstrated

-   **Multi-Agent Setup**: Running two distinct A2A agents (`MathAgent`, `OrchestratorAgent`) simultaneously.
-   **MCP Tool Provision**: `MathAgent` uses `fastmcp` to define and serve `add` and `subtract` tools over HTTP.
-   **MCP Tool Consumption**: `OrchestratorAgent` uses `@modelcontextprotocol/sdk` (`MCPClient` with `HttpConnector`) to connect to `MathAgent`'s MCP server and invoke its tools.
-   **LLM Orchestration Pattern**: A clear (though simulated) pattern for how an LLM could be prompted to select appropriate tools or actions based on user input and available capabilities. This involves formatting tool descriptions for the LLM and parsing its structured (JSON) output.
-   **A2A and MCP Synergy**: Agents communicate via A2A for higher-level tasks or information exchange, while MCP is used for standardized, often stateless, tool invocations. The `OrchestratorAgent` exemplifies this by using its A2A interface for user interaction and then deciding to use MCP for specific calculations.
-   **Agent Card Customization**: The `MathAgent`'s card includes `customProperties` (pending linter fix for exact field name) to advertise its MCP endpoint.
-   **Simulated Inter-Agent A2A**: The `OrchestratorAgent` has a placeholder for sending A2A messages to the `MathAgent`.

## 5. Workflow Example: User asks OrchestratorAgent "What is 5 plus 3?"

1.  User sends an A2A message "What is 5 plus 3?" to `OrchestratorAgent` (running on port 4002).
2.  `OrchestratorAgent`'s `TaskHandler` receives the query.
3.  It calls `decideToolCallWithLLM`.
4.  The (simulated) LLM logic processes the query and the list of available tools (including "add" from `MathAgent`). It determines that the "add" tool should be called with arguments `{ a: 5, b: 3 }`.
5.  `OrchestratorAgent` yields an update indicating it's calling the tool.
6.  It then calls `executeMcpTool("add", { a: 5, b: 3 })`.
7.  The `MCPClient` in `OrchestratorAgent` sends an MCP `ToolCallRequest` over HTTP to `MathAgent`'s `fastmcp` server (listening on port 7071).
8.  `MathAgent`'s `fastmcp` server routes the request to the "add" tool's `execute` function.
9.  The `add` function calculates `5 + 3 = 8` and returns `{ "result": 8 }`.
10. This result is sent back as an MCP `ToolCallResponse` to `OrchestratorAgent`.
11. `executeMcpTool` in `OrchestratorAgent` receives the output `{ "result": 8 }`.
12. The `OrchestratorAgent`'s `TaskHandler` then formats this result into a final answer (e.g., "Tool add executed. Result: {\"result\":8}").
13. `OrchestratorAgent` yields a final `completed` update via A2A to the user with the answer.

## 6. Code Structure (`quickstart/a2a-mcp.ts`)

The file is organized as follows:
-   **Imports**: Necessary modules from `@artinet/sdk`, `fastmcp`, `@modelcontextprotocol/sdk`, `zod`, and `http`.
-   **Configuration**: Constants for ports, URLs, and API keys. Initialization of the Artinet client.
-   **`MathAgent` Section**:
    -   `startMathAgentMcpServer()`: Initializes and starts the `fastmcp` server with "add" and "subtract" tools.
    -   `mathAgentLogic`: The `TaskHandler` for `MathAgent`'s A2A interface.
    -   `mathA2AServer`: `A2AServer` instance for `MathAgent`.
-   **`OrchestratorAgent` Section**:
    -   `orchestratorMcpClient`: `MCPClient` instance configured to connect to `MathAgent`'s MCP server.
    -   `LLMToolCallDecision` interface.
    -   `decideToolCallWithLLM()`: Simulates LLM decision-making.
    -   `executeMcpTool()`: Handles calling MCP tools using the `MCPClient`.
    -   `sendA2AMessageToMathAgent()`: Simulates A2A messaging.
    -   `orchestratorAgentLogic`: The `TaskHandler` for `OrchestratorAgent`.
    -   `orchestratorA2AServer`: `A2AServer` instance for `OrchestratorAgent`.
-   **Main Execution & Test Functions**:
    -   `startAllServices()`: Starts all A2A and MCP servers.
    -   `testAgentQuery()`: A helper function to log how one might test the agents (actual A2A client calls are manual).
    -   `runTests()`: Queues a series of test scenarios by calling `testAgentQuery`.
    -   `main()`: Orchestrates starting services and running tests.
    -   `SIGINT` handler: For graceful shutdown of servers.

## 7. Current Challenges & Linter Errors (Summary from last automated check)

The PoC is currently not fully runnable due to TypeScript compilation errors. These primarily stem from:
-   **Module Not Found**: `fastmcp` and `@modelcontextprotocol/sdk` need to be installed in the project (`npm install fastmcp @modelcontextprotocol/sdk zod`).
-   **`@artinet/sdk` Type Mismatches**:
    -   `Artinet` class import: The linter indicates `Artinet` might not be an exported member, or might be named differently (e.g., `ArtinetClient`).
    -   `MessagePart` type: Similar import issue.
    -   `UpdateEvent`: The structure of objects yielded by `TaskHandler`s (`mathAgentLogic`, `orchestratorAgentLogic`) does not align with the SDK's `UpdateEvent` type. The attempt to create a compatible `ArtinetUpdateEvent` interface also leads to errors. The exact structure of `UpdateEvent` (e.g., whether it uses `state` and `message` directly, or a `type` and `payload` structure) needs to be correctly implemented.
    -   `AgentCard`: The use of `customProperties` (previously `metadata`) is not recognized as a standard field. The correct mechanism for adding arbitrary data to an `AgentCard` in the Artinet SDK needs to be used.
-   **`TaskContext` Property**: Errors indicate `context.taskId` should likely be `context.task.id` (or similar, depending on the actual structure of `context.task`).
-   **Interface Extension**: `interface ArtinetUpdateEvent extends UpdateEvent` causes an error if `UpdateEvent` is not an object type suitable for extension.

## 8. Next Steps (Implied for Full Functionality)

1.  **Dependency Installation**: Ensure all external libraries (`fastmcp`, `@modelcontextprotocol/sdk`, `zod`) are installed.
2.  **Resolve Linter Errors**:
    -   Correct import statements for `Artinet` and `MessagePart` from `@artinet/sdk`.
    -   Accurately define and use the `UpdateEvent` structure as expected by `@artinet/sdk`'s `TaskHandler`.
    -   Use the correct property for accessing the task ID from `TaskContext`.
    -   Use the correct mechanism for storing custom data in `AgentCard` or find an alternative method to share MCP endpoint information.
3.  **Implement Real LLM Calls**: Replace the simulated LLM logic in `decideToolCallWithLLM` with actual calls to `artinet.v0.connect` (or a similar LLM service). This will involve crafting precise prompts and robustly parsing LLM JSON outputs, including error handling.
4.  **Implement A2A Client for Inter-Agent Communication**: Replace `sendA2AMessageToMathAgent` simulation with actual A2A client logic, potentially using components from `@artinet/sdk` if available for client-side A2A calls, or a general HTTP client if A2A tasks are initiated via simple POST requests.
5.  **Enhance Error Handling**: Add more robust error handling throughout, especially for network requests (MCP calls, A2A calls, LLM calls).
6.  **Refine Tool Discovery**: Instead of hardcoding the `mathAgentTools` list in `OrchestratorAgent`, implement dynamic discovery (e.g., by querying `MathAgent`'s A2A card or a hypothetical MCP discovery endpoint).
7.  **Expand Test Suite**: Create comprehensive automated tests for all functionalities. The current `testAgentQuery` is a mock and relies on manual inspection of logs or external A2A client tools.
